
C:\Users\Vindar\AppData\Local\Temp\VMBuilds\SARCASM\teensy41\Release/SARCASM.ino.elf:     file format elf32-littlearm


Disassembly of section .text.code:

60001400 <memory_copy>:
	if (dest == src) return;
	do {
		*dest++ = *src++;
	} while (dest < dest_end);
#else
	asm volatile(
60001400:	4281      	cmp	r1, r0
60001402:	d005      	beq.n	60001410 <memory_copy+0x10>
60001404:	f851 3b04 	ldr.w	r3, [r1], #4
60001408:	f840 3b04 	str.w	r3, [r0], #4
6000140c:	4282      	cmp	r2, r0
6000140e:	d8f9      	bhi.n	60001404 <memory_copy+0x4>
	"	cmp	%[end], %[dest]		\n"
	"	bhi.n	1b			\n"
	"2:					\n"
	: [dest] "+r" (dest), [src] "+r" (src) : [end] "r" (dest_end) : "r3", "memory");
#endif
}
60001410:	4770      	bx	lr

60001412 <memory_clear.constprop.0>:
#if 0
	while (dest < dest_end) {
		*dest++ = 0;
	}
#else
	asm volatile(
60001412:	4a04      	ldr	r2, [pc, #16]	; (60001424 <memory_clear.constprop.0+0x12>)
60001414:	4904      	ldr	r1, [pc, #16]	; (60001428 <memory_clear.constprop.0+0x16>)
60001416:	f04f 0300 	mov.w	r3, #0
6000141a:	f842 3b04 	str.w	r3, [r2], #4
6000141e:	4291      	cmp	r1, r2
60001420:	d8fb      	bhi.n	6000141a <memory_clear.constprop.0+0x8>
	"1:	str.w	r3, [%[dest]], #4	\n"
	"	cmp	%[end], %[dest]		\n"
	"	bhi.n	1b			\n"
	: [dest] "+r" (dest) : [end] "r" (dest_end) : "r3", "memory");
#endif
}
60001422:	4770      	bx	lr
60001424:	2000d2c0 	.word	0x2000d2c0
60001428:	200447a0 	.word	0x200447a0

6000142c <ResetHandler2>:
{
6000142c:	b580      	push	{r7, lr}
	__asm__ volatile("dsb":::"memory");
6000142e:	f3bf 8f4f 	dsb	sy
	asm volatile("nop");
60001432:	bf00      	nop
	asm volatile("nop");
60001434:	bf00      	nop
	asm volatile("nop");
60001436:	bf00      	nop
	asm volatile("nop");
60001438:	bf00      	nop
	startup_early_hook(); // must be in FLASHMEM, as ITCM is not yet initialized!
6000143a:	f039 fa47 	bl	6003a8cc <startup_default_early_hook>
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000143e:	4b65      	ldr	r3, [pc, #404]	; (600015d4 <ResetHandler2+0x1a8>)
60001440:	2208      	movs	r2, #8
60001442:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
	asm volatile("nop");
60001446:	bf00      	nop
	asm volatile("nop");
60001448:	bf00      	nop
	asm volatile("nop");
6000144a:	bf00      	nop
	asm volatile("nop");
6000144c:	bf00      	nop
	asm volatile("nop");
6000144e:	bf00      	nop
	asm volatile("nop");
60001450:	bf00      	nop
	asm volatile("nop");
60001452:	bf00      	nop
	asm volatile("nop");
60001454:	bf00      	nop
	asm volatile("nop");
60001456:	bf00      	nop
	asm volatile("nop");
60001458:	bf00      	nop
	asm volatile("nop");
6000145a:	bf00      	nop
	asm volatile("nop");
6000145c:	bf00      	nop
	asm volatile("nop");
6000145e:	bf00      	nop
	asm volatile("nop");
60001460:	bf00      	nop
	asm volatile("nop");
60001462:	bf00      	nop
	asm volatile("nop");
60001464:	bf00      	nop
	memory_copy(&_stext, &_stextload, &_etext);
60001466:	4a5c      	ldr	r2, [pc, #368]	; (600015d8 <ResetHandler2+0x1ac>)
60001468:	495c      	ldr	r1, [pc, #368]	; (600015dc <ResetHandler2+0x1b0>)
6000146a:	485d      	ldr	r0, [pc, #372]	; (600015e0 <ResetHandler2+0x1b4>)
6000146c:	f7ff ffc8 	bl	60001400 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
60001470:	4a5c      	ldr	r2, [pc, #368]	; (600015e4 <ResetHandler2+0x1b8>)
60001472:	495d      	ldr	r1, [pc, #372]	; (600015e8 <ResetHandler2+0x1bc>)
60001474:	485d      	ldr	r0, [pc, #372]	; (600015ec <ResetHandler2+0x1c0>)
60001476:	f7ff ffc3 	bl	60001400 <memory_copy>
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000147a:	4d5d      	ldr	r5, [pc, #372]	; (600015f0 <ResetHandler2+0x1c4>)
	memory_clear(&_sbss, &_ebss);
6000147c:	f7ff ffc9 	bl	60001412 <memory_clear.constprop.0>
	SCB_CPACR = 0x00F00000;
60001480:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
60001484:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
60001488:	f8c3 2d88 	str.w	r2, [r3, #3464]	; 0xd88
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
6000148c:	2300      	movs	r3, #0
6000148e:	4a59      	ldr	r2, [pc, #356]	; (600015f4 <ResetHandler2+0x1c8>)
60001490:	f845 2023 	str.w	r2, [r5, r3, lsl #2]
60001494:	3301      	adds	r3, #1
60001496:	2bb0      	cmp	r3, #176	; 0xb0
60001498:	d1fa      	bne.n	60001490 <ResetHandler2+0x64>
6000149a:	4b57      	ldr	r3, [pc, #348]	; (600015f8 <ResetHandler2+0x1cc>)
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
6000149c:	2180      	movs	r1, #128	; 0x80
6000149e:	4a57      	ldr	r2, [pc, #348]	; (600015fc <ResetHandler2+0x1d0>)
600014a0:	f803 1b01 	strb.w	r1, [r3], #1
600014a4:	4293      	cmp	r3, r2
600014a6:	d1fb      	bne.n	600014a0 <ResetHandler2+0x74>
	SCB_VTOR = (uint32_t)_VectorsRam;
600014a8:	f04f 20e0 	mov.w	r0, #3758153728	; 0xe000e000
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014ac:	4c49      	ldr	r4, [pc, #292]	; (600015d4 <ResetHandler2+0x1a8>)
600014ae:	f04f 3780 	mov.w	r7, #2155905152	; 0x80808080
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014b2:	f8df 9178 	ldr.w	r9, [pc, #376]	; 6000162c <ResetHandler2+0x200>
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014b6:	f8df 8178 	ldr.w	r8, [pc, #376]	; 60001630 <ResetHandler2+0x204>
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014ba:	f04f 32ff 	mov.w	r2, #4294967295
	SCB_VTOR = (uint32_t)_VectorsRam;
600014be:	f8c0 5d08 	str.w	r5, [r0, #3336]	; 0xd08
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
600014c2:	f8c4 7104 	str.w	r7, [r4, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
600014c6:	f8c4 9100 	str.w	r9, [r4, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
600014ca:	f8c4 70f4 	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
600014ce:	f8c4 80f0 	str.w	r8, [r4, #240]	; 0xf0
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014d2:	f8d0 3d24 	ldr.w	r3, [r0, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014d6:	4e4a      	ldr	r6, [pc, #296]	; (60001600 <ResetHandler2+0x1d4>)
	SCB_SHCSR |= SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_USGFAULTENA;
600014d8:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
600014dc:	f8c0 3d24 	str.w	r3, [r0, #3364]	; 0xd24
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600014e0:	69f3      	ldr	r3, [r6, #28]
600014e2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014e6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014ea:	61f3      	str	r3, [r6, #28]
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600014ec:	6a73      	ldr	r3, [r6, #36]	; 0x24
600014ee:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600014f2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600014f6:	6273      	str	r3, [r6, #36]	; 0x24
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600014f8:	4b42      	ldr	r3, [pc, #264]	; (60001604 <ResetHandler2+0x1d8>)
600014fa:	669a      	str	r2, [r3, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600014fc:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600014fe:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
60001500:	675a      	str	r2, [r3, #116]	; 0x74
	configure_cache();
60001502:	f039 f9e8 	bl	6003a8d6 <configure_cache>
	_VectorsRam[14] = pendablesrvreq_isr;
60001506:	4b40      	ldr	r3, [pc, #256]	; (60001608 <ResetHandler2+0x1dc>)
60001508:	63ab      	str	r3, [r5, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
6000150a:	4b40      	ldr	r3, [pc, #256]	; (6000160c <ResetHandler2+0x1e0>)
6000150c:	63eb      	str	r3, [r5, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
6000150e:	2363      	movs	r3, #99	; 0x63
	SYST_CVR = 0;
60001510:	2500      	movs	r5, #0
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
60001512:	6143      	str	r3, [r0, #20]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001514:	2303      	movs	r3, #3
	SYST_CVR = 0;
60001516:	6185      	str	r5, [r0, #24]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
60001518:	6103      	str	r3, [r0, #16]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
6000151a:	4b3d      	ldr	r3, [pc, #244]	; (60001610 <ResetHandler2+0x1e4>)
6000151c:	f8c0 3d20 	str.w	r3, [r0, #3360]	; 0xd20
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
60001520:	f8d0 3dfc 	ldr.w	r3, [r0, #3580]	; 0xdfc
60001524:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
60001528:	f8c0 3dfc 	str.w	r3, [r0, #3580]	; 0xdfc
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
6000152c:	4b39      	ldr	r3, [pc, #228]	; (60001614 <ResetHandler2+0x1e8>)
6000152e:	681a      	ldr	r2, [r3, #0]
60001530:	f042 0201 	orr.w	r2, r2, #1
60001534:	601a      	str	r2, [r3, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
60001536:	685a      	ldr	r2, [r3, #4]
60001538:	4b37      	ldr	r3, [pc, #220]	; (60001618 <ResetHandler2+0x1ec>)
6000153a:	601a      	str	r2, [r3, #0]
	usb_pll_start();	
6000153c:	f039 fb8e 	bl	6003ac5c <usb_pll_start>
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
60001540:	f8c4 7104 	str.w	r7, [r4, #260]	; 0x104
	set_arm_clock(F_CPU);
60001544:	4835      	ldr	r0, [pc, #212]	; (6000161c <ResetHandler2+0x1f0>)
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001546:	f8c4 9100 	str.w	r9, [r4, #256]	; 0x100
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000154a:	f8c4 70f4 	str.w	r7, [r4, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
6000154e:	f8c4 80f0 	str.w	r8, [r4, #240]	; 0xf0
	set_arm_clock(F_CPU);
60001552:	f03a fb71 	bl	6003bc38 <__set_arm_clock_veneer>
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
60001556:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
60001558:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
6000155c:	66f3      	str	r3, [r6, #108]	; 0x6c
	PIT_MCR = 0;
6000155e:	4b30      	ldr	r3, [pc, #192]	; (60001620 <ResetHandler2+0x1f4>)
60001560:	601d      	str	r5, [r3, #0]
	PIT_TCTRL0 = 0;
60001562:	f8c3 5108 	str.w	r5, [r3, #264]	; 0x108
	PIT_TCTRL1 = 0;
60001566:	f8c3 5118 	str.w	r5, [r3, #280]	; 0x118
	PIT_TCTRL2 = 0;
6000156a:	f8c3 5128 	str.w	r5, [r3, #296]	; 0x128
	PIT_TCTRL3 = 0;
6000156e:	f8c3 5138 	str.w	r5, [r3, #312]	; 0x138
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001572:	f503 23a0 	add.w	r3, r3, #327680	; 0x50000
60001576:	6b9a      	ldr	r2, [r3, #56]	; 0x38
60001578:	07d2      	lsls	r2, r2, #31
6000157a:	d408      	bmi.n	6000158e <ResetHandler2+0x162>
		SNVS_LPSRTCLR = 1546300800u << 15;
6000157c:	4a29      	ldr	r2, [pc, #164]	; (60001624 <ResetHandler2+0x1f8>)
6000157e:	655a      	str	r2, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
60001580:	f642 6215 	movw	r2, #11797	; 0x2e15
60001584:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001586:	6b9a      	ldr	r2, [r3, #56]	; 0x38
60001588:	f042 0201 	orr.w	r2, r2, #1
6000158c:	639a      	str	r2, [r3, #56]	; 0x38
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
6000158e:	689a      	ldr	r2, [r3, #8]
// Returns the number of milliseconds since your program started running.
// This 32 bit number will roll back to zero after about 49.7 days.  For a
// simpler way to build delays or timeouts, consider using elapsedMillis.
static inline uint32_t millis(void)
{
	return systick_millis_count;
60001590:	4c25      	ldr	r4, [pc, #148]	; (60001628 <ResetHandler2+0x1fc>)
60001592:	f042 1201 	orr.w	r2, r2, #65537	; 0x10001
60001596:	609a      	str	r2, [r3, #8]
	configure_external_ram();
60001598:	f039 fa26 	bl	6003a9e8 <configure_external_ram>
	analog_init();
6000159c:	f039 fcbe 	bl	6003af1c <analog_init>
	pwm_init();
600015a0:	f039 fcfe 	bl	6003afa0 <__pwm_init_veneer>
	tempmon_init();
600015a4:	f039 fb88 	bl	6003acb8 <tempmon_init>
	startup_middle_hook();
600015a8:	f039 f991 	bl	6003a8ce <startup_default_middle_hook>
600015ac:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015ae:	2b13      	cmp	r3, #19
600015b0:	d9fc      	bls.n	600015ac <ResetHandler2+0x180>
	usb_init();
600015b2:	f039 fc17 	bl	6003ade4 <usb_init>
600015b6:	6823      	ldr	r3, [r4, #0]
	while (millis() < TEENSY_INIT_USB_DELAY_AFTER + TEENSY_INIT_USB_DELAY_BEFORE) ; // wait
600015b8:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
600015bc:	d3fb      	bcc.n	600015b6 <ResetHandler2+0x18a>
	startup_debug_reset();
600015be:	f039 f988 	bl	6003a8d2 <startup_debug_reset>
	startup_late_hook();
600015c2:	f039 f985 	bl	6003a8d0 <startup_default_late_hook>
	__libc_init_array();
600015c6:	f039 fe83 	bl	6003b2d0 <____libc_init_array_veneer>
	main();
600015ca:	f008 fcaf 	bl	60009f2c <main>
	while (1) asm("WFI");
600015ce:	bf30      	wfi
600015d0:	e7fd      	b.n	600015ce <ResetHandler2+0x1a2>
600015d2:	bf00      	nop
600015d4:	400d8000 	.word	0x400d8000
600015d8:	00030d68 	.word	0x00030d68
600015dc:	6072cc84 	.word	0x6072cc84
600015e0:	00000000 	.word	0x00000000
600015e4:	2000d2c0 	.word	0x2000d2c0
600015e8:	6075d9f0 	.word	0x6075d9f0
600015ec:	20000000 	.word	0x20000000
600015f0:	2000d000 	.word	0x2000d000
600015f4:	0002743d 	.word	0x0002743d
600015f8:	e000e400 	.word	0xe000e400
600015fc:	e000e4a0 	.word	0xe000e4a0
60001600:	400fc000 	.word	0x400fc000
60001604:	400ac000 	.word	0x400ac000
60001608:	00025695 	.word	0x00025695
6000160c:	000256f9 	.word	0x000256f9
60001610:	20200000 	.word	0x20200000
60001614:	e0001000 	.word	0xe0001000
60001618:	2001a5d0 	.word	0x2001a5d0
6000161c:	2aea5400 	.word	0x2aea5400
60001620:	40084000 	.word	0x40084000
60001624:	56c00000 	.word	0x56c00000
60001628:	2001a5d4 	.word	0x2001a5d4
6000162c:	2018101b 	.word	0x2018101b
60001630:	13110d0c 	.word	0x13110d0c

60001634 <ResetHandler>:
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001634:	4b05      	ldr	r3, [pc, #20]	; (6000164c <ResetHandler+0x18>)
60001636:	4a06      	ldr	r2, [pc, #24]	; (60001650 <ResetHandler+0x1c>)
60001638:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
6000163a:	4a06      	ldr	r2, [pc, #24]	; (60001654 <ResetHandler+0x20>)
6000163c:	641a      	str	r2, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
6000163e:	f44f 022a 	mov.w	r2, #11141120	; 0xaa0000
60001642:	639a      	str	r2, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : "memory");
60001644:	4b04      	ldr	r3, [pc, #16]	; (60001658 <ResetHandler+0x24>)
60001646:	469d      	mov	sp, r3
	ResetHandler2();
60001648:	f7ff fef0 	bl	6000142c <ResetHandler2>
6000164c:	400ac000 	.word	0x400ac000
60001650:	aaaabfff 	.word	0xaaaabfff
60001654:	00200007 	.word	0x00200007
60001658:	20048000 	.word	0x20048000

6000165c <alloc_pool>:
)
	{
	char* rp = 0;


	ndata = (ndata + 3) & ~3;			/* Align block size to the word boundary */
6000165c:	3103      	adds	r1, #3

	if (jd->sz_pool >= ndata) {
6000165e:	6f43      	ldr	r3, [r0, #116]	; 0x74
	ndata = (ndata + 3) & ~3;			/* Align block size to the word boundary */
60001660:	f021 0103 	bic.w	r1, r1, #3
	if (jd->sz_pool >= ndata) {
60001664:	428b      	cmp	r3, r1
		jd->sz_pool -= ndata;
60001666:	bf29      	itett	cs
60001668:	1a5b      	subcs	r3, r3, r1
	char* rp = 0;
6000166a:	2300      	movcc	r3, #0
		jd->sz_pool -= ndata;
6000166c:	6743      	strcs	r3, [r0, #116]	; 0x74
		rp = (char*)jd->pool;			/* Get start of available memory pool */
6000166e:	6f03      	ldrcs	r3, [r0, #112]	; 0x70
		jd->pool = (void*)(rp + ndata);	/* Allocate requierd bytes */
60001670:	bf24      	itt	cs
60001672:	18c9      	addcs	r1, r1, r3
60001674:	6701      	strcs	r1, [r0, #112]	; 0x70
		}

	return (void*)rp;	/* Return allocated memory block (NULL:no memory to allocate) */
	}
60001676:	4618      	mov	r0, r3
60001678:	4770      	bx	lr

6000167a <huffext>:
SLOWFUN static int huffext(	/* >=0: decoded data, <0: error code */
	JDEC* jd,			/* Pointer to the decompressor object */
	unsigned int id,	/* Table ID (0:Y, 1:C) */
	unsigned int cls	/* Table class (0:DC, 1:AC) */
)
	{
6000167a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
6000167e:	4604      	mov	r4, r0
60001680:	4615      	mov	r5, r2

#else
	const uint8_t* hb, * hd;
	const uint16_t* hc;
	unsigned int nc, bl, wbit = jd->dbit % 32;
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
60001682:	f04f 32ff 	mov.w	r2, #4294967295
	{
60001686:	468a      	mov	sl, r1
	unsigned int nc, bl, wbit = jd->dbit % 32;
60001688:	7b27      	ldrb	r7, [r4, #12]
	unsigned int d, flg = 0;
6000168a:	f04f 0900 	mov.w	r9, #0
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
6000168e:	6e21      	ldr	r1, [r4, #96]	; 0x60
	unsigned int nc, bl, wbit = jd->dbit % 32;
60001690:	f007 071f 	and.w	r7, r7, #31
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
60001694:	40ba      	lsls	r2, r7
	uint8_t* dp = jd->dptr;
60001696:	e9d0 0600 	ldrd	r0, r6, [r0]
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
6000169a:	ea21 0802 	bic.w	r8, r1, r2


	while (wbit < 16) {	/* Prepare 16 bits into the working register */
6000169e:	2f0f      	cmp	r7, #15
600016a0:	d919      	bls.n	600016d6 <huffext+0x5c>
				}
			}
		w = w << 8 | d;	/* Shift 8 bits in the working register */
		wbit += 8;
		}
	jd->dctr = dc; jd->dptr = dp;
600016a2:	eb05 054a 	add.w	r5, r5, sl, lsl #1
	jd->wreg = w;
600016a6:	f8c4 8060 	str.w	r8, [r4, #96]	; 0x60
#else
	/* Incremental serch for all codes */
	hb = jd->huffbits[id][cls];	/* Bit distribution table */
	hc = jd->huffcode[id][cls];	/* Code word table */
	hd = jd->huffdata[id][cls];	/* Data table */
	bl = 1;
600016aa:	2301      	movs	r3, #1
600016ac:	eb04 0585 	add.w	r5, r4, r5, lsl #2
	jd->dctr = dc; jd->dptr = dp;
600016b0:	e9c4 0600 	strd	r0, r6, [r4]
	hb = jd->huffbits[id][cls];	/* Bit distribution table */
600016b4:	6a2e      	ldr	r6, [r5, #32]
	hc = jd->huffcode[id][cls];	/* Code word table */
600016b6:	6b28      	ldr	r0, [r5, #48]	; 0x30
	hd = jd->huffdata[id][cls];	/* Data table */
600016b8:	6c29      	ldr	r1, [r5, #64]	; 0x40
#endif
	for (; bl <= 16; bl++) {	/* Incremental search */
		nc = *hb++;
600016ba:	f816 2b01 	ldrb.w	r2, [r6], #1
		if (nc) {
600016be:	b38a      	cbz	r2, 60001724 <huffext+0xaa>
			d = w >> (wbit - bl);
600016c0:	1afd      	subs	r5, r7, r3
600016c2:	fa28 fc05 	lsr.w	ip, r8, r5
			do {	/* Search the code word in this bit length */
				if (d == *hc++) {		/* Matched? */
600016c6:	f830 eb02 	ldrh.w	lr, [r0], #2
600016ca:	45e6      	cmp	lr, ip
600016cc:	d126      	bne.n	6000171c <huffext+0xa2>
					jd->dbit = wbit - bl;	/* Snip the huffman code */
600016ce:	7325      	strb	r5, [r4, #12]
					return *hd;			/* Return the decoded data */
600016d0:	7808      	ldrb	r0, [r1, #0]
			}
		}
#endif

	return 0 - (int)JDR_FMT1;	/* Err: code not found (may be collapted data) */
	}
600016d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (jd->marker) {
600016d6:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
600016da:	b99a      	cbnz	r2, 60001704 <huffext+0x8a>
			if (!dc) {	/* Buffer empty, re-fill input buffer */
600016dc:	b938      	cbnz	r0, 600016ee <huffext+0x74>
				dp = jd->inbuf;						/* Top of input buffer */
600016de:	68a6      	ldr	r6, [r4, #8]
				dc = jd->infunc(jd, dp, JD_SZBUF);
600016e0:	f44f 6280 	mov.w	r2, #1024	; 0x400
600016e4:	6fa3      	ldr	r3, [r4, #120]	; 0x78
600016e6:	4620      	mov	r0, r4
600016e8:	4631      	mov	r1, r6
600016ea:	4798      	blx	r3
				if (!dc) return 0 - (int)JDR_INP;	/* Err: read error or wrong stream termination */
600016ec:	b300      	cbz	r0, 60001730 <huffext+0xb6>
			d = *dp++; dc--;
600016ee:	f816 2b01 	ldrb.w	r2, [r6], #1
600016f2:	3801      	subs	r0, #1
			if (flg) {		/* In flag sequence? */
600016f4:	f1b9 0f00 	cmp.w	r9, #0
600016f8:	d009      	beq.n	6000170e <huffext+0x94>
				if (d != 0) jd->marker = d;	/* Not an escape of 0xFF but a marker */
600016fa:	b16a      	cbz	r2, 60001718 <huffext+0x9e>
				flg = 0;	/* Exit flag sequence */
600016fc:	f04f 0900 	mov.w	r9, #0
				if (d != 0) jd->marker = d;	/* Not an escape of 0xFF but a marker */
60001700:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
				d = 0xFF;
60001704:	22ff      	movs	r2, #255	; 0xff
		w = w << 8 | d;	/* Shift 8 bits in the working register */
60001706:	ea42 2808 	orr.w	r8, r2, r8, lsl #8
		wbit += 8;
6000170a:	3708      	adds	r7, #8
6000170c:	e7c7      	b.n	6000169e <huffext+0x24>
				if (d == 0xFF) {		/* Is start of flag sequence? */
6000170e:	2aff      	cmp	r2, #255	; 0xff
60001710:	d1f9      	bne.n	60001706 <huffext+0x8c>
					flg = 1; continue;	/* Enter flag sequence, get trailing byte */
60001712:	f04f 0901 	mov.w	r9, #1
60001716:	e7c2      	b.n	6000169e <huffext+0x24>
				flg = 0;	/* Exit flag sequence */
60001718:	4691      	mov	r9, r2
6000171a:	e7f3      	b.n	60001704 <huffext+0x8a>
				} while (--nc);
6000171c:	3a01      	subs	r2, #1
				hd++;
6000171e:	f101 0101 	add.w	r1, r1, #1
				} while (--nc);
60001722:	d1d0      	bne.n	600016c6 <huffext+0x4c>
	for (; bl <= 16; bl++) {	/* Incremental search */
60001724:	3301      	adds	r3, #1
60001726:	2b11      	cmp	r3, #17
60001728:	d1c7      	bne.n	600016ba <huffext+0x40>
	return 0 - (int)JDR_FMT1;	/* Err: code not found (may be collapted data) */
6000172a:	f06f 0005 	mvn.w	r0, #5
6000172e:	e7d0      	b.n	600016d2 <huffext+0x58>
				if (!dc) return 0 - (int)JDR_INP;	/* Err: read error or wrong stream termination */
60001730:	f06f 0001 	mvn.w	r0, #1
60001734:	e7cd      	b.n	600016d2 <huffext+0x58>

60001736 <bitext>:

SLOWFUN static int bitext(	/* >=0: extracted data, <0: error code */
	JDEC* jd,			/* Pointer to the decompressor object */
	unsigned int nbit	/* Number of bits to extract (1 to 16) */
)
	{
60001736:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
6000173a:	4604      	mov	r4, r0
	jd->dbit = mbit; jd->dctr = dc; jd->dptr = dp;
	return (int)d;

#else
	unsigned int wbit = jd->dbit % 32;
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
6000173c:	f04f 32ff 	mov.w	r2, #4294967295
	{
60001740:	4688      	mov	r8, r1
	unsigned int d, flg = 0;
60001742:	f04f 0900 	mov.w	r9, #0
	unsigned int wbit = jd->dbit % 32;
60001746:	7b25      	ldrb	r5, [r4, #12]
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
60001748:	6e26      	ldr	r6, [r4, #96]	; 0x60
	unsigned int wbit = jd->dbit % 32;
6000174a:	f005 051f 	and.w	r5, r5, #31
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
6000174e:	40aa      	lsls	r2, r5
	uint8_t* dp = jd->dptr;
60001750:	e9d0 0700 	ldrd	r0, r7, [r0]
	uint32_t w = jd->wreg & ((1UL << wbit) - 1);
60001754:	ea26 0602 	bic.w	r6, r6, r2


	while (wbit < nbit) {	/* Prepare nbit bits into the working register */
60001758:	4545      	cmp	r5, r8
6000175a:	d30b      	bcc.n	60001774 <bitext+0x3e>
				}
			}
		w = w << 8 | d;	/* Get 8 bits into the working register */
		wbit += 8;
		}
	jd->wreg = w; jd->dbit = wbit - nbit;
6000175c:	eba5 0508 	sub.w	r5, r5, r8
60001760:	6626      	str	r6, [r4, #96]	; 0x60
60001762:	7325      	strb	r5, [r4, #12]
	jd->dctr = dc; jd->dptr = dp;

	return (int)(w >> ((wbit - nbit) % 32));
60001764:	f005 051f 	and.w	r5, r5, #31
	jd->dctr = dc; jd->dptr = dp;
60001768:	e9c4 0700 	strd	r0, r7, [r4]
	return (int)(w >> ((wbit - nbit) % 32));
6000176c:	fa26 f005 	lsr.w	r0, r6, r5
#endif
	}
60001770:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (jd->marker) {
60001774:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
60001778:	b99a      	cbnz	r2, 600017a2 <bitext+0x6c>
			if (!dc) {	/* Buffer empty, re-fill input buffer */
6000177a:	b938      	cbnz	r0, 6000178c <bitext+0x56>
				dp = jd->inbuf;	/* Top of input buffer */
6000177c:	68a7      	ldr	r7, [r4, #8]
				dc = jd->infunc(jd, dp, JD_SZBUF);
6000177e:	f44f 6280 	mov.w	r2, #1024	; 0x400
60001782:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001784:	4620      	mov	r0, r4
60001786:	4639      	mov	r1, r7
60001788:	4798      	blx	r3
				if (!dc) return 0 - (int)JDR_INP;	/* Err: read error or wrong stream termination */
6000178a:	b1b0      	cbz	r0, 600017ba <bitext+0x84>
			d = *dp++; dc--;
6000178c:	f817 2b01 	ldrb.w	r2, [r7], #1
60001790:	3801      	subs	r0, #1
			if (flg) {		/* In flag sequence? */
60001792:	f1b9 0f00 	cmp.w	r9, #0
60001796:	d009      	beq.n	600017ac <bitext+0x76>
				if (d != 0) jd->marker = d;	/* Not an escape of 0xFF but a marker */
60001798:	b16a      	cbz	r2, 600017b6 <bitext+0x80>
				flg = 0;	/* Exit flag sequence */
6000179a:	f04f 0900 	mov.w	r9, #0
				if (d != 0) jd->marker = d;	/* Not an escape of 0xFF but a marker */
6000179e:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
				d = 0xFF;
600017a2:	22ff      	movs	r2, #255	; 0xff
		w = w << 8 | d;	/* Get 8 bits into the working register */
600017a4:	ea42 2606 	orr.w	r6, r2, r6, lsl #8
		wbit += 8;
600017a8:	3508      	adds	r5, #8
600017aa:	e7d5      	b.n	60001758 <bitext+0x22>
				if (d == 0xFF) {		/* Is start of flag sequence? */
600017ac:	2aff      	cmp	r2, #255	; 0xff
600017ae:	d1f9      	bne.n	600017a4 <bitext+0x6e>
					flg = 1; continue;	/* Enter flag sequence, get trailing byte */
600017b0:	f04f 0901 	mov.w	r9, #1
600017b4:	e7d0      	b.n	60001758 <bitext+0x22>
				flg = 0;	/* Exit flag sequence */
600017b6:	4691      	mov	r9, r2
600017b8:	e7f3      	b.n	600017a2 <bitext+0x6c>
				if (!dc) return 0 - (int)JDR_INP;	/* Err: read error or wrong stream termination */
600017ba:	f06f 0001 	mvn.w	r0, #1
600017be:	e7d7      	b.n	60001770 <bitext+0x3a>

600017c0 <jd_prepare>:
	size_t(*infunc)(JDEC*, uint8_t*, size_t),	/* JPEG strem input function */
	void* pool,				/* Working buffer for the decompression session */
	size_t sz_pool,			/* Size of working buffer */
	void* dev				/* I/O device identifier for the session */
)
	{
600017c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
600017c4:	b085      	sub	sp, #20
600017c6:	460d      	mov	r5, r1
600017c8:	4617      	mov	r7, r2
	unsigned int n, i, ofs;
	size_t len;
	JRESULT rc;


	memset(jd, 0, sizeof(JDEC));	/* Clear decompression object (this might be a problem if machine's null pointer is not all bits zero) */
600017ca:	2100      	movs	r1, #0
600017cc:	2280      	movs	r2, #128	; 0x80
	{
600017ce:	4604      	mov	r4, r0
600017d0:	461e      	mov	r6, r3
	memset(jd, 0, sizeof(JDEC));	/* Clear decompression object (this might be a problem if machine's null pointer is not all bits zero) */
600017d2:	f039 fcb1 	bl	6003b138 <__memset_veneer>
	jd->pool = pool;		/* Work memroy */
	jd->sz_pool = sz_pool;	/* Size of given work memory */
	jd->infunc = infunc;	/* Stream input function */
	jd->device = dev;		/* I/O device identifier */
600017d6:	9b0e      	ldr	r3, [sp, #56]	; 0x38

	jd->inbuf = seg = alloc_pool(jd, JD_SZBUF);		/* Allocate stream input buffer */
600017d8:	f44f 6180 	mov.w	r1, #1024	; 0x400
	jd->infunc = infunc;	/* Stream input function */
600017dc:	67a5      	str	r5, [r4, #120]	; 0x78
	jd->inbuf = seg = alloc_pool(jd, JD_SZBUF);		/* Allocate stream input buffer */
600017de:	4620      	mov	r0, r4
	jd->device = dev;		/* I/O device identifier */
600017e0:	67e3      	str	r3, [r4, #124]	; 0x7c
	jd->sz_pool = sz_pool;	/* Size of given work memory */
600017e2:	e9c4 761c 	strd	r7, r6, [r4, #112]	; 0x70
	jd->inbuf = seg = alloc_pool(jd, JD_SZBUF);		/* Allocate stream input buffer */
600017e6:	f7ff ff39 	bl	6000165c <alloc_pool>
600017ea:	4605      	mov	r5, r0
600017ec:	60a0      	str	r0, [r4, #8]
	if (!seg) return JDR_MEM1;
600017ee:	2800      	cmp	r0, #0
600017f0:	f000 80c0 	beq.w	60001974 <jd_prepare+0x1b4>

	ofs = marker = 0;		/* Find SOI marker */
600017f4:	2300      	movs	r3, #0
	do {
		if (jd->infunc(jd, seg, 1) != 1) return JDR_INP;	/* Err: SOI was not detected */
		ofs++;
		marker = marker << 8 | seg[0];
		} while (marker != 0xFFD8);
600017f6:	f64f 78d8 	movw	r8, #65496	; 0xffd8
	ofs = marker = 0;		/* Find SOI marker */
600017fa:	461f      	mov	r7, r3
600017fc:	9300      	str	r3, [sp, #0]
		if (jd->infunc(jd, seg, 1) != 1) return JDR_INP;	/* Err: SOI was not detected */
600017fe:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001800:	2201      	movs	r2, #1
60001802:	4629      	mov	r1, r5
60001804:	4620      	mov	r0, r4
60001806:	4798      	blx	r3
60001808:	2801      	cmp	r0, #1
6000180a:	d001      	beq.n	60001810 <jd_prepare+0x50>
			case 0xD9:	/* EOI */
				return JDR_FMT3;	/* Unsuppoted JPEG standard (may be progressive JPEG) */

			default:	/* Unknown segment (comment, exif or etc..) */
				/* Skip segment data (null pointer specifies to remove data from the stream) */
				if (jd->infunc(jd, 0, len) != len) return JDR_INP;
6000180c:	2002      	movs	r0, #2
6000180e:	e191      	b.n	60001b34 <jd_prepare+0x374>
		ofs++;
60001810:	9b00      	ldr	r3, [sp, #0]
60001812:	3301      	adds	r3, #1
60001814:	9300      	str	r3, [sp, #0]
		marker = marker << 8 | seg[0];
60001816:	782b      	ldrb	r3, [r5, #0]
60001818:	ea43 2707 	orr.w	r7, r3, r7, lsl #8
6000181c:	b2bf      	uxth	r7, r7
		} while (marker != 0xFFD8);
6000181e:	4547      	cmp	r7, r8
60001820:	d1ed      	bne.n	600017fe <jd_prepare+0x3e>
		if (jd->infunc(jd, seg, 4) != 4) return JDR_INP;
60001822:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001824:	2204      	movs	r2, #4
60001826:	4629      	mov	r1, r5
60001828:	4620      	mov	r0, r4
6000182a:	4798      	blx	r3
6000182c:	2804      	cmp	r0, #4
6000182e:	d1ed      	bne.n	6000180c <jd_prepare+0x4c>
		len = LDB_WORD(seg + 2);	/* Length field */
60001830:	886a      	ldrh	r2, [r5, #2]
60001832:	882b      	ldrh	r3, [r5, #0]
60001834:	ba52      	rev16	r2, r2
60001836:	ba5b      	rev16	r3, r3
60001838:	b292      	uxth	r2, r2
6000183a:	b29b      	uxth	r3, r3
		if (len <= 2 || (marker >> 8) != 0xFF) return JDR_FMT1;
6000183c:	2a02      	cmp	r2, #2
6000183e:	f240 8083 	bls.w	60001948 <jd_prepare+0x188>
60001842:	0a19      	lsrs	r1, r3, #8
60001844:	29ff      	cmp	r1, #255	; 0xff
60001846:	d17f      	bne.n	60001948 <jd_prepare+0x188>
		ofs += 4 + len;		/* Number of bytes loaded */
60001848:	9900      	ldr	r1, [sp, #0]
		len -= 2;			/* Segent content size */
6000184a:	f1a2 0802 	sub.w	r8, r2, #2
		ofs += 4 + len;		/* Number of bytes loaded */
6000184e:	b2db      	uxtb	r3, r3
60001850:	3202      	adds	r2, #2
		switch (marker & 0xFF) {
60001852:	2bda      	cmp	r3, #218	; 0xda
		ofs += 4 + len;		/* Number of bytes loaded */
60001854:	4411      	add	r1, r2
60001856:	9100      	str	r1, [sp, #0]
		switch (marker & 0xFF) {
60001858:	f000 8122 	beq.w	60001aa0 <jd_prepare+0x2e0>
6000185c:	d843      	bhi.n	600018e6 <jd_prepare+0x126>
6000185e:	3bc0      	subs	r3, #192	; 0xc0
60001860:	b298      	uxth	r0, r3
60001862:	2819      	cmp	r0, #25
60001864:	d844      	bhi.n	600018f0 <jd_prepare+0x130>
60001866:	2301      	movs	r3, #1
60001868:	4ab4      	ldr	r2, [pc, #720]	; (60001b3c <jd_prepare+0x37c>)
6000186a:	4083      	lsls	r3, r0
6000186c:	ea13 0702 	ands.w	r7, r3, r2
60001870:	d148      	bne.n	60001904 <jd_prepare+0x144>
60001872:	2804      	cmp	r0, #4
60001874:	d058      	beq.n	60001928 <jd_prepare+0x168>
60001876:	07db      	lsls	r3, r3, #31
60001878:	d53a      	bpl.n	600018f0 <jd_prepare+0x130>
				if (len > JD_SZBUF) return JDR_MEM2;
6000187a:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
6000187e:	f200 8183 	bhi.w	60001b88 <jd_prepare+0x3c8>
				if (jd->infunc(jd, seg, len) != len) return JDR_INP;	/* Load segment data */
60001882:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001884:	4642      	mov	r2, r8
60001886:	4629      	mov	r1, r5
60001888:	4620      	mov	r0, r4
6000188a:	4798      	blx	r3
6000188c:	4540      	cmp	r0, r8
6000188e:	d1bd      	bne.n	6000180c <jd_prepare+0x4c>
				jd->width = LDB_WORD(&seg[3]);		/* Image width in unit of pixel */
60001890:	f8b5 3003 	ldrh.w	r3, [r5, #3]
60001894:	ba5b      	rev16	r3, r3
60001896:	83a3      	strh	r3, [r4, #28]
				jd->height = LDB_WORD(&seg[1]);		/* Image height in unit of pixel */
60001898:	f8b5 3001 	ldrh.w	r3, [r5, #1]
6000189c:	ba5b      	rev16	r3, r3
6000189e:	83e3      	strh	r3, [r4, #30]
				jd->ncomp = seg[5];					/* Number of color components */
600018a0:	7969      	ldrb	r1, [r5, #5]
				if (jd->ncomp != 3 && jd->ncomp != 1) return JDR_FMT3;	/* Err: Supports only Grayscale and Y/Cb/Cr */
600018a2:	f001 03fd 	and.w	r3, r1, #253	; 0xfd
				jd->ncomp = seg[5];					/* Number of color components */
600018a6:	74e1      	strb	r1, [r4, #19]
				if (jd->ncomp != 3 && jd->ncomp != 1) return JDR_FMT3;	/* Err: Supports only Grayscale and Y/Cb/Cr */
600018a8:	2b01      	cmp	r3, #1
600018aa:	d12b      	bne.n	60001904 <jd_prepare+0x144>
600018ac:	462a      	mov	r2, r5
600018ae:	f104 000f 	add.w	r0, r4, #15
				for (i = 0; i < jd->ncomp; i++) {
600018b2:	42b9      	cmp	r1, r7
600018b4:	d9b5      	bls.n	60001822 <jd_prepare+0x62>
					b = seg[7 + 3 * i];							/* Get sampling factor */
600018b6:	79d3      	ldrb	r3, [r2, #7]
					if (i == 0) {	/* Y component */
600018b8:	bb17      	cbnz	r7, 60001900 <jd_prepare+0x140>
						if (b != 0x11 && b != 0x22 && b != 0x21) {	/* Check sampling factor */
600018ba:	2b11      	cmp	r3, #17
600018bc:	d004      	beq.n	600018c8 <jd_prepare+0x108>
600018be:	f1a3 0c21 	sub.w	ip, r3, #33	; 0x21
600018c2:	f1bc 0f01 	cmp.w	ip, #1
600018c6:	d81d      	bhi.n	60001904 <jd_prepare+0x144>
						jd->msx = b >> 4; jd->msy = b & 15;		/* Size of MCU [blocks] */
600018c8:	ea4f 1c13 	mov.w	ip, r3, lsr #4
600018cc:	f003 030f 	and.w	r3, r3, #15
600018d0:	f884 c00e 	strb.w	ip, [r4, #14]
600018d4:	73e3      	strb	r3, [r4, #15]
					jd->qtid[i] = seg[8 + 3 * i];				/* Get dequantizer table ID for this component */
600018d6:	7a13      	ldrb	r3, [r2, #8]
					if (jd->qtid[i] > 3) return JDR_FMT3;		/* Err: Invalid ID */
600018d8:	3203      	adds	r2, #3
600018da:	2b03      	cmp	r3, #3
					jd->qtid[i] = seg[8 + 3 * i];				/* Get dequantizer table ID for this component */
600018dc:	f800 3f01 	strb.w	r3, [r0, #1]!
					if (jd->qtid[i] > 3) return JDR_FMT3;		/* Err: Invalid ID */
600018e0:	d810      	bhi.n	60001904 <jd_prepare+0x144>
				for (i = 0; i < jd->ncomp; i++) {
600018e2:	3701      	adds	r7, #1
600018e4:	e7e5      	b.n	600018b2 <jd_prepare+0xf2>
		switch (marker & 0xFF) {
600018e6:	2bdb      	cmp	r3, #219	; 0xdb
600018e8:	f000 809d 	beq.w	60001a26 <jd_prepare+0x266>
600018ec:	2bdd      	cmp	r3, #221	; 0xdd
600018ee:	d00b      	beq.n	60001908 <jd_prepare+0x148>
				if (jd->infunc(jd, 0, len) != len) return JDR_INP;
600018f0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
600018f2:	4642      	mov	r2, r8
600018f4:	2100      	movs	r1, #0
600018f6:	4620      	mov	r0, r4
600018f8:	4798      	blx	r3
600018fa:	4540      	cmp	r0, r8
600018fc:	d091      	beq.n	60001822 <jd_prepare+0x62>
600018fe:	e785      	b.n	6000180c <jd_prepare+0x4c>
						if (b != 0x11) return JDR_FMT3;			/* Err: Sampling factor of Cb/Cr must be 1 */
60001900:	2b11      	cmp	r3, #17
60001902:	d0e8      	beq.n	600018d6 <jd_prepare+0x116>
				if (seg[0] != jd->ncomp) return JDR_FMT3;		/* Err: Wrong color components */
60001904:	2008      	movs	r0, #8
60001906:	e115      	b.n	60001b34 <jd_prepare+0x374>
				if (len > JD_SZBUF) return JDR_MEM2;
60001908:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
6000190c:	f200 8112 	bhi.w	60001b34 <jd_prepare+0x374>
				if (jd->infunc(jd, seg, len) != len) return JDR_INP;	/* Load segment data */
60001910:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001912:	4642      	mov	r2, r8
60001914:	4629      	mov	r1, r5
60001916:	4620      	mov	r0, r4
60001918:	4798      	blx	r3
6000191a:	4540      	cmp	r0, r8
6000191c:	f47f af76 	bne.w	6000180c <jd_prepare+0x4c>
				jd->nrst = LDB_WORD(seg);	/* Get restart interval (MCUs) */
60001920:	882b      	ldrh	r3, [r5, #0]
60001922:	ba5b      	rev16	r3, r3
60001924:	8363      	strh	r3, [r4, #26]
				break;
60001926:	e77c      	b.n	60001822 <jd_prepare+0x62>
				if (len > JD_SZBUF) return JDR_MEM2;
60001928:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
6000192c:	f200 8102 	bhi.w	60001b34 <jd_prepare+0x374>
				if (jd->infunc(jd, seg, len) != len) return JDR_INP;	/* Load segment data */
60001930:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001932:	4642      	mov	r2, r8
60001934:	4629      	mov	r1, r5
60001936:	4620      	mov	r0, r4
60001938:	4798      	blx	r3
6000193a:	4540      	cmp	r0, r8
6000193c:	f47f af66 	bne.w	6000180c <jd_prepare+0x4c>
60001940:	462f      	mov	r7, r5
		if (ndata < 17) return JDR_FMT1;	/* Err: wrong data size */
60001942:	f1b8 0f10 	cmp.w	r8, #16
60001946:	d801      	bhi.n	6000194c <jd_prepare+0x18c>
		if (len <= 2 || (marker >> 8) != 0xFF) return JDR_FMT1;
60001948:	2006      	movs	r0, #6
6000194a:	e0f3      	b.n	60001b34 <jd_prepare+0x374>
		d = *data++;						/* Get table number and class */
6000194c:	46ba      	mov	sl, r7
		ndata -= 17;
6000194e:	f1a8 0311 	sub.w	r3, r8, #17
		d = *data++;						/* Get table number and class */
60001952:	f81a 8b01 	ldrb.w	r8, [sl], #1
		ndata -= 17;
60001956:	9301      	str	r3, [sp, #4]
		if (d & 0xEE) return JDR_FMT1;		/* Err: invalid class/number */
60001958:	f018 02ee 	ands.w	r2, r8, #238	; 0xee
6000195c:	d1f4      	bne.n	60001948 <jd_prepare+0x188>
		cls = d >> 4; num = d & 0x0F;		/* class = dc(0)/ac(1), table number = 0/1 */
6000195e:	ea4f 1318 	mov.w	r3, r8, lsr #4
		pb = alloc_pool(jd, 16);			/* Allocate a memory block for the bit distribution table */
60001962:	2110      	movs	r1, #16
60001964:	4620      	mov	r0, r4
60001966:	f008 080f 	and.w	r8, r8, #15
		cls = d >> 4; num = d & 0x0F;		/* class = dc(0)/ac(1), table number = 0/1 */
6000196a:	9302      	str	r3, [sp, #8]
		pb = alloc_pool(jd, 16);			/* Allocate a memory block for the bit distribution table */
6000196c:	f7ff fe76 	bl	6000165c <alloc_pool>
		if (!pb) return JDR_MEM1;			/* Err: not enough memory */
60001970:	4681      	mov	r9, r0
60001972:	b908      	cbnz	r0, 60001978 <jd_prepare+0x1b8>
	if (!seg) return JDR_MEM1;
60001974:	2003      	movs	r0, #3
60001976:	e0dd      	b.n	60001b34 <jd_prepare+0x374>
		jd->huffbits[num][cls] = pb;
60001978:	2302      	movs	r3, #2
6000197a:	3711      	adds	r7, #17
6000197c:	4619      	mov	r1, r3
6000197e:	9b02      	ldr	r3, [sp, #8]
60001980:	fb11 3808 	smlabb	r8, r1, r8, r3
60001984:	eb04 0b88 	add.w	fp, r4, r8, lsl #2
60001988:	f100 38ff 	add.w	r8, r0, #4294967295
6000198c:	4641      	mov	r1, r8
6000198e:	f8cb 0020 	str.w	r0, [fp, #32]
			np += (pb[i] = *data++);		/* Get sum of code words for each code */
60001992:	f81a 3b01 	ldrb.w	r3, [sl], #1
		for (np = i = 0; i < 16; i++) {		/* Load number of patterns for 1 to 16-bit code */
60001996:	4557      	cmp	r7, sl
			np += (pb[i] = *data++);		/* Get sum of code words for each code */
60001998:	441a      	add	r2, r3
6000199a:	f801 3f01 	strb.w	r3, [r1, #1]!
		for (np = i = 0; i < 16; i++) {		/* Load number of patterns for 1 to 16-bit code */
6000199e:	d1f8      	bne.n	60001992 <jd_prepare+0x1d2>
		ph = alloc_pool(jd, np * sizeof(uint16_t));/* Allocate a memory block for the code word table */
600019a0:	0051      	lsls	r1, r2, #1
600019a2:	4620      	mov	r0, r4
600019a4:	f7ff fe5a 	bl	6000165c <alloc_pool>
		if (!ph) return JDR_MEM1;			/* Err: not enough memory */
600019a8:	4601      	mov	r1, r0
600019aa:	2800      	cmp	r0, #0
600019ac:	d0e2      	beq.n	60001974 <jd_prepare+0x1b4>
		jd->huffcode[num][cls] = ph;
600019ae:	f109 030f 	add.w	r3, r9, #15
600019b2:	f8cb 0030 	str.w	r0, [fp, #48]	; 0x30
		for (j = i = 0; i < 16; i++) {		/* Re-build huffman code word table */
600019b6:	2000      	movs	r0, #0
600019b8:	9303      	str	r3, [sp, #12]
		hc = 0;
600019ba:	4603      	mov	r3, r0
			b = pb[i];
600019bc:	f818 cf01 	ldrb.w	ip, [r8, #1]!
			while (b--) ph[j++] = hc++;
600019c0:	eb01 0a40 	add.w	sl, r1, r0, lsl #1
600019c4:	4699      	mov	r9, r3
			b = pb[i];
600019c6:	46e6      	mov	lr, ip
			while (b--) ph[j++] = hc++;
600019c8:	f1be 0e01 	subs.w	lr, lr, #1
600019cc:	d21b      	bcs.n	60001a06 <jd_prepare+0x246>
600019ce:	4463      	add	r3, ip
		for (j = i = 0; i < 16; i++) {		/* Re-build huffman code word table */
600019d0:	9e03      	ldr	r6, [sp, #12]
600019d2:	4460      	add	r0, ip
			hc <<= 1;
600019d4:	b29b      	uxth	r3, r3
		for (j = i = 0; i < 16; i++) {		/* Re-build huffman code word table */
600019d6:	4546      	cmp	r6, r8
			hc <<= 1;
600019d8:	ea4f 0343 	mov.w	r3, r3, lsl #1
600019dc:	b29b      	uxth	r3, r3
		for (j = i = 0; i < 16; i++) {		/* Re-build huffman code word table */
600019de:	d1ed      	bne.n	600019bc <jd_prepare+0x1fc>
		if (ndata < np) return JDR_FMT1;	/* Err: wrong data size */
600019e0:	9b01      	ldr	r3, [sp, #4]
600019e2:	4293      	cmp	r3, r2
600019e4:	d3b0      	bcc.n	60001948 <jd_prepare+0x188>
		pd = alloc_pool(jd, np);			/* Allocate a memory block for the decoded data */
600019e6:	4611      	mov	r1, r2
600019e8:	4620      	mov	r0, r4
600019ea:	f7ff fe37 	bl	6000165c <alloc_pool>
		if (!pd) return JDR_MEM1;			/* Err: not enough memory */
600019ee:	2800      	cmp	r0, #0
600019f0:	d0c0      	beq.n	60001974 <jd_prepare+0x1b4>
		jd->huffdata[num][cls] = pd;
600019f2:	1881      	adds	r1, r0, r2
600019f4:	f8cb 0040 	str.w	r0, [fp, #64]	; 0x40
		for (i = 0; i < np; i++) {			/* Load decoded data corresponds to each code word */
600019f8:	4288      	cmp	r0, r1
600019fa:	d10b      	bne.n	60001a14 <jd_prepare+0x254>
	while (ndata) {	/* Process all tables in the segment */
600019fc:	9b01      	ldr	r3, [sp, #4]
600019fe:	ebb3 0802 	subs.w	r8, r3, r2
60001a02:	d19e      	bne.n	60001942 <jd_prepare+0x182>
60001a04:	e70d      	b.n	60001822 <jd_prepare+0x62>
			while (b--) ph[j++] = hc++;
60001a06:	f109 0601 	add.w	r6, r9, #1
60001a0a:	f82a 9b02 	strh.w	r9, [sl], #2
60001a0e:	fa1f f986 	uxth.w	r9, r6
60001a12:	e7d9      	b.n	600019c8 <jd_prepare+0x208>
			if (!cls && d > 11) return JDR_FMT1;
60001a14:	9e02      	ldr	r6, [sp, #8]
			d = *data++;
60001a16:	f817 3b01 	ldrb.w	r3, [r7], #1
			if (!cls && d > 11) return JDR_FMT1;
60001a1a:	b90e      	cbnz	r6, 60001a20 <jd_prepare+0x260>
60001a1c:	2b0b      	cmp	r3, #11
60001a1e:	d893      	bhi.n	60001948 <jd_prepare+0x188>
			pd[i] = d;
60001a20:	f800 3b01 	strb.w	r3, [r0], #1
		for (i = 0; i < np; i++) {			/* Load decoded data corresponds to each code word */
60001a24:	e7e8      	b.n	600019f8 <jd_prepare+0x238>
				if (len > JD_SZBUF) return JDR_MEM2;
60001a26:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
60001a2a:	f200 8083 	bhi.w	60001b34 <jd_prepare+0x374>
				if (jd->infunc(jd, seg, len) != len) return JDR_INP;	/* Load segment data */
60001a2e:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001a30:	4642      	mov	r2, r8
60001a32:	4629      	mov	r1, r5
60001a34:	4620      	mov	r0, r4
60001a36:	4798      	blx	r3
60001a38:	4540      	cmp	r0, r8
60001a3a:	f47f aee7 	bne.w	6000180c <jd_prepare+0x4c>
60001a3e:	f105 0241 	add.w	r2, r5, #65	; 0x41
		if (ndata < 65) return JDR_FMT1;	/* Err: table size is unaligned */
60001a42:	f1b8 0f40 	cmp.w	r8, #64	; 0x40
60001a46:	f67f af7f 	bls.w	60001948 <jd_prepare+0x188>
		d = *data++;							/* Get table property */
60001a4a:	f812 3c41 	ldrb.w	r3, [r2, #-65]
		ndata -= 65;
60001a4e:	f1a8 0841 	sub.w	r8, r8, #65	; 0x41
		d = *data++;							/* Get table property */
60001a52:	f1a2 0740 	sub.w	r7, r2, #64	; 0x40
		if (d & 0xF0) return JDR_FMT1;			/* Err: not 8-bit resolution */
60001a56:	f013 0ff0 	tst.w	r3, #240	; 0xf0
60001a5a:	f47f af75 	bne.w	60001948 <jd_prepare+0x188>
		pb = alloc_pool(jd, 64 * sizeof(int32_t));/* Allocate a memory block for the table */
60001a5e:	f44f 7180 	mov.w	r1, #256	; 0x100
60001a62:	4620      	mov	r0, r4
		i = d & 3;								/* Get table ID */
60001a64:	f003 0903 	and.w	r9, r3, #3
		pb = alloc_pool(jd, 64 * sizeof(int32_t));/* Allocate a memory block for the table */
60001a68:	f7ff fdf8 	bl	6000165c <alloc_pool>
		if (!pb) return JDR_MEM1;				/* Err: not enough memory */
60001a6c:	2800      	cmp	r0, #0
60001a6e:	d081      	beq.n	60001974 <jd_prepare+0x1b4>
		jd->qttbl[i] = pb;						/* Register the table */
60001a70:	f109 0314 	add.w	r3, r9, #20
60001a74:	f8df c0cc 	ldr.w	ip, [pc, #204]	; 60001b44 <jd_prepare+0x384>
60001a78:	f844 0023 	str.w	r0, [r4, r3, lsl #2]
			zi = Zig[i];						/* Zigzag-order to raster-order conversion */
60001a7c:	f81c 1b01 	ldrb.w	r1, [ip], #1
			pb[zi] = (int32_t)((uint32_t)*data++ * Ipsf[zi]);	/* Apply scale factor of Arai algorithm to the de-quantizers */
60001a80:	4e2f      	ldr	r6, [pc, #188]	; (60001b40 <jd_prepare+0x380>)
60001a82:	f817 3b01 	ldrb.w	r3, [r7], #1
60001a86:	f836 e011 	ldrh.w	lr, [r6, r1, lsl #1]
		for (i = 0; i < 64; i++) {				/* Load the table */
60001a8a:	4297      	cmp	r7, r2
			pb[zi] = (int32_t)((uint32_t)*data++ * Ipsf[zi]);	/* Apply scale factor of Arai algorithm to the de-quantizers */
60001a8c:	fb0e f303 	mul.w	r3, lr, r3
60001a90:	f840 3021 	str.w	r3, [r0, r1, lsl #2]
		for (i = 0; i < 64; i++) {				/* Load the table */
60001a94:	d1f2      	bne.n	60001a7c <jd_prepare+0x2bc>
	while (ndata) {	/* Process all tables in the segment */
60001a96:	3241      	adds	r2, #65	; 0x41
60001a98:	f1b8 0f00 	cmp.w	r8, #0
60001a9c:	d1d1      	bne.n	60001a42 <jd_prepare+0x282>
60001a9e:	e6c0      	b.n	60001822 <jd_prepare+0x62>
				if (len > JD_SZBUF) return JDR_MEM2;
60001aa0:	f5b8 6f80 	cmp.w	r8, #1024	; 0x400
60001aa4:	d846      	bhi.n	60001b34 <jd_prepare+0x374>
				if (jd->infunc(jd, seg, len) != len) return JDR_INP;	/* Load segment data */
60001aa6:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001aa8:	4642      	mov	r2, r8
60001aaa:	4629      	mov	r1, r5
60001aac:	4620      	mov	r0, r4
60001aae:	4798      	blx	r3
60001ab0:	4540      	cmp	r0, r8
60001ab2:	f47f aeab 	bne.w	6000180c <jd_prepare+0x4c>
				if (!jd->width || !jd->height) return JDR_FMT1;	/* Err: Invalid image size */
60001ab6:	8ba3      	ldrh	r3, [r4, #28]
60001ab8:	2b00      	cmp	r3, #0
60001aba:	f43f af45 	beq.w	60001948 <jd_prepare+0x188>
60001abe:	8be3      	ldrh	r3, [r4, #30]
60001ac0:	2b00      	cmp	r3, #0
60001ac2:	f43f af41 	beq.w	60001948 <jd_prepare+0x188>
				if (seg[0] != jd->ncomp) return JDR_FMT3;		/* Err: Wrong color components */
60001ac6:	7ce1      	ldrb	r1, [r4, #19]
60001ac8:	782b      	ldrb	r3, [r5, #0]
60001aca:	428b      	cmp	r3, r1
60001acc:	f47f af1a 	bne.w	60001904 <jd_prepare+0x144>
60001ad0:	f104 000f 	add.w	r0, r4, #15
				for (i = 0; i < jd->ncomp; i++) {
60001ad4:	2300      	movs	r3, #0
60001ad6:	4299      	cmp	r1, r3
60001ad8:	d836      	bhi.n	60001b48 <jd_prepare+0x388>
				n = jd->msy * jd->msx;						/* Number of Y blocks in the MCU */
60001ada:	7be2      	ldrb	r2, [r4, #15]
60001adc:	7ba3      	ldrb	r3, [r4, #14]
60001ade:	fb12 f203 	smulbb	r2, r2, r3
				if (!n) return JDR_FMT1;					/* Err: SOF0 has not been loaded */
60001ae2:	2a00      	cmp	r2, #0
60001ae4:	f43f af30 	beq.w	60001948 <jd_prepare+0x188>
				len = n * 64 * 2 + 64;						/* Allocate buffer for IDCT and RGB output */
60001ae8:	01d2      	lsls	r2, r2, #7
				jd->workbuf = alloc_pool(jd, len);			/* and it may occupy a part of following MCU working buffer for RGB output */
60001aea:	4620      	mov	r0, r4
				len = n * 64 * 2 + 64;						/* Allocate buffer for IDCT and RGB output */
60001aec:	f102 0140 	add.w	r1, r2, #64	; 0x40
				jd->workbuf = alloc_pool(jd, len);			/* and it may occupy a part of following MCU working buffer for RGB output */
60001af0:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
60001af4:	bf38      	it	cc
60001af6:	f44f 7180 	movcc.w	r1, #256	; 0x100
60001afa:	f7ff fdaf 	bl	6000165c <alloc_pool>
60001afe:	66a0      	str	r0, [r4, #104]	; 0x68
				if (!jd->workbuf) return JDR_MEM1;			/* Err: not enough memory */
60001b00:	2800      	cmp	r0, #0
60001b02:	f43f af37 	beq.w	60001974 <jd_prepare+0x1b4>
				jd->mcubuf = alloc_pool(jd, (n + 2) * 64 * sizeof(jd_yuv_t));	/* Allocate MCU working buffer */
60001b06:	f502 7180 	add.w	r1, r2, #256	; 0x100
60001b0a:	4620      	mov	r0, r4
60001b0c:	f7ff fda6 	bl	6000165c <alloc_pool>
60001b10:	66e0      	str	r0, [r4, #108]	; 0x6c
				if (!jd->mcubuf) return JDR_MEM1;			/* Err: not enough memory */
60001b12:	2800      	cmp	r0, #0
60001b14:	f43f af2e 	beq.w	60001974 <jd_prepare+0x1b4>
				if (ofs %= JD_SZBUF) {
60001b18:	9b00      	ldr	r3, [sp, #0]
60001b1a:	f3c3 0209 	ubfx	r2, r3, #0, #10
					jd->dctr = jd->infunc(jd, seg + ofs, (size_t)(JD_SZBUF - ofs));
60001b1e:	4415      	add	r5, r2
				if (ofs %= JD_SZBUF) {
60001b20:	b132      	cbz	r2, 60001b30 <jd_prepare+0x370>
					jd->dctr = jd->infunc(jd, seg + ofs, (size_t)(JD_SZBUF - ofs));
60001b22:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001b24:	f5c2 6280 	rsb	r2, r2, #1024	; 0x400
60001b28:	4629      	mov	r1, r5
60001b2a:	4620      	mov	r0, r4
60001b2c:	4798      	blx	r3
60001b2e:	6020      	str	r0, [r4, #0]
				return JDR_OK;		/* Initialization succeeded. Ready to decompress the JPEG image. */
60001b30:	2000      	movs	r0, #0
				jd->dptr = seg + ofs - (JD_FASTDECODE ? 0 : 1);
60001b32:	6065      	str	r5, [r4, #4]
			}
		}
	}
60001b34:	b005      	add	sp, #20
60001b36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
60001b3a:	bf00      	nop
60001b3c:	0200eeee 	.word	0x0200eeee
60001b40:	2000455e 	.word	0x2000455e
60001b44:	20004a99 	.word	0x20004a99
					b = seg[2 + 2 * i];	/* Get huffman table ID */
60001b48:	1c5f      	adds	r7, r3, #1
60001b4a:	f815 2017 	ldrb.w	r2, [r5, r7, lsl #1]
					if (b != 0x00 && b != 0x11)	return JDR_FMT3;	/* Err: Different table number for DC/AC element */
60001b4e:	b112      	cbz	r2, 60001b56 <jd_prepare+0x396>
60001b50:	2a11      	cmp	r2, #17
60001b52:	f47f aed7 	bne.w	60001904 <jd_prepare+0x144>
					n = i ? 1 : 0;							/* Component class */
60001b56:	3b00      	subs	r3, #0
60001b58:	bf18      	it	ne
60001b5a:	2301      	movne	r3, #1
					if (!jd->huffbits[n][0] || !jd->huffbits[n][1]) {	/* Check huffman table for this component */
60001b5c:	1d1a      	adds	r2, r3, #4
60001b5e:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
60001b62:	2a00      	cmp	r2, #0
60001b64:	f43f aef0 	beq.w	60001948 <jd_prepare+0x188>
60001b68:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
60001b6c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
60001b6e:	2b00      	cmp	r3, #0
60001b70:	f43f aeea 	beq.w	60001948 <jd_prepare+0x188>
					if (!jd->qttbl[jd->qtid[i]]) {			/* Check dequantizer table for this component */
60001b74:	f810 3f01 	ldrb.w	r3, [r0, #1]!
60001b78:	3314      	adds	r3, #20
60001b7a:	f854 3023 	ldr.w	r3, [r4, r3, lsl #2]
60001b7e:	2b00      	cmp	r3, #0
60001b80:	f43f aee2 	beq.w	60001948 <jd_prepare+0x188>
				for (i = 0; i < jd->ncomp; i++) {
60001b84:	463b      	mov	r3, r7
60001b86:	e7a6      	b.n	60001ad6 <jd_prepare+0x316>
				if (len > JD_SZBUF) return JDR_MEM2;
60001b88:	2004      	movs	r0, #4
60001b8a:	e7d3      	b.n	60001b34 <jd_prepare+0x374>

60001b8c <jd_decomp>:
SLOWFUN JRESULT jd_decomp(
	JDEC* jd,								/* Initialized decompression object */
	int (*outfunc)(JDEC*, void*, JRECT*),	/* RGB output function */
	uint8_t scale							/* Output de-scaling factor (0 to 3) */
)
	{
60001b8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	unsigned int x, y, mx, my;
	uint16_t rst, rsc;
	JRESULT rc;


	if (scale > (JD_USE_SCALE ? 3 : 0)) return JDR_PAR;
60001b90:	2a03      	cmp	r2, #3
	{
60001b92:	b095      	sub	sp, #84	; 0x54
60001b94:	4604      	mov	r4, r0
60001b96:	9111      	str	r1, [sp, #68]	; 0x44
	if (scale > (JD_USE_SCALE ? 3 : 0)) return JDR_PAR;
60001b98:	f200 83b3 	bhi.w	60002302 <jd_decomp+0x776>
	jd->scale = scale;

	mx = jd->msx * 8; my = jd->msy * 8;			/* Size of the MCU (pixel) */
60001b9c:	7b83      	ldrb	r3, [r0, #14]
	jd->scale = scale;
60001b9e:	7342      	strb	r2, [r0, #13]
	mx = jd->msx * 8; my = jd->msy * 8;			/* Size of the MCU (pixel) */
60001ba0:	00db      	lsls	r3, r3, #3
60001ba2:	930d      	str	r3, [sp, #52]	; 0x34
60001ba4:	7bc3      	ldrb	r3, [r0, #15]
60001ba6:	00db      	lsls	r3, r3, #3
60001ba8:	930e      	str	r3, [sp, #56]	; 0x38

	jd->dcv[2] = jd->dcv[1] = jd->dcv[0] = 0;	/* Initialize DC values */
60001baa:	2300      	movs	r3, #0
60001bac:	6143      	str	r3, [r0, #20]
60001bae:	8303      	strh	r3, [r0, #24]
	rst = rsc = 0;
60001bb0:	9305      	str	r3, [sp, #20]
60001bb2:	9307      	str	r3, [sp, #28]

	rc = JDR_OK;
	for (y = 0; y < jd->height; y += my) {		/* Vertical loop of MCUs */
60001bb4:	9304      	str	r3, [sp, #16]
60001bb6:	9a04      	ldr	r2, [sp, #16]
60001bb8:	8be3      	ldrh	r3, [r4, #30]
60001bba:	4293      	cmp	r3, r2
60001bbc:	f200 839f 	bhi.w	600022fe <jd_decomp+0x772>
			rc = mcu_output(jd, outfunc, x, y);	/* Output the MCU (YCbCr to RGB, scaling and output) */
			if (rc != JDR_OK) return rc;
			}
		}

	return rc;
60001bc0:	2000      	movs	r0, #0
60001bc2:	e01a      	b.n	60001bfa <jd_decomp+0x6e>
			if (jd->nrst && rst++ == jd->nrst) {	/* Process restart interval if enabled */
60001bc4:	8b62      	ldrh	r2, [r4, #26]
60001bc6:	2a00      	cmp	r2, #0
60001bc8:	d041      	beq.n	60001c4e <jd_decomp+0xc2>
60001bca:	9b07      	ldr	r3, [sp, #28]
60001bcc:	9907      	ldr	r1, [sp, #28]
60001bce:	3301      	adds	r3, #1
60001bd0:	428a      	cmp	r2, r1
60001bd2:	b29b      	uxth	r3, r3
60001bd4:	d13a      	bne.n	60001c4c <jd_decomp+0xc0>
	if (jd->marker) {	/* Generate a maker if it has been detected */
60001bd6:	f894 5064 	ldrb.w	r5, [r4, #100]	; 0x64
	size_t dc = jd->dctr;
60001bda:	e9d4 0700 	ldrd	r0, r7, [r4]
	if (jd->marker) {	/* Generate a maker if it has been detected */
60001bde:	b17d      	cbz	r5, 60001c00 <jd_decomp+0x74>
		jd->marker = 0;
60001be0:	2300      	movs	r3, #0
		marker = 0xFF00 | jd->marker;
60001be2:	f445 457f 	orr.w	r5, r5, #65280	; 0xff00
		jd->marker = 0;
60001be6:	f884 3064 	strb.w	r3, [r4, #100]	; 0x64
	if ((marker & 0xFFD8) != 0xFFD0 || (marker & 7) != (rstn & 7)) {
60001bea:	f025 0327 	bic.w	r3, r5, #39	; 0x27
60001bee:	f64f 72d0 	movw	r2, #65488	; 0xffd0
60001bf2:	b29b      	uxth	r3, r3
60001bf4:	4293      	cmp	r3, r2
60001bf6:	d01d      	beq.n	60001c34 <jd_decomp+0xa8>
		return JDR_FMT1;	/* Err: expected RSTn marker was not detected (may be collapted data) */
60001bf8:	2006      	movs	r0, #6
	}
60001bfa:	b015      	add	sp, #84	; 0x54
60001bfc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
60001c00:	2602      	movs	r6, #2
			if (!dc) {		/* No input data is available, re-fill input buffer */
60001c02:	b948      	cbnz	r0, 60001c18 <jd_decomp+0x8c>
				dp = jd->inbuf;
60001c04:	68a7      	ldr	r7, [r4, #8]
				dc = jd->infunc(jd, dp, JD_SZBUF);
60001c06:	f44f 6280 	mov.w	r2, #1024	; 0x400
60001c0a:	6fa3      	ldr	r3, [r4, #120]	; 0x78
60001c0c:	4620      	mov	r0, r4
60001c0e:	4639      	mov	r1, r7
60001c10:	4798      	blx	r3
				if (!dc) return JDR_INP;
60001c12:	2800      	cmp	r0, #0
60001c14:	f000 8377 	beq.w	60002306 <jd_decomp+0x77a>
			marker = (marker << 8) | *dp++;	/* Get a byte */
60001c18:	f817 3b01 	ldrb.w	r3, [r7], #1
		for (i = 0; i < 2; i++) {	/* Get a restart marker */
60001c1c:	2e01      	cmp	r6, #1
			dc--;
60001c1e:	f100 30ff 	add.w	r0, r0, #4294967295
			marker = (marker << 8) | *dp++;	/* Get a byte */
60001c22:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
60001c26:	b29d      	uxth	r5, r3
		for (i = 0; i < 2; i++) {	/* Get a restart marker */
60001c28:	d102      	bne.n	60001c30 <jd_decomp+0xa4>
		jd->dptr = dp; jd->dctr = dc;
60001c2a:	e9c4 0700 	strd	r0, r7, [r4]
60001c2e:	e7dc      	b.n	60001bea <jd_decomp+0x5e>
60001c30:	2601      	movs	r6, #1
60001c32:	e7e6      	b.n	60001c02 <jd_decomp+0x76>
	if ((marker & 0xFFD8) != 0xFFD0 || (marker & 7) != (rstn & 7)) {
60001c34:	9b05      	ldr	r3, [sp, #20]
60001c36:	405d      	eors	r5, r3
60001c38:	f015 0507 	ands.w	r5, r5, #7
60001c3c:	d1dc      	bne.n	60001bf8 <jd_decomp+0x6c>
				rc = restart(jd, rsc++);
60001c3e:	3301      	adds	r3, #1
	jd->dbit = 0;			/* Discard stuff bits */
60001c40:	7325      	strb	r5, [r4, #12]
	jd->dcv[2] = jd->dcv[1] = jd->dcv[0] = 0;	/* Reset DC offset */
60001c42:	6165      	str	r5, [r4, #20]
				rc = restart(jd, rsc++);
60001c44:	b29b      	uxth	r3, r3
	jd->dcv[2] = jd->dcv[1] = jd->dcv[0] = 0;	/* Reset DC offset */
60001c46:	8325      	strh	r5, [r4, #24]
				rc = restart(jd, rsc++);
60001c48:	9305      	str	r3, [sp, #20]
				rst = 1;
60001c4a:	2301      	movs	r3, #1
			if (jd->nrst && rst++ == jd->nrst) {	/* Process restart interval if enabled */
60001c4c:	9307      	str	r3, [sp, #28]
	int32_t* tmp = (int32_t*)jd->workbuf;	/* Block working buffer for de-quantize and IDCT */
60001c4e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
	nby = jd->msx * jd->msy;	/* Number of Y blocks (1, 2 or 4) */
60001c50:	7ba2      	ldrb	r2, [r4, #14]
	int32_t* tmp = (int32_t*)jd->workbuf;	/* Block working buffer for de-quantize and IDCT */
60001c52:	9306      	str	r3, [sp, #24]
	nby = jd->msx * jd->msy;	/* Number of Y blocks (1, 2 or 4) */
60001c54:	7be3      	ldrb	r3, [r4, #15]
60001c56:	6ee5      	ldr	r5, [r4, #108]	; 0x6c
60001c58:	fb12 f303 	smulbb	r3, r2, r3
60001c5c:	9308      	str	r3, [sp, #32]
	for (blk = 0; blk < nby + 2; blk++) {	/* Get nby Y blocks and two C blocks */
60001c5e:	1eab      	subs	r3, r5, #2
60001c60:	9301      	str	r3, [sp, #4]
60001c62:	9b08      	ldr	r3, [sp, #32]
60001c64:	f1c3 0301 	rsb	r3, r3, #1
60001c68:	9302      	str	r3, [sp, #8]
		cmp = (blk < nby) ? 0 : blk - nby + 1;	/* Component number 0:Y, 1:Cb, 2:Cr */
60001c6a:	9b08      	ldr	r3, [sp, #32]
60001c6c:	3b01      	subs	r3, #1
60001c6e:	930a      	str	r3, [sp, #40]	; 0x28
60001c70:	9a02      	ldr	r2, [sp, #8]
60001c72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
60001c74:	4413      	add	r3, r2
60001c76:	9a08      	ldr	r2, [sp, #32]
60001c78:	429a      	cmp	r2, r3
60001c7a:	d87d      	bhi.n	60001d78 <jd_decomp+0x1ec>
		if (cmp && jd->ncomp != 3) {		/* Clear C blocks if not exist (monochrome image) */
60001c7c:	9b02      	ldr	r3, [sp, #8]
60001c7e:	2b00      	cmp	r3, #0
60001c80:	d07a      	beq.n	60001d78 <jd_decomp+0x1ec>
60001c82:	7ce3      	ldrb	r3, [r4, #19]
60001c84:	2b03      	cmp	r3, #3
60001c86:	f000 808a 	beq.w	60001d9e <jd_decomp+0x212>
60001c8a:	9b01      	ldr	r3, [sp, #4]
			for (i = 0; i < 64; bp[i++] = 128);
60001c8c:	2180      	movs	r1, #128	; 0x80
60001c8e:	461a      	mov	r2, r3
60001c90:	440a      	add	r2, r1
60001c92:	f823 1f02 	strh.w	r1, [r3, #2]!
60001c96:	429a      	cmp	r2, r3
60001c98:	d1fb      	bne.n	60001c92 <jd_decomp+0x106>
	for (blk = 0; blk < nby + 2; blk++) {	/* Get nby Y blocks and two C blocks */
60001c9a:	9b01      	ldr	r3, [sp, #4]
60001c9c:	3380      	adds	r3, #128	; 0x80
60001c9e:	9301      	str	r3, [sp, #4]
60001ca0:	9b02      	ldr	r3, [sp, #8]
60001ca2:	3301      	adds	r3, #1
60001ca4:	2b03      	cmp	r3, #3
60001ca6:	9302      	str	r3, [sp, #8]
60001ca8:	d1e2      	bne.n	60001c70 <jd_decomp+0xe4>
	mx = jd->msx * 8; my = jd->msy * 8;					/* MCU size (pixel) */
60001caa:	7be1      	ldrb	r1, [r4, #15]
60001cac:	2308      	movs	r3, #8
60001cae:	7ba2      	ldrb	r2, [r4, #14]
60001cb0:	00c9      	lsls	r1, r1, #3
	rx = (x + mx <= jd->width) ? mx : jd->width - x;	/* Output rectangular size (it may be clipped at right/bottom end of image) */
60001cb2:	9803      	ldr	r0, [sp, #12]
	mx = jd->msx * 8; my = jd->msy * 8;					/* MCU size (pixel) */
60001cb4:	fb12 fa03 	smulbb	sl, r2, r3
60001cb8:	9101      	str	r1, [sp, #4]
	rx = (x + mx <= jd->width) ? mx : jd->width - x;	/* Output rectangular size (it may be clipped at right/bottom end of image) */
60001cba:	fb13 0302 	smlabb	r3, r3, r2, r0
60001cbe:	8ba1      	ldrh	r1, [r4, #28]
60001cc0:	428b      	cmp	r3, r1
60001cc2:	f200 81c6 	bhi.w	60002052 <jd_decomp+0x4c6>
	mx = jd->msx * 8; my = jd->msy * 8;					/* MCU size (pixel) */
60001cc6:	4651      	mov	r1, sl
	ry = (y + my <= jd->height) ? my : jd->height - y;
60001cc8:	9b04      	ldr	r3, [sp, #16]
60001cca:	9801      	ldr	r0, [sp, #4]
60001ccc:	8be2      	ldrh	r2, [r4, #30]
60001cce:	4403      	add	r3, r0
60001cd0:	4293      	cmp	r3, r2
60001cd2:	bf8a      	itet	hi
60001cd4:	9b04      	ldrhi	r3, [sp, #16]
	mx = jd->msx * 8; my = jd->msy * 8;					/* MCU size (pixel) */
60001cd6:	9a01      	ldrls	r2, [sp, #4]
	ry = (y + my <= jd->height) ? my : jd->height - y;
60001cd8:	1ad2      	subhi	r2, r2, r3
		rx >>= jd->scale; ry >>= jd->scale;
60001cda:	7b63      	ldrb	r3, [r4, #13]
		if (!rx || !ry) return JDR_OK;					/* Skip this MCU if all pixel is to be rounded off */
60001cdc:	40d9      	lsrs	r1, r3
60001cde:	9102      	str	r1, [sp, #8]
60001ce0:	d03d      	beq.n	60001d5e <jd_decomp+0x1d2>
60001ce2:	40da      	lsrs	r2, r3
60001ce4:	920b      	str	r2, [sp, #44]	; 0x2c
60001ce6:	d03a      	beq.n	60001d5e <jd_decomp+0x1d2>
		x >>= jd->scale; y >>= jd->scale;
60001ce8:	9a03      	ldr	r2, [sp, #12]
	if (!JD_USE_SCALE || jd->scale != 3) {	/* Not for 1/8 scaling */
60001cea:	2b03      	cmp	r3, #3
		pix = (uint8_t*)jd->workbuf;
60001cec:	6ea7      	ldr	r7, [r4, #104]	; 0x68
		x >>= jd->scale; y >>= jd->scale;
60001cee:	fa22 f203 	lsr.w	r2, r2, r3
	rect.left = x; rect.right = x + rx - 1;				/* Rectangular area in the frame buffer */
60001cf2:	b292      	uxth	r2, r2
60001cf4:	f8ad 2048 	strh.w	r2, [sp, #72]	; 0x48
60001cf8:	f102 32ff 	add.w	r2, r2, #4294967295
60001cfc:	440a      	add	r2, r1
	rect.top = y; rect.bottom = y + ry - 1;
60001cfe:	990b      	ldr	r1, [sp, #44]	; 0x2c
	rect.left = x; rect.right = x + rx - 1;				/* Rectangular area in the frame buffer */
60001d00:	f8ad 204a 	strh.w	r2, [sp, #74]	; 0x4a
		x >>= jd->scale; y >>= jd->scale;
60001d04:	9a04      	ldr	r2, [sp, #16]
60001d06:	fa22 f203 	lsr.w	r2, r2, r3
	rect.top = y; rect.bottom = y + ry - 1;
60001d0a:	b292      	uxth	r2, r2
60001d0c:	f8ad 204c 	strh.w	r2, [sp, #76]	; 0x4c
60001d10:	f102 32ff 	add.w	r2, r2, #4294967295
60001d14:	440a      	add	r2, r1
60001d16:	f8ad 204e 	strh.w	r2, [sp, #78]	; 0x4e
	if (!JD_USE_SCALE || jd->scale != 3) {	/* Not for 1/8 scaling */
60001d1a:	f000 826a 	beq.w	600021f2 <jd_decomp+0x666>
60001d1e:	eb0a 034a 	add.w	r3, sl, sl, lsl #1
			for (iy = 0; iy < my; iy++) {
60001d22:	f04f 0c00 	mov.w	ip, #0
60001d26:	ea4f 190a 	mov.w	r9, sl, lsl #4
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60001d2a:	f240 2bdb 	movw	fp, #731	; 0x2db
60001d2e:	930c      	str	r3, [sp, #48]	; 0x30
			for (iy = 0; iy < my; iy++) {
60001d30:	9b01      	ldr	r3, [sp, #4]
60001d32:	4563      	cmp	r3, ip
60001d34:	f040 8190 	bne.w	60002058 <jd_decomp+0x4cc>
		if (JD_USE_SCALE && jd->scale) {
60001d38:	7b63      	ldrb	r3, [r4, #13]
60001d3a:	2b00      	cmp	r3, #0
60001d3c:	f040 8202 	bne.w	60002144 <jd_decomp+0x5b8>
	mx >>= jd->scale;
60001d40:	7b63      	ldrb	r3, [r4, #13]
	if (rx < mx) {	/* Is the MCU spans rigit edge? */
60001d42:	9a02      	ldr	r2, [sp, #8]
	mx >>= jd->scale;
60001d44:	fa2a f303 	lsr.w	r3, sl, r3
	if (rx < mx) {	/* Is the MCU spans rigit edge? */
60001d48:	429a      	cmp	r2, r3
60001d4a:	f0c0 82b4 	bcc.w	600022b6 <jd_decomp+0x72a>
	return outfunc(jd, jd->workbuf, &rect) ? JDR_OK : JDR_INTR;
60001d4e:	aa12      	add	r2, sp, #72	; 0x48
60001d50:	6ea1      	ldr	r1, [r4, #104]	; 0x68
60001d52:	4620      	mov	r0, r4
60001d54:	9b11      	ldr	r3, [sp, #68]	; 0x44
60001d56:	4798      	blx	r3
			if (rc != JDR_OK) return rc;
60001d58:	2800      	cmp	r0, #0
60001d5a:	f000 82d6 	beq.w	6000230a <jd_decomp+0x77e>
		for (x = 0; x < jd->width; x += mx) {	/* Horizontal loop of MCUs */
60001d5e:	9b03      	ldr	r3, [sp, #12]
60001d60:	9a0d      	ldr	r2, [sp, #52]	; 0x34
60001d62:	4413      	add	r3, r2
60001d64:	9303      	str	r3, [sp, #12]
60001d66:	9a03      	ldr	r2, [sp, #12]
60001d68:	8ba3      	ldrh	r3, [r4, #28]
60001d6a:	4293      	cmp	r3, r2
60001d6c:	f63f af2a 	bhi.w	60001bc4 <jd_decomp+0x38>
	for (y = 0; y < jd->height; y += my) {		/* Vertical loop of MCUs */
60001d70:	9b04      	ldr	r3, [sp, #16]
60001d72:	9a0e      	ldr	r2, [sp, #56]	; 0x38
60001d74:	4413      	add	r3, r2
60001d76:	e71d      	b.n	60001bb4 <jd_decomp+0x28>
		cmp = (blk < nby) ? 0 : blk - nby + 1;	/* Component number 0:Y, 1:Cb, 2:Cr */
60001d78:	2700      	movs	r7, #0
			id = cmp ? 1 : 0;						/* Huffman table ID of this component */
60001d7a:	1e3e      	subs	r6, r7, #0
			d = huffext(jd, id, 0);					/* Extract a huffman coded data (bit length) */
60001d7c:	f04f 0200 	mov.w	r2, #0
60001d80:	4620      	mov	r0, r4
			id = cmp ? 1 : 0;						/* Huffman table ID of this component */
60001d82:	bf18      	it	ne
60001d84:	2601      	movne	r6, #1
			d = huffext(jd, id, 0);					/* Extract a huffman coded data (bit length) */
60001d86:	4631      	mov	r1, r6
60001d88:	f7ff fc77 	bl	6000167a <huffext>
			if (d < 0) return (JRESULT)(0 - d);		/* Err: invalid code or input */
60001d8c:	f1b0 0a00 	subs.w	sl, r0, #0
60001d90:	da07      	bge.n	60001da2 <jd_decomp+0x216>
60001d92:	f1ca 0000 	rsb	r0, sl, #0
					if (d < 0) return (JRESULT)(0 - d);	/* Err: input device */
60001d96:	b2c0      	uxtb	r0, r0
			if (rc != JDR_OK) return rc;
60001d98:	2800      	cmp	r0, #0
60001d9a:	d086      	beq.n	60001caa <jd_decomp+0x11e>
60001d9c:	e72d      	b.n	60001bfa <jd_decomp+0x6e>
60001d9e:	9f02      	ldr	r7, [sp, #8]
60001da0:	e7eb      	b.n	60001d7a <jd_decomp+0x1ee>
			d = jd->dcv[cmp];						/* DC value of previous block */
60001da2:	eb04 0947 	add.w	r9, r4, r7, lsl #1
60001da6:	f9b9 8014 	ldrsh.w	r8, [r9, #20]
			if (bc) {								/* If there is any difference from previous block */
60001daa:	d017      	beq.n	60001ddc <jd_decomp+0x250>
				e = bitext(jd, bc);					/* Extract data bits */
60001dac:	4651      	mov	r1, sl
60001dae:	4620      	mov	r0, r4
60001db0:	f7ff fcc1 	bl	60001736 <bitext>
				if (e < 0) return (JRESULT)(0 - e);	/* Err: input */
60001db4:	2800      	cmp	r0, #0
60001db6:	da01      	bge.n	60001dbc <jd_decomp+0x230>
					if (d < 0) return (JRESULT)(0 - d);	/* Err: input device */
60001db8:	4240      	negs	r0, r0
60001dba:	e7ec      	b.n	60001d96 <jd_decomp+0x20a>
				bc = 1 << (bc - 1);					/* MSB position */
60001dbc:	2301      	movs	r3, #1
60001dbe:	f10a 3aff 	add.w	sl, sl, #4294967295
60001dc2:	fa03 fa0a 	lsl.w	sl, r3, sl
				if (!(e & bc)) e -= (bc << 1) - 1;	/* Restore negative value if needed */
60001dc6:	ea1a 0f00 	tst.w	sl, r0
60001dca:	bf02      	ittt	eq
60001dcc:	fa0a fa03 	lsleq.w	sl, sl, r3
60001dd0:	eba3 0a0a 	subeq.w	sl, r3, sl
60001dd4:	4450      	addeq	r0, sl
				d += e;								/* Get current value */
60001dd6:	4480      	add	r8, r0
				jd->dcv[cmp] = (int16_t)d;			/* Save current DC value for next block */
60001dd8:	f8a9 8014 	strh.w	r8, [r9, #20]
			dqf = jd->qttbl[jd->qtid[cmp]];			/* De-quantizer table ID for this component */
60001ddc:	4427      	add	r7, r4
			z = 1;		/* Top of the AC elements (in zigzag-order) */
60001dde:	f04f 0901 	mov.w	r9, #1
			tmp[0] = d * dqf[0] >> 8;				/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001de2:	9806      	ldr	r0, [sp, #24]
			memset(&tmp[1], 0, 63 * sizeof(int32_t));	/* Initialize all AC elements */
60001de4:	22fc      	movs	r2, #252	; 0xfc
			dqf = jd->qttbl[jd->qtid[cmp]];			/* De-quantizer table ID for this component */
60001de6:	7c3b      	ldrb	r3, [r7, #16]
			memset(&tmp[1], 0, 63 * sizeof(int32_t));	/* Initialize all AC elements */
60001de8:	2100      	movs	r1, #0
			dqf = jd->qttbl[jd->qtid[cmp]];			/* De-quantizer table ID for this component */
60001dea:	3314      	adds	r3, #20
60001dec:	f854 7023 	ldr.w	r7, [r4, r3, lsl #2]
			tmp[0] = d * dqf[0] >> 8;				/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001df0:	683b      	ldr	r3, [r7, #0]
60001df2:	fb03 f808 	mul.w	r8, r3, r8
60001df6:	ea4f 2328 	mov.w	r3, r8, asr #8
				d = huffext(jd, id, 1);				/* Extract a huffman coded value (zero runs and bit length) */
60001dfa:	46c8      	mov	r8, r9
			tmp[0] = d * dqf[0] >> 8;				/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001dfc:	f840 3b04 	str.w	r3, [r0], #4
			memset(&tmp[1], 0, 63 * sizeof(int32_t));	/* Initialize all AC elements */
60001e00:	f039 f99a 	bl	6003b138 <__memset_veneer>
				d = huffext(jd, id, 1);				/* Extract a huffman coded value (zero runs and bit length) */
60001e04:	2201      	movs	r2, #1
60001e06:	4631      	mov	r1, r6
60001e08:	4620      	mov	r0, r4
60001e0a:	f7ff fc36 	bl	6000167a <huffext>
				if (d == 0) break;					/* EOB? */
60001e0e:	2800      	cmp	r0, #0
60001e10:	d03e      	beq.n	60001e90 <jd_decomp+0x304>
				if (d < 0) return (JRESULT)(0 - d);	/* Err: invalid code or input error */
60001e12:	dbd1      	blt.n	60001db8 <jd_decomp+0x22c>
				z += bc >> 4;						/* Skip leading zero run */
60001e14:	eb09 1a10 	add.w	sl, r9, r0, lsr #4
				if (z >= 64) return JDR_FMT1;		/* Too long zero run */
60001e18:	f1ba 0f3f 	cmp.w	sl, #63	; 0x3f
60001e1c:	f63f aeec 	bhi.w	60001bf8 <jd_decomp+0x6c>
				if (bc &= 0x0F) {					/* Bit length? */
60001e20:	f010 090f 	ands.w	r9, r0, #15
60001e24:	d01b      	beq.n	60001e5e <jd_decomp+0x2d2>
					d = bitext(jd, bc);				/* Extract data bits */
60001e26:	4649      	mov	r1, r9
60001e28:	4620      	mov	r0, r4
60001e2a:	f7ff fc84 	bl	60001736 <bitext>
					if (d < 0) return (JRESULT)(0 - d);	/* Err: input device */
60001e2e:	2800      	cmp	r0, #0
60001e30:	dbc2      	blt.n	60001db8 <jd_decomp+0x22c>
					bc = 1 << (bc - 1);				/* MSB position */
60001e32:	f109 39ff 	add.w	r9, r9, #4294967295
					tmp[i] = d * dqf[i] >> 8;		/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001e36:	4bcf      	ldr	r3, [pc, #828]	; (60002174 <jd_decomp+0x5e8>)
					bc = 1 << (bc - 1);				/* MSB position */
60001e38:	fa08 f909 	lsl.w	r9, r8, r9
					tmp[i] = d * dqf[i] >> 8;		/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001e3c:	f813 200a 	ldrb.w	r2, [r3, sl]
					if (!(d & bc)) d -= (bc << 1) - 1;	/* Restore negative value if needed */
60001e40:	ea19 0f00 	tst.w	r9, r0
					tmp[i] = d * dqf[i] >> 8;		/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001e44:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
					if (!(d & bc)) d -= (bc << 1) - 1;	/* Restore negative value if needed */
60001e48:	bf02      	ittt	eq
60001e4a:	ea4f 0949 	moveq.w	r9, r9, lsl #1
60001e4e:	f1c9 0901 	rsbeq	r9, r9, #1
60001e52:	4448      	addeq	r0, r9
					tmp[i] = d * dqf[i] >> 8;		/* De-quantize, apply scale factor of Arai algorithm and descale 8 bits */
60001e54:	4358      	muls	r0, r3
60001e56:	9b06      	ldr	r3, [sp, #24]
60001e58:	1200      	asrs	r0, r0, #8
60001e5a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
				} while (++z < 64);		/* Next AC element */
60001e5e:	f1ba 0f3f 	cmp.w	sl, #63	; 0x3f
60001e62:	f10a 0901 	add.w	r9, sl, #1
60001e66:	d1cd      	bne.n	60001e04 <jd_decomp+0x278>
				if (z == 1 || (JD_USE_SCALE && jd->scale == 3)) {	/* If no AC element or scale ratio is 1/8, IDCT can be ommited and the block is filled with DC value */
60001e68:	7b63      	ldrb	r3, [r4, #13]
60001e6a:	2b03      	cmp	r3, #3
60001e6c:	d114      	bne.n	60001e98 <jd_decomp+0x30c>
					d = (jd_yuv_t)((*tmp / 256) + 128);
60001e6e:	9b06      	ldr	r3, [sp, #24]
60001e70:	9a01      	ldr	r2, [sp, #4]
60001e72:	681b      	ldr	r3, [r3, #0]
						for (i = 0; i < 64; bp[i++] = d);
60001e74:	4611      	mov	r1, r2
					d = (jd_yuv_t)((*tmp / 256) + 128);
60001e76:	2b00      	cmp	r3, #0
						for (i = 0; i < 64; bp[i++] = d);
60001e78:	f101 0180 	add.w	r1, r1, #128	; 0x80
					d = (jd_yuv_t)((*tmp / 256) + 128);
60001e7c:	bfb8      	it	lt
60001e7e:	33ff      	addlt	r3, #255	; 0xff
60001e80:	121b      	asrs	r3, r3, #8
60001e82:	3380      	adds	r3, #128	; 0x80
60001e84:	b21b      	sxth	r3, r3
						for (i = 0; i < 64; bp[i++] = d);
60001e86:	f822 3f02 	strh.w	r3, [r2, #2]!
60001e8a:	4291      	cmp	r1, r2
60001e8c:	d1fb      	bne.n	60001e86 <jd_decomp+0x2fa>
60001e8e:	e704      	b.n	60001c9a <jd_decomp+0x10e>
				if (z == 1 || (JD_USE_SCALE && jd->scale == 3)) {	/* If no AC element or scale ratio is 1/8, IDCT can be ommited and the block is filled with DC value */
60001e90:	f1b9 0f01 	cmp.w	r9, #1
60001e94:	d1e8      	bne.n	60001e68 <jd_decomp+0x2dc>
60001e96:	e7ea      	b.n	60001e6e <jd_decomp+0x2e2>
60001e98:	9b06      	ldr	r3, [sp, #24]
		t11 = (v1 - v3) * M13 >> 12;
60001e9a:	f44f 59b5 	mov.w	r9, #5792	; 0x16a0
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001e9e:	f642 1acf 	movw	sl, #10703	; 0x29cf
60001ea2:	3320      	adds	r3, #32
60001ea4:	9309      	str	r3, [sp, #36]	; 0x24
				if (z == 1 || (JD_USE_SCALE && jd->scale == 3)) {	/* If no AC element or scale ratio is 1/8, IDCT can be ommited and the block is filled with DC value */
60001ea6:	9b06      	ldr	r3, [sp, #24]
		v2 = src[8 * 4];
60001ea8:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
		t13 = (t10 + t12) * M5 >> 12;
60001eac:	f641 5590 	movw	r5, #7568	; 0x1d90
		v3 = src[8 * 6];
60001eb0:	f8d3 60c0 	ldr.w	r6, [r3, #192]	; 0xc0
		src++;	/* Next column */
60001eb4:	3304      	adds	r3, #4
		v0 = src[8 * 0];	/* Get even elements */
60001eb6:	f853 0c04 	ldr.w	r0, [r3, #-4]
		v1 = src[8 * 2];
60001eba:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
		t10 = v0 + v2;		/* Process the even elements */
60001ebc:	1887      	adds	r7, r0, r2
		t12 = v0 - v2;
60001ebe:	1a80      	subs	r0, r0, r2
		t11 = (v1 - v3) * M13 >> 12;
60001ec0:	1b8a      	subs	r2, r1, r6
		v3 += v1;
60001ec2:	4431      	add	r1, r6
		v6 = src[8 * 5];
60001ec4:	f8d3 c09c 	ldr.w	ip, [r3, #156]	; 0x9c
		t11 = (v1 - v3) * M13 >> 12;
60001ec8:	fb09 f202 	mul.w	r2, r9, r2
		v4 = src[8 * 7];	/* Get odd elements */
60001ecc:	f8d3 60dc 	ldr.w	r6, [r3, #220]	; 0xdc
		v7 = src[8 * 3];
60001ed0:	f8d3 b05c 	ldr.w	fp, [r3, #92]	; 0x5c
		v0 = t10 + v3;
60001ed4:	eb07 0801 	add.w	r8, r7, r1
		t11 -= v3;
60001ed8:	ebc1 3222 	rsb	r2, r1, r2, asr #12
		v3 = t10 - v3;
60001edc:	1a7f      	subs	r7, r7, r1
		v1 = t11 + t12;
60001ede:	eb00 0e02 	add.w	lr, r0, r2
		v2 = t12 - t11;
60001ee2:	1a80      	subs	r0, r0, r2
		v5 = src[8 * 1];
60001ee4:	69da      	ldr	r2, [r3, #28]
		t10 = v5 - v4;		/* Process the odd elements */
60001ee6:	1b91      	subs	r1, r2, r6
		t11 = v5 + v4;
60001ee8:	4416      	add	r6, r2
		t12 = v6 - v7;
60001eea:	ebac 020b 	sub.w	r2, ip, fp
		v7 += v6;
60001eee:	44e3      	add	fp, ip
		v5 = (t11 - v7) * M13 >> 12;
60001ef0:	eba6 0c0b 	sub.w	ip, r6, fp
		v7 += t11;
60001ef4:	445e      	add	r6, fp
		t13 = (t10 + t12) * M5 >> 12;
60001ef6:	eb01 0b02 	add.w	fp, r1, r2
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001efa:	fb0a f202 	mul.w	r2, sl, r2
		v5 = (t11 - v7) * M13 >> 12;
60001efe:	fb09 fc0c 	mul.w	ip, r9, ip
		t13 = (t10 + t12) * M5 >> 12;
60001f02:	fb05 fb0b 	mul.w	fp, r5, fp
		v4 = t13 - (t10 * M2 >> 12);
60001f06:	f241 1551 	movw	r5, #4433	; 0x1151
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001f0a:	1312      	asrs	r2, r2, #12
		v4 = t13 - (t10 * M2 >> 12);
60001f0c:	4369      	muls	r1, r5
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001f0e:	ebc2 322b 	rsb	r2, r2, fp, asr #12
		v4 = t13 - (t10 * M2 >> 12);
60001f12:	1309      	asrs	r1, r1, #12
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001f14:	1b92      	subs	r2, r2, r6
		v4 = t13 - (t10 * M2 >> 12);
60001f16:	ebc1 312b 	rsb	r1, r1, fp, asr #12
		src[8 * 0] = v0 + v7;	/* Write-back transformed values */
60001f1a:	eb08 0b06 	add.w	fp, r8, r6
		src[8 * 7] = v0 - v7;
60001f1e:	eba8 0606 	sub.w	r6, r8, r6
		v5 -= v6;
60001f22:	ebc2 3c2c 	rsb	ip, r2, ip, asr #12
		src[8 * 0] = v0 + v7;	/* Write-back transformed values */
60001f26:	f843 bc04 	str.w	fp, [r3, #-4]
		src[8 * 7] = v0 - v7;
60001f2a:	f8c3 60dc 	str.w	r6, [r3, #220]	; 0xdc
		src[8 * 1] = v1 + v6;
60001f2e:	eb0e 0602 	add.w	r6, lr, r2
		src[8 * 6] = v1 - v6;
60001f32:	ebae 0202 	sub.w	r2, lr, r2
		v4 -= v5;
60001f36:	eba1 010c 	sub.w	r1, r1, ip
		src[8 * 1] = v1 + v6;
60001f3a:	61de      	str	r6, [r3, #28]
		src[8 * 6] = v1 - v6;
60001f3c:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
		src[8 * 2] = v2 + v5;
60001f40:	eb00 020c 	add.w	r2, r0, ip
		src[8 * 5] = v2 - v5;
60001f44:	eba0 000c 	sub.w	r0, r0, ip
		src[8 * 2] = v2 + v5;
60001f48:	63da      	str	r2, [r3, #60]	; 0x3c
		src[8 * 3] = v3 + v4;
60001f4a:	187a      	adds	r2, r7, r1
		src[8 * 4] = v3 - v4;
60001f4c:	1a7f      	subs	r7, r7, r1
		src[8 * 5] = v2 - v5;
60001f4e:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
		src[8 * 3] = v3 + v4;
60001f52:	65da      	str	r2, [r3, #92]	; 0x5c
	for (i = 0; i < 8; i++) {
60001f54:	9a09      	ldr	r2, [sp, #36]	; 0x24
		src[8 * 4] = v3 - v4;
60001f56:	67df      	str	r7, [r3, #124]	; 0x7c
	for (i = 0; i < 8; i++) {
60001f58:	4293      	cmp	r3, r2
60001f5a:	d1a5      	bne.n	60001ea8 <jd_decomp+0x31c>
	for (i = 0; i < 8; i++) {
60001f5c:	9a01      	ldr	r2, [sp, #4]
		t11 = (v1 - v3) * M13 >> 12;
60001f5e:	f44f 5ab5 	mov.w	sl, #5792	; 0x16a0
60001f62:	f102 0012 	add.w	r0, r2, #18
	for (i = 0; i < 8; i++) {
60001f66:	3292      	adds	r2, #146	; 0x92
60001f68:	9209      	str	r2, [sp, #36]	; 0x24
		v0 = src[0] + (128L << 8);	/* Get even elements (remove DC offset (-128) here) */
60001f6a:	f853 2c20 	ldr.w	r2, [r3, #-32]
		t13 = (t10 + t12) * M5 >> 12;
60001f6e:	f641 5590 	movw	r5, #7568	; 0x1d90
		v1 = src[2];
60001f72:	f853 cc18 	ldr.w	ip, [r3, #-24]
	for (i = 0; i < 8; i++) {
60001f76:	3010      	adds	r0, #16
		v2 = src[4];
60001f78:	f853 1c10 	ldr.w	r1, [r3, #-16]
		v0 = src[0] + (128L << 8);	/* Get even elements (remove DC offset (-128) here) */
60001f7c:	f502 4200 	add.w	r2, r2, #32768	; 0x8000
		v3 = src[6];
60001f80:	f853 6c08 	ldr.w	r6, [r3, #-8]
	for (i = 0; i < 8; i++) {
60001f84:	3320      	adds	r3, #32
		t10 = v0 + v2;				/* Process the even elements */
60001f86:	1857      	adds	r7, r2, r1
		t12 = v0 - v2;
60001f88:	1a52      	subs	r2, r2, r1
		t11 = (v1 - v3) * M13 >> 12;
60001f8a:	ebac 0106 	sub.w	r1, ip, r6
		v3 += v1;
60001f8e:	4466      	add	r6, ip
		v6 = src[5];
60001f90:	f853 ec2c 	ldr.w	lr, [r3, #-44]
		t11 = (v1 - v3) * M13 >> 12;
60001f94:	fb0a f101 	mul.w	r1, sl, r1
		v4 = src[7];				/* Get odd elements */
60001f98:	f853 cc24 	ldr.w	ip, [r3, #-36]
		v7 = src[3];
60001f9c:	f853 bc34 	ldr.w	fp, [r3, #-52]
		v0 = t10 + v3;
60001fa0:	eb07 0906 	add.w	r9, r7, r6
		t11 -= v3;
60001fa4:	ebc6 3121 	rsb	r1, r6, r1, asr #12
		v3 = t10 - v3;
60001fa8:	1bbf      	subs	r7, r7, r6
		v1 = t11 + t12;
60001faa:	eb02 0801 	add.w	r8, r2, r1
		v2 = t12 - t11;
60001fae:	1a52      	subs	r2, r2, r1
		v5 = src[1];
60001fb0:	f853 1c3c 	ldr.w	r1, [r3, #-60]
		t10 = v5 - v4;				/* Process the odd elements */
60001fb4:	eba1 060c 	sub.w	r6, r1, ip
		t11 = v5 + v4;
60001fb8:	448c      	add	ip, r1
		t12 = v6 - v7;
60001fba:	ebae 010b 	sub.w	r1, lr, fp
		v7 += v6;
60001fbe:	44f3      	add	fp, lr
		v5 = (t11 - v7) * M13 >> 12;
60001fc0:	ebac 0e0b 	sub.w	lr, ip, fp
		v7 += t11;
60001fc4:	44dc      	add	ip, fp
		t13 = (t10 + t12) * M5 >> 12;
60001fc6:	eb06 0b01 	add.w	fp, r6, r1
		v5 = (t11 - v7) * M13 >> 12;
60001fca:	fb0a fe0e 	mul.w	lr, sl, lr
		t13 = (t10 + t12) * M5 >> 12;
60001fce:	fb05 fb0b 	mul.w	fp, r5, fp
		v4 = t13 - (t10 * M2 >> 12);
60001fd2:	f241 1551 	movw	r5, #4433	; 0x1151
60001fd6:	436e      	muls	r6, r5
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001fd8:	f642 15cf 	movw	r5, #10703	; 0x29cf
60001fdc:	4369      	muls	r1, r5
		v4 = t13 - (t10 * M2 >> 12);
60001fde:	1336      	asrs	r6, r6, #12
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001fe0:	1309      	asrs	r1, r1, #12
		v4 = t13 - (t10 * M2 >> 12);
60001fe2:	ebc6 362b 	rsb	r6, r6, fp, asr #12
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001fe6:	ebc1 312b 	rsb	r1, r1, fp, asr #12
		dst[0] = (int16_t)((v0 + v7) >> 8);
60001fea:	eb09 0b0c 	add.w	fp, r9, ip
		dst[7] = (int16_t)((v0 - v7) >> 8);
60001fee:	eba9 090c 	sub.w	r9, r9, ip
		v6 = t13 - (t12 * M4 >> 12) - v7;
60001ff2:	eba1 010c 	sub.w	r1, r1, ip
		dst[0] = (int16_t)((v0 + v7) >> 8);
60001ff6:	ea4f 2b2b 	mov.w	fp, fp, asr #8
		dst[7] = (int16_t)((v0 - v7) >> 8);
60001ffa:	ea4f 2929 	mov.w	r9, r9, asr #8
		v5 -= v6;
60001ffe:	ebc1 3e2e 	rsb	lr, r1, lr, asr #12
		dst[1] = (int16_t)((v1 + v6) >> 8);
60002002:	eb08 0c01 	add.w	ip, r8, r1
		dst[6] = (int16_t)((v1 - v6) >> 8);
60002006:	eba8 0801 	sub.w	r8, r8, r1
		dst[0] = (int16_t)((v0 + v7) >> 8);
6000200a:	f820 bc20 	strh.w	fp, [r0, #-32]
		dst[2] = (int16_t)((v2 + v5) >> 8);
6000200e:	eb02 010e 	add.w	r1, r2, lr
		dst[5] = (int16_t)((v2 - v5) >> 8);
60002012:	eba2 020e 	sub.w	r2, r2, lr
		v4 -= v5;
60002016:	eba6 060e 	sub.w	r6, r6, lr
		dst[1] = (int16_t)((v1 + v6) >> 8);
6000201a:	ea4f 2c2c 	mov.w	ip, ip, asr #8
		dst[5] = (int16_t)((v2 - v5) >> 8);
6000201e:	1212      	asrs	r2, r2, #8
		dst[7] = (int16_t)((v0 - v7) >> 8);
60002020:	f820 9c12 	strh.w	r9, [r0, #-18]
		dst[6] = (int16_t)((v1 - v6) >> 8);
60002024:	ea4f 2828 	mov.w	r8, r8, asr #8
		dst[1] = (int16_t)((v1 + v6) >> 8);
60002028:	f820 cc1e 	strh.w	ip, [r0, #-30]
		dst[5] = (int16_t)((v2 - v5) >> 8);
6000202c:	f820 2c16 	strh.w	r2, [r0, #-22]
		dst[3] = (int16_t)((v3 + v4) >> 8);
60002030:	19ba      	adds	r2, r7, r6
		dst[4] = (int16_t)((v3 - v4) >> 8);
60002032:	1bbf      	subs	r7, r7, r6
		dst[2] = (int16_t)((v2 + v5) >> 8);
60002034:	1209      	asrs	r1, r1, #8
		dst[3] = (int16_t)((v3 + v4) >> 8);
60002036:	1212      	asrs	r2, r2, #8
		dst[6] = (int16_t)((v1 - v6) >> 8);
60002038:	f820 8c14 	strh.w	r8, [r0, #-20]
		dst[4] = (int16_t)((v3 - v4) >> 8);
6000203c:	123f      	asrs	r7, r7, #8
		dst[2] = (int16_t)((v2 + v5) >> 8);
6000203e:	f820 1c1c 	strh.w	r1, [r0, #-28]
		dst[3] = (int16_t)((v3 + v4) >> 8);
60002042:	f820 2c1a 	strh.w	r2, [r0, #-26]
	for (i = 0; i < 8; i++) {
60002046:	9a09      	ldr	r2, [sp, #36]	; 0x24
		dst[4] = (int16_t)((v3 - v4) >> 8);
60002048:	f820 7c18 	strh.w	r7, [r0, #-24]
	for (i = 0; i < 8; i++) {
6000204c:	4282      	cmp	r2, r0
6000204e:	d18c      	bne.n	60001f6a <jd_decomp+0x3de>
60002050:	e623      	b.n	60001c9a <jd_decomp+0x10e>
	rx = (x + mx <= jd->width) ? mx : jd->width - x;	/* Output rectangular size (it may be clipped at right/bottom end of image) */
60002052:	9b03      	ldr	r3, [sp, #12]
60002054:	1ac9      	subs	r1, r1, r3
60002056:	e637      	b.n	60001cc8 <jd_decomp+0x13c>
				if (my == 16) {		/* Double block height? */
60002058:	9b01      	ldr	r3, [sp, #4]
				pc = py = jd->mcubuf;
6000205a:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
				if (my == 16) {		/* Double block height? */
6000205c:	2b10      	cmp	r3, #16
6000205e:	d118      	bne.n	60002092 <jd_decomp+0x506>
					pc += 64 * 4 + (iy >> 1) * 8;
60002060:	ea4f 005c 	mov.w	r0, ip, lsr #1
					if (iy >= 8) py += 64;
60002064:	f1bc 0f07 	cmp.w	ip, #7
					pc += 64 * 4 + (iy >> 1) * 8;
60002068:	f100 0020 	add.w	r0, r0, #32
6000206c:	eb02 1000 	add.w	r0, r2, r0, lsl #4
					if (iy >= 8) py += 64;
60002070:	d900      	bls.n	60002074 <jd_decomp+0x4e8>
60002072:	3280      	adds	r2, #128	; 0x80
				py += iy * 8;
60002074:	eb02 120c 	add.w	r2, r2, ip, lsl #4
				for (ix = 0; ix < mx; ix++) {
60002078:	f107 0803 	add.w	r8, r7, #3
6000207c:	f04f 0e00 	mov.w	lr, #0
60002080:	45f2      	cmp	sl, lr
60002082:	d109      	bne.n	60002098 <jd_decomp+0x50c>
60002084:	9b0c      	ldr	r3, [sp, #48]	; 0x30
			for (iy = 0; iy < my; iy++) {
60002086:	f10c 0c01 	add.w	ip, ip, #1
6000208a:	f109 0910 	add.w	r9, r9, #16
6000208e:	441f      	add	r7, r3
60002090:	e64e      	b.n	60001d30 <jd_decomp+0x1a4>
					pc += mx * 8 + iy * 8;
60002092:	eb02 0009 	add.w	r0, r2, r9
60002096:	e7ed      	b.n	60002074 <jd_decomp+0x4e8>
					cb = pc[0] - 128; 	/* Get Cb/Cr component and remove offset */
60002098:	f9b0 6000 	ldrsh.w	r6, [r0]
					if (mx == 16) {					/* Double block width? */
6000209c:	f1ba 0f10 	cmp.w	sl, #16
					cr = pc[64] - 128;
600020a0:	f9b0 3080 	ldrsh.w	r3, [r0, #128]	; 0x80
					cb = pc[0] - 128; 	/* Get Cb/Cr component and remove offset */
600020a4:	f1a6 0680 	sub.w	r6, r6, #128	; 0x80
					cr = pc[64] - 128;
600020a8:	f1a3 0380 	sub.w	r3, r3, #128	; 0x80
					if (mx == 16) {					/* Double block width? */
600020ac:	d13c      	bne.n	60002128 <jd_decomp+0x59c>
						if (ix == 8) py += 64 - 8;	/* Jump to next block if double block heigt */
600020ae:	f1be 0f08 	cmp.w	lr, #8
						pc += ix & 1;				/* Step forward chroma pointer every two pixels */
600020b2:	f00e 0101 	and.w	r1, lr, #1
						if (ix == 8) py += 64 - 8;	/* Jump to next block if double block heigt */
600020b6:	bf08      	it	eq
600020b8:	3270      	addeq	r2, #112	; 0x70
						pc += ix & 1;				/* Step forward chroma pointer every two pixels */
600020ba:	eb00 0041 	add.w	r0, r0, r1, lsl #1
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr) / CVACC);
600020be:	f240 559b 	movw	r5, #1435	; 0x59b
					yy = *py++;			/* Get Y component */
600020c2:	f932 1b02 	ldrsh.w	r1, [r2], #2
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr) / CVACC);
600020c6:	435d      	muls	r5, r3
600020c8:	bf48      	it	mi
600020ca:	f205 35ff 	addwmi	r5, r5, #1023	; 0x3ff
	if (val < 0) return 0;
600020ce:	eb11 25a5 	adds.w	r5, r1, r5, asr #10
600020d2:	d42b      	bmi.n	6000212c <jd_decomp+0x5a0>
	if (val > 255) return 255;
600020d4:	2dff      	cmp	r5, #255	; 0xff
600020d6:	dc2b      	bgt.n	60002130 <jd_decomp+0x5a4>
	return (uint8_t)val;
600020d8:	b2ed      	uxtb	r5, r5
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
600020da:	fb0b f303 	mul.w	r3, fp, r3
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr) / CVACC);
600020de:	f808 5c03 	strb.w	r5, [r8, #-3]
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
600020e2:	f44f 75b0 	mov.w	r5, #352	; 0x160
600020e6:	fb05 3306 	mla	r3, r5, r6, r3
600020ea:	2b00      	cmp	r3, #0
600020ec:	bfb8      	it	lt
600020ee:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
	if (val < 0) return 0;
600020f2:	ebb1 23a3 	subs.w	r3, r1, r3, asr #10
600020f6:	d41d      	bmi.n	60002134 <jd_decomp+0x5a8>
	if (val > 255) return 255;
600020f8:	2bff      	cmp	r3, #255	; 0xff
600020fa:	dc1d      	bgt.n	60002138 <jd_decomp+0x5ac>
	return (uint8_t)val;
600020fc:	b2db      	uxtb	r3, r3
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
600020fe:	f808 3c02 	strb.w	r3, [r8, #-2]
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb) / CVACC);
60002102:	f240 7316 	movw	r3, #1814	; 0x716
60002106:	435e      	muls	r6, r3
60002108:	bf48      	it	mi
6000210a:	f206 36ff 	addwmi	r6, r6, #1023	; 0x3ff
	if (val < 0) return 0;
6000210e:	eb11 21a6 	adds.w	r1, r1, r6, asr #10
60002112:	d413      	bmi.n	6000213c <jd_decomp+0x5b0>
	if (val > 255) return 255;
60002114:	29ff      	cmp	r1, #255	; 0xff
60002116:	dc13      	bgt.n	60002140 <jd_decomp+0x5b4>
	return (uint8_t)val;
60002118:	b2c9      	uxtb	r1, r1
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb) / CVACC);
6000211a:	f808 1c01 	strb.w	r1, [r8, #-1]
				for (ix = 0; ix < mx; ix++) {
6000211e:	f10e 0e01 	add.w	lr, lr, #1
60002122:	f108 0803 	add.w	r8, r8, #3
60002126:	e7ab      	b.n	60002080 <jd_decomp+0x4f4>
						pc++;						/* Step forward chroma pointer every pixel */
60002128:	3002      	adds	r0, #2
6000212a:	e7c8      	b.n	600020be <jd_decomp+0x532>
	if (val < 0) return 0;
6000212c:	2500      	movs	r5, #0
6000212e:	e7d4      	b.n	600020da <jd_decomp+0x54e>
	if (val > 255) return 255;
60002130:	25ff      	movs	r5, #255	; 0xff
60002132:	e7d2      	b.n	600020da <jd_decomp+0x54e>
	if (val < 0) return 0;
60002134:	2300      	movs	r3, #0
60002136:	e7e2      	b.n	600020fe <jd_decomp+0x572>
	if (val > 255) return 255;
60002138:	23ff      	movs	r3, #255	; 0xff
6000213a:	e7e0      	b.n	600020fe <jd_decomp+0x572>
	if (val < 0) return 0;
6000213c:	2100      	movs	r1, #0
6000213e:	e7ec      	b.n	6000211a <jd_decomp+0x58e>
	if (val > 255) return 255;
60002140:	21ff      	movs	r1, #255	; 0xff
60002142:	e7ea      	b.n	6000211a <jd_decomp+0x58e>
			s = jd->scale * 2;	/* Number of shifts for averaging */
60002144:	005a      	lsls	r2, r3, #1
60002146:	fa0a f103 	lsl.w	r1, sl, r3
			op = (uint8_t*)jd->workbuf;
6000214a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
			s = jd->scale * 2;	/* Number of shifts for averaging */
6000214c:	9206      	str	r2, [sp, #24]
			w = 1 << jd->scale;	/* Width of square */
6000214e:	2201      	movs	r2, #1
60002150:	910f      	str	r1, [sp, #60]	; 0x3c
60002152:	2103      	movs	r1, #3
60002154:	409a      	lsls	r2, r3
			for (iy = 0; iy < my; iy += w) {
60002156:	fa01 f303 	lsl.w	r3, r1, r3
6000215a:	2100      	movs	r1, #0
6000215c:	9310      	str	r3, [sp, #64]	; 0x40
6000215e:	9108      	str	r1, [sp, #32]
60002160:	9b01      	ldr	r3, [sp, #4]
60002162:	9d08      	ldr	r5, [sp, #32]
60002164:	42ab      	cmp	r3, r5
60002166:	f67f adeb 	bls.w	60001d40 <jd_decomp+0x1b4>
6000216a:	eb01 0841 	add.w	r8, r1, r1, lsl #1
				for (ix = 0; ix < mx; ix += w) {
6000216e:	f04f 0e00 	mov.w	lr, #0
60002172:	e035      	b.n	600021e0 <jd_decomp+0x654>
60002174:	20004a99 	.word	0x20004a99
					pix = (uint8_t*)jd->workbuf + (iy * mx + ix) * (JD_FORMAT != 2 ? 3 : 1);
60002178:	eb05 0308 	add.w	r3, r5, r8
6000217c:	461e      	mov	r6, r3
					r = g = b = 0;
6000217e:	2300      	movs	r3, #0
60002180:	461f      	mov	r7, r3
60002182:	9309      	str	r3, [sp, #36]	; 0x24
					for (y = 0; y < w; y++) {	/* Accumulate RGB value in the square */
60002184:	930a      	str	r3, [sp, #40]	; 0x28
60002186:	9d0a      	ldr	r5, [sp, #40]	; 0x28
60002188:	42aa      	cmp	r2, r5
6000218a:	d01a      	beq.n	600021c2 <jd_decomp+0x636>
6000218c:	46b4      	mov	ip, r6
						for (x = 0; x < w; x++) {
6000218e:	f04f 0900 	mov.w	r9, #0
60002192:	e00c      	b.n	600021ae <jd_decomp+0x622>
							r += *pix++;	/* Accumulate R or Y (monochrome output) */
60002194:	f81c bc03 	ldrb.w	fp, [ip, #-3]
						for (x = 0; x < w; x++) {
60002198:	f109 0901 	add.w	r9, r9, #1
								g += *pix++;	/* Accumulate G */
6000219c:	9d09      	ldr	r5, [sp, #36]	; 0x24
							r += *pix++;	/* Accumulate R or Y (monochrome output) */
6000219e:	445f      	add	r7, fp
								g += *pix++;	/* Accumulate G */
600021a0:	f81c bc02 	ldrb.w	fp, [ip, #-2]
600021a4:	445d      	add	r5, fp
								b += *pix++;	/* Accumulate B */
600021a6:	f81c bc01 	ldrb.w	fp, [ip, #-1]
600021aa:	445b      	add	r3, fp
								g += *pix++;	/* Accumulate G */
600021ac:	9509      	str	r5, [sp, #36]	; 0x24
						for (x = 0; x < w; x++) {
600021ae:	454a      	cmp	r2, r9
600021b0:	f10c 0c03 	add.w	ip, ip, #3
600021b4:	d1ee      	bne.n	60002194 <jd_decomp+0x608>
						pix += a;
600021b6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
600021b8:	442e      	add	r6, r5
					for (y = 0; y < w; y++) {	/* Accumulate RGB value in the square */
600021ba:	9d0a      	ldr	r5, [sp, #40]	; 0x28
600021bc:	3501      	adds	r5, #1
600021be:	950a      	str	r5, [sp, #40]	; 0x28
600021c0:	e7e1      	b.n	60002186 <jd_decomp+0x5fa>
					*op++ = (uint8_t)(r >> s);	/* Put R or Y (monochrome output) */
600021c2:	9d06      	ldr	r5, [sp, #24]
600021c4:	3003      	adds	r0, #3
						*op++ = (uint8_t)(g >> s);	/* Put G */
600021c6:	9e09      	ldr	r6, [sp, #36]	; 0x24
				for (ix = 0; ix < mx; ix += w) {
600021c8:	4496      	add	lr, r2
					*op++ = (uint8_t)(r >> s);	/* Put R or Y (monochrome output) */
600021ca:	40ef      	lsrs	r7, r5
						*op++ = (uint8_t)(b >> s);	/* Put B */
600021cc:	40eb      	lsrs	r3, r5
						*op++ = (uint8_t)(g >> s);	/* Put G */
600021ce:	40ee      	lsrs	r6, r5
					*op++ = (uint8_t)(r >> s);	/* Put R or Y (monochrome output) */
600021d0:	f800 7c03 	strb.w	r7, [r0, #-3]
						*op++ = (uint8_t)(g >> s);	/* Put G */
600021d4:	f800 6c02 	strb.w	r6, [r0, #-2]
						*op++ = (uint8_t)(b >> s);	/* Put B */
600021d8:	f800 3c01 	strb.w	r3, [r0, #-1]
				for (ix = 0; ix < mx; ix += w) {
600021dc:	9b10      	ldr	r3, [sp, #64]	; 0x40
600021de:	4498      	add	r8, r3
600021e0:	45f2      	cmp	sl, lr
					pix = (uint8_t*)jd->workbuf + (iy * mx + ix) * (JD_FORMAT != 2 ? 3 : 1);
600021e2:	6ea5      	ldr	r5, [r4, #104]	; 0x68
				for (ix = 0; ix < mx; ix += w) {
600021e4:	d8c8      	bhi.n	60002178 <jd_decomp+0x5ec>
			for (iy = 0; iy < my; iy += w) {
600021e6:	9b08      	ldr	r3, [sp, #32]
600021e8:	4413      	add	r3, r2
600021ea:	9308      	str	r3, [sp, #32]
600021ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
600021ee:	4419      	add	r1, r3
600021f0:	e7b6      	b.n	60002160 <jd_decomp+0x5d4>
		pc = jd->mcubuf + mx * my;
600021f2:	9b01      	ldr	r3, [sp, #4]
		for (iy = 0; iy < my; iy += 8) {
600021f4:	2600      	movs	r6, #0
		pc = jd->mcubuf + mx * my;
600021f6:	fb03 f20a 	mul.w	r2, r3, sl
600021fa:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
600021fc:	eb03 0142 	add.w	r1, r3, r2, lsl #1
		cb = pc[0] - 128;		/* Get Cb/Cr component and restore right level */
60002200:	f933 2012 	ldrsh.w	r2, [r3, r2, lsl #1]
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60002204:	f240 23db 	movw	r3, #731	; 0x2db
		cr = pc[64] - 128;
60002208:	f9b1 0080 	ldrsh.w	r0, [r1, #128]	; 0x80
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr / CVACC));
6000220c:	f240 519b 	movw	r1, #1435	; 0x59b
		cb = pc[0] - 128;		/* Get Cb/Cr component and restore right level */
60002210:	3a80      	subs	r2, #128	; 0x80
		cr = pc[64] - 128;
60002212:	3880      	subs	r0, #128	; 0x80
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr / CVACC));
60002214:	4341      	muls	r1, r0
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60002216:	fb00 f303 	mul.w	r3, r0, r3
6000221a:	f44f 70b0 	mov.w	r0, #352	; 0x160
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr / CVACC));
6000221e:	bf48      	it	mi
60002220:	f201 31ff 	addwmi	r1, r1, #1023	; 0x3ff
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60002224:	fb00 3302 	mla	r3, r0, r2, r3
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb / CVACC));
60002228:	f240 7016 	movw	r0, #1814	; 0x716
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr / CVACC));
6000222c:	1289      	asrs	r1, r1, #10
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
6000222e:	2b00      	cmp	r3, #0
60002230:	bfb8      	it	lt
60002232:	f203 33ff 	addwlt	r3, r3, #1023	; 0x3ff
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb / CVACC));
60002236:	4350      	muls	r0, r2
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60002238:	ea4f 23a3 	mov.w	r3, r3, asr #10
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb / CVACC));
6000223c:	bf48      	it	mi
6000223e:	f200 30ff 	addwmi	r0, r0, #1023	; 0x3ff
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60002242:	425b      	negs	r3, r3
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb / CVACC));
60002244:	1280      	asrs	r0, r0, #10
		for (iy = 0; iy < my; iy += 8) {
60002246:	9a01      	ldr	r2, [sp, #4]
60002248:	42b2      	cmp	r2, r6
6000224a:	f67f ad79 	bls.w	60001d40 <jd_decomp+0x1b4>
			py = jd->mcubuf;
6000224e:	f8d4 e06c 	ldr.w	lr, [r4, #108]	; 0x6c
			if (iy == 8) py += 64 * 2;
60002252:	2e08      	cmp	r6, #8
	if (val > 255) return 255;
60002254:	f04f 0c00 	mov.w	ip, #0
			if (iy == 8) py += 64 * 2;
60002258:	bf08      	it	eq
6000225a:	f50e 7e80 	addeq.w	lr, lr, #256	; 0x100
			for (ix = 0; ix < mx; ix += 8) {
6000225e:	45e2      	cmp	sl, ip
60002260:	d801      	bhi.n	60002266 <jd_decomp+0x6da>
		for (iy = 0; iy < my; iy += 8) {
60002262:	3608      	adds	r6, #8
60002264:	e7ef      	b.n	60002246 <jd_decomp+0x6ba>
				yy = *py;	/* Get Y component */
60002266:	ea4f 120c 	mov.w	r2, ip, lsl #4
6000226a:	f93e 2002 	ldrsh.w	r2, [lr, r2]
	if (val < 0) return 0;
6000226e:	1855      	adds	r5, r2, r1
60002270:	d415      	bmi.n	6000229e <jd_decomp+0x712>
	if (val > 255) return 255;
60002272:	2dff      	cmp	r5, #255	; 0xff
60002274:	dc15      	bgt.n	600022a2 <jd_decomp+0x716>
	return (uint8_t)val;
60002276:	b2ed      	uxtb	r5, r5
					*pix++ = /*R*/ BYTECLIP(yy + ((int)(1.402 * CVACC) * cr / CVACC));
60002278:	703d      	strb	r5, [r7, #0]
	if (val < 0) return 0;
6000227a:	18d5      	adds	r5, r2, r3
6000227c:	d413      	bmi.n	600022a6 <jd_decomp+0x71a>
	if (val > 255) return 255;
6000227e:	2dff      	cmp	r5, #255	; 0xff
60002280:	dc13      	bgt.n	600022aa <jd_decomp+0x71e>
	return (uint8_t)val;
60002282:	b2ed      	uxtb	r5, r5
	if (val < 0) return 0;
60002284:	1812      	adds	r2, r2, r0
					*pix++ = /*G*/ BYTECLIP(yy - ((int)(0.344 * CVACC) * cb + (int)(0.714 * CVACC) * cr) / CVACC);
60002286:	707d      	strb	r5, [r7, #1]
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb / CVACC));
60002288:	f107 0703 	add.w	r7, r7, #3
	if (val < 0) return 0;
6000228c:	d40f      	bmi.n	600022ae <jd_decomp+0x722>
	if (val > 255) return 255;
6000228e:	2aff      	cmp	r2, #255	; 0xff
60002290:	dc0f      	bgt.n	600022b2 <jd_decomp+0x726>
	return (uint8_t)val;
60002292:	b2d2      	uxtb	r2, r2
			for (ix = 0; ix < mx; ix += 8) {
60002294:	f10c 0c08 	add.w	ip, ip, #8
					*pix++ = /*B*/ BYTECLIP(yy + ((int)(1.772 * CVACC) * cb / CVACC));
60002298:	f807 2c01 	strb.w	r2, [r7, #-1]
			for (ix = 0; ix < mx; ix += 8) {
6000229c:	e7df      	b.n	6000225e <jd_decomp+0x6d2>
	if (val < 0) return 0;
6000229e:	2500      	movs	r5, #0
600022a0:	e7ea      	b.n	60002278 <jd_decomp+0x6ec>
	if (val > 255) return 255;
600022a2:	25ff      	movs	r5, #255	; 0xff
600022a4:	e7e8      	b.n	60002278 <jd_decomp+0x6ec>
	if (val < 0) return 0;
600022a6:	2500      	movs	r5, #0
600022a8:	e7ec      	b.n	60002284 <jd_decomp+0x6f8>
	if (val > 255) return 255;
600022aa:	25ff      	movs	r5, #255	; 0xff
600022ac:	e7ea      	b.n	60002284 <jd_decomp+0x6f8>
	if (val < 0) return 0;
600022ae:	2200      	movs	r2, #0
600022b0:	e7f0      	b.n	60002294 <jd_decomp+0x708>
	if (val > 255) return 255;
600022b2:	22ff      	movs	r2, #255	; 0xff
600022b4:	e7ee      	b.n	60002294 <jd_decomp+0x708>
		s = d = (uint8_t*)jd->workbuf;
600022b6:	6ea0      	ldr	r0, [r4, #104]	; 0x68
		for (y = 0; y < ry; y++) {
600022b8:	eb03 0843 	add.w	r8, r3, r3, lsl #1
600022bc:	9a02      	ldr	r2, [sp, #8]
600022be:	2700      	movs	r7, #0
		s = d = (uint8_t*)jd->workbuf;
600022c0:	4606      	mov	r6, r0
600022c2:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
			for (x = 0; x < rx; x++) {	/* Copy effective pixels */
600022c6:	1cc1      	adds	r1, r0, #3
600022c8:	1cf2      	adds	r2, r6, #3
600022ca:	2500      	movs	r5, #0
				*d++ = *s++;
600022cc:	f811 ec03 	ldrb.w	lr, [r1, #-3]
			for (x = 0; x < rx; x++) {	/* Copy effective pixels */
600022d0:	3501      	adds	r5, #1
600022d2:	9b02      	ldr	r3, [sp, #8]
600022d4:	3103      	adds	r1, #3
				*d++ = *s++;
600022d6:	f802 ec03 	strb.w	lr, [r2, #-3]
			for (x = 0; x < rx; x++) {	/* Copy effective pixels */
600022da:	3203      	adds	r2, #3
					*d++ = *s++;
600022dc:	f811 ec05 	ldrb.w	lr, [r1, #-5]
			for (x = 0; x < rx; x++) {	/* Copy effective pixels */
600022e0:	42ab      	cmp	r3, r5
					*d++ = *s++;
600022e2:	f802 ec05 	strb.w	lr, [r2, #-5]
					*d++ = *s++;
600022e6:	f811 ec04 	ldrb.w	lr, [r1, #-4]
600022ea:	f802 ec04 	strb.w	lr, [r2, #-4]
			for (x = 0; x < rx; x++) {	/* Copy effective pixels */
600022ee:	d1ed      	bne.n	600022cc <jd_decomp+0x740>
		for (y = 0; y < ry; y++) {
600022f0:	3701      	adds	r7, #1
600022f2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
					*d++ = *s++;
600022f4:	4466      	add	r6, ip
			s += (mx - rx) * (JD_FORMAT != 2 ? 3 : 1);	/* Skip truncated pixels */
600022f6:	4440      	add	r0, r8
		for (y = 0; y < ry; y++) {
600022f8:	42bb      	cmp	r3, r7
600022fa:	d1e4      	bne.n	600022c6 <jd_decomp+0x73a>
600022fc:	e527      	b.n	60001d4e <jd_decomp+0x1c2>
		for (x = 0; x < jd->width; x += mx) {	/* Horizontal loop of MCUs */
600022fe:	2300      	movs	r3, #0
60002300:	e530      	b.n	60001d64 <jd_decomp+0x1d8>
	if (scale > (JD_USE_SCALE ? 3 : 0)) return JDR_PAR;
60002302:	2005      	movs	r0, #5
60002304:	e479      	b.n	60001bfa <jd_decomp+0x6e>
60002306:	2002      	movs	r0, #2
60002308:	e477      	b.n	60001bfa <jd_decomp+0x6e>
6000230a:	2001      	movs	r0, #1
6000230c:	e475      	b.n	60001bfa <jd_decomp+0x6e>
6000230e:	bf00      	nop

60002310 <MAX98357A::activityLevel()>:
    static volatile int _maxv_audio_block = 0;

    SLOWFUN tgx::iVec2 activityLevel()
        {
        //Serial.printf("act: %d , %d\n", _minv_audio_block, _maxv_audio_block);
        if (_minv_audio_block == 0 && _maxv_audio_block == 0) return tgx::iVec2(-1, -1);
60002310:	4a0b      	ldr	r2, [pc, #44]	; (60002340 <MAX98357A::activityLevel()+0x30>)
60002312:	4b0c      	ldr	r3, [pc, #48]	; (60002344 <MAX98357A::activityLevel()+0x34>)
60002314:	6811      	ldr	r1, [r2, #0]
60002316:	b931      	cbnz	r1, 60002326 <MAX98357A::activityLevel()+0x16>
60002318:	6819      	ldr	r1, [r3, #0]
6000231a:	b921      	cbnz	r1, 60002326 <MAX98357A::activityLevel()+0x16>


        /**
         * Constructor with explicit initialization.
         */
        constexpr Vec2(T X, T Y) : x(X), y(Y) {}
6000231c:	f04f 33ff 	mov.w	r3, #4294967295
60002320:	6003      	str	r3, [r0, #0]
60002322:	6043      	str	r3, [r0, #4]
        int ma = 4 + _minv_audio_block / ACTIVITY_LEVEL_SCALER;
        int mb = 4 + _maxv_audio_block / ACTIVITY_LEVEL_SCALER;
        return tgx::iVec2(ma, mb);
        }
60002324:	4770      	bx	lr
        int ma = 4 + _minv_audio_block / ACTIVITY_LEVEL_SCALER;
60002326:	6812      	ldr	r2, [r2, #0]
60002328:	f640 4135 	movw	r1, #3125	; 0xc35
        int mb = 4 + _maxv_audio_block / ACTIVITY_LEVEL_SCALER;
6000232c:	681b      	ldr	r3, [r3, #0]
        int ma = 4 + _minv_audio_block / ACTIVITY_LEVEL_SCALER;
6000232e:	fb92 f2f1 	sdiv	r2, r2, r1
        int mb = 4 + _maxv_audio_block / ACTIVITY_LEVEL_SCALER;
60002332:	fb93 f3f1 	sdiv	r3, r3, r1
        int ma = 4 + _minv_audio_block / ACTIVITY_LEVEL_SCALER;
60002336:	3204      	adds	r2, #4
        int mb = 4 + _maxv_audio_block / ACTIVITY_LEVEL_SCALER;
60002338:	3304      	adds	r3, #4
6000233a:	6002      	str	r2, [r0, #0]
6000233c:	e7f1      	b.n	60002322 <MAX98357A::activityLevel()+0x12>
6000233e:	bf00      	nop
60002340:	2001985c 	.word	0x2001985c
60002344:	20019858 	.word	0x20019858

60002348 <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)>:
        }


    SLOWFUN void AudioLedMusic::hsvToRgb(float h, float s, float v, uint8_t& r, uint8_t& g, uint8_t& b)
        {
        int i = int(h / 60.0f) % 6;
60002348:	ed9f 7a33 	vldr	s14, [pc, #204]	; 60002418 <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0xd0>
6000234c:	eec0 7a07 	vdiv.f32	s15, s0, s14
        {
60002350:	b530      	push	{r4, r5, lr}
        int i = int(h / 60.0f) % 6;
60002352:	2406      	movs	r4, #6
60002354:	eebd 7ae7 	vcvt.s32.f32	s14, s15
60002358:	ee17 0a10 	vmov	r0, s14
6000235c:	fb90 f5f4 	sdiv	r5, r0, r4
60002360:	fb04 0015 	mls	r0, r4, r5, r0
        float f = (h / 60.0f) - i;
60002364:	ee07 0a10 	vmov	s14, r0
60002368:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
6000236c:	ee77 6ac7 	vsub.f32	s13, s15, s14
        float p = v * (1.0f - s);
60002370:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
        float q = v * (1.0f - f * s);
60002374:	eeb0 6a67 	vmov.f32	s12, s15
        float p = v * (1.0f - s);
60002378:	ee37 7ae0 	vsub.f32	s14, s15, s1
        float q = v * (1.0f - f * s);
6000237c:	eea6 6ae0 	vfms.f32	s12, s13, s1
        float t = v * (1.0f - (1.0f - f) * s);
60002380:	ee77 6ae6 	vsub.f32	s13, s15, s13
        float p = v * (1.0f - s);
60002384:	ee27 7a01 	vmul.f32	s14, s14, s2
        float t = v * (1.0f - (1.0f - f) * s);
60002388:	eee6 7ae0 	vfms.f32	s15, s13, s1
        float q = v * (1.0f - f * s);
6000238c:	ee26 6a01 	vmul.f32	s12, s12, s2
        float t = v * (1.0f - (1.0f - f) * s);
60002390:	ee67 7a81 	vmul.f32	s15, s15, s2
        float rf, gf, bf;
        switch (i) {
60002394:	2804      	cmp	r0, #4
60002396:	d839      	bhi.n	6000240c <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0xc4>
60002398:	e8df f000 	tbb	[pc, r0]
6000239c:	281f0307 	.word	0x281f0307
600023a0:	31          	.byte	0x31
600023a1:	00          	.byte	0x00
600023a2:	eef0 7a41 	vmov.f32	s15, s2
600023a6:	eeb0 1a46 	vmov.f32	s2, s12
            case 2: rf = p; gf = v; bf = t; break;
            case 3: rf = p; gf = q; bf = v; break;
            case 4: rf = t; gf = p; bf = v; break;
            default: rf = v; gf = p; bf = q; break;
            }
        r = (uint8_t)(rf * 255.0f);
600023aa:	eddf 6a1c 	vldr	s13, [pc, #112]	; 6000241c <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0xd4>
600023ae:	ee21 1a26 	vmul.f32	s2, s2, s13
        g = (uint8_t)(gf * 255.0f);
600023b2:	ee67 7aa6 	vmul.f32	s15, s15, s13
        b = (uint8_t)(bf * 255.0f);
600023b6:	ee27 7a26 	vmul.f32	s14, s14, s13
        r = (uint8_t)(rf * 255.0f);
600023ba:	eebc 6ac1 	vcvt.u32.f32	s12, s2
        g = (uint8_t)(gf * 255.0f);
600023be:	eefc 7ae7 	vcvt.u32.f32	s15, s15
        r = (uint8_t)(rf * 255.0f);
600023c2:	ee16 0a10 	vmov	r0, s12
600023c6:	7008      	strb	r0, [r1, #0]
        g = (uint8_t)(gf * 255.0f);
600023c8:	ee17 1a90 	vmov	r1, s15
        b = (uint8_t)(bf * 255.0f);
600023cc:	eefc 7ac7 	vcvt.u32.f32	s15, s14
        g = (uint8_t)(gf * 255.0f);
600023d0:	7011      	strb	r1, [r2, #0]
        b = (uint8_t)(bf * 255.0f);
600023d2:	ee17 2a90 	vmov	r2, s15
600023d6:	701a      	strb	r2, [r3, #0]
        }
600023d8:	bd30      	pop	{r4, r5, pc}
            case 2: rf = p; gf = v; bf = t; break;
600023da:	eef0 6a41 	vmov.f32	s13, s2
600023de:	eeb0 1a47 	vmov.f32	s2, s14
600023e2:	eeb0 7a67 	vmov.f32	s14, s15
600023e6:	eef0 7a66 	vmov.f32	s15, s13
600023ea:	e7de      	b.n	600023aa <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0x62>
            case 3: rf = p; gf = q; bf = v; break;
600023ec:	eef0 6a41 	vmov.f32	s13, s2
600023f0:	eef0 7a46 	vmov.f32	s15, s12
600023f4:	eeb0 1a47 	vmov.f32	s2, s14
            case 4: rf = t; gf = p; bf = v; break;
600023f8:	eeb0 7a66 	vmov.f32	s14, s13
600023fc:	e7d5      	b.n	600023aa <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0x62>
600023fe:	eef0 6a41 	vmov.f32	s13, s2
60002402:	eeb0 1a67 	vmov.f32	s2, s15
60002406:	eef0 7a47 	vmov.f32	s15, s14
6000240a:	e7f5      	b.n	600023f8 <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0xb0>
            default: rf = v; gf = p; bf = q; break;
6000240c:	eef0 7a47 	vmov.f32	s15, s14
60002410:	eeb0 7a46 	vmov.f32	s14, s12
60002414:	e7c9      	b.n	600023aa <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)+0x62>
60002416:	bf00      	nop
60002418:	42700000 	.word	0x42700000
6000241c:	437f0000 	.word	0x437f0000

60002420 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)>:
        {
60002420:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
60002424:	460d      	mov	r5, r1
60002426:	4604      	mov	r4, r0
60002428:	4616      	mov	r6, r2
6000242a:	ed2d 8b0a 	vpush	{d8-d12}
6000242e:	b089      	sub	sp, #36	; 0x24
60002430:	eef0 8a40 	vmov.f32	s17, s0
	elapsedMicros(void) { us = micros(); }
	elapsedMicros(unsigned long val) { us = micros() - val; }
	elapsedMicros(const elapsedMicros &orig) { us = orig.us; }
	operator unsigned long () const { return micros() - us; }
	elapsedMicros & operator = (const elapsedMicros &rhs) { us = rhs.us; return *this; }
	elapsedMicros & operator = (unsigned long val) { us = micros() - val; return *this; }
60002434:	f038 fddc 	bl	6003aff0 <__micros_veneer>
        if (peak<0) 
60002438:	2d00      	cmp	r5, #0
6000243a:	edd4 7a06 	vldr	s15, [r4, #24]
6000243e:	6160      	str	r0, [r4, #20]
60002440:	f280 80c5 	bge.w	600025ce <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x1ae>
            level *= decaySpeed;
60002444:	ed94 8a01 	vldr	s16, [r4, #4]
60002448:	ee27 8a88 	vmul.f32	s16, s15, s16
        frameCounter++;
6000244c:	69e7      	ldr	r7, [r4, #28]
            if ((level > flashThreshold) && ((i % 5) == ((int)(frameCounter % 5)))) 
6000244e:	2305      	movs	r3, #5
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
60002450:	ed9f 9a77 	vldr	s18, [pc, #476]	; 60002630 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x210>
60002454:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
        frameCounter++;
60002458:	3701      	adds	r7, #1
6000245a:	f104 0920 	add.w	r9, r4, #32
        for (int i = 0; i < LED_COUNT; ++i) 
6000245e:	f04f 0800 	mov.w	r8, #0
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
60002462:	eddf aa74 	vldr	s21, [pc, #464]	; 60002634 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x214>
60002466:	ee07 7a90 	vmov	s15, r7
        frameCounter++;
6000246a:	61e7      	str	r7, [r4, #28]
            float hue = fmod(frameCounter * colorSpeed * 360.0f + i * 12.0f, 360.0f);
6000246c:	ed9f aa72 	vldr	s20, [pc, #456]	; 60002638 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x218>
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
60002470:	eef8 9a67 	vcvt.f32.u32	s19, s15
60002474:	ed84 8a06 	vstr	s16, [r4, #24]
            if ((level > flashThreshold) && ((i % 5) == ((int)(frameCounter % 5)))) 
60002478:	fbb7 f3f3 	udiv	r3, r7, r3
6000247c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
60002480:	ee29 9a89 	vmul.f32	s18, s19, s18
            if ((level > flashThreshold) && ((i % 5) == ((int)(frameCounter % 5)))) 
60002484:	1aff      	subs	r7, r7, r3
            float pos = (float)i / (LED_COUNT - 1);
60002486:	ee07 8a90 	vmov	s15, r8
6000248a:	eeb3 7a08 	vmov.f32	s14, #56	; 0x41c00000  24.0
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
6000248e:	eeb0 0a49 	vmov.f32	s0, s18
            float pos = (float)i / (LED_COUNT - 1);
60002492:	eeb8 cae7 	vcvt.f32.s32	s24, s15
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
60002496:	eef6 ba00 	vmov.f32	s23, #96	; 0x3f000000  0.5
            float pos = (float)i / (LED_COUNT - 1);
6000249a:	eecc 7a07 	vdiv.f32	s15, s24, s14
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
6000249e:	ed94 7a03 	vldr	s14, [r4, #12]
600024a2:	ee97 0a27 	vfnms.f32	s0, s14, s15
600024a6:	ee20 0a2a 	vmul.f32	s0, s0, s21
600024aa:	f038 fd89 	bl	6003afc0 <__sinf_veneer>
            trail[i] *= decaySpeed;
600024ae:	ed94 7a01 	vldr	s14, [r4, #4]
600024b2:	edd9 7a00 	vldr	s15, [r9]
            float wave = sinf(2.0f * 3.14159f * (waveFrequency * pos - frameCounter * 0.01f)) * 0.5f + 0.5f;
600024b6:	eee0 ba2b 	vfma.f32	s23, s0, s23
  using ::fmod;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }
600024ba:	eddf 0a5f 	vldr	s1, [pc, #380]	; 60002638 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x218>
            trail[i] *= decaySpeed;
600024be:	ee67 7a87 	vmul.f32	s15, s15, s14
            float hue = fmod(frameCounter * colorSpeed * 360.0f + i * 12.0f, 360.0f);
600024c2:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
            if (trail[i] < level) trail[i] = level;
600024c6:	eef4 7a48 	vcmp.f32	s15, s16
            float hue = fmod(frameCounter * colorSpeed * 360.0f + i * 12.0f, 360.0f);
600024ca:	ee2c 0a07 	vmul.f32	s0, s24, s14
            if (trail[i] < level) trail[i] = level;
600024ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600024d2:	bf48      	it	mi
600024d4:	eef0 7a48 	vmovmi.f32	s15, s16
600024d8:	ece9 7a01 	vstmia	r9!, {s15}
            float intensity = trail[i] * wave;
600024dc:	ee6b baa7 	vmul.f32	s23, s23, s15
            float hue = fmod(frameCounter * colorSpeed * 360.0f + i * 12.0f, 360.0f);
600024e0:	edd4 7a02 	vldr	s15, [r4, #8]
600024e4:	ee69 7aa7 	vmul.f32	s15, s19, s15
600024e8:	eea7 0a8a 	vfma.f32	s0, s15, s20
600024ec:	f038 ff4c 	bl	6003b388 <__fmodf_veneer>
            if ((level > flashThreshold) && ((i % 5) == ((int)(frameCounter % 5)))) 
600024f0:	edd4 7a04 	vldr	s15, [r4, #16]
600024f4:	eef4 7ac8 	vcmpe.f32	s15, s16
600024f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600024fc:	d512      	bpl.n	60002524 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x104>
600024fe:	2305      	movs	r3, #5
60002500:	fbb8 f3f3 	udiv	r3, r8, r3
60002504:	eb03 0383 	add.w	r3, r3, r3, lsl #2
60002508:	eba8 0303 	sub.w	r3, r8, r3
6000250c:	42bb      	cmp	r3, r7
6000250e:	d109      	bne.n	60002524 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x104>
60002510:	eddf 7a4a 	vldr	s15, [pc, #296]	; 6000263c <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x21c>
                value = 1.0f;
60002514:	eef7 ba00 	vmov.f32	s23, #112	; 0x3f800000  1.0
60002518:	eef0 0a4a 	vmov.f32	s1, s20
6000251c:	ee30 0a27 	vadd.f32	s0, s0, s15
60002520:	f038 ff32 	bl	6003b388 <__fmodf_veneer>
            hsvToRgb(hue, saturation, value, r, g, b);
60002524:	f10d 031f 	add.w	r3, sp, #31
60002528:	eeb0 1a6b 	vmov.f32	s2, s23
6000252c:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
60002530:	f10d 021e 	add.w	r2, sp, #30
60002534:	f10d 011d 	add.w	r1, sp, #29
60002538:	4620      	mov	r0, r4
6000253a:	f7ff ff05 	bl	60002348 <MAX98357A::AudioLedMusic::hsvToRgb(float, float, float, unsigned char&, unsigned char&, unsigned char&)>
            if (opacity < 1.0f)
6000253e:	f89d 301f 	ldrb.w	r3, [sp, #31]
60002542:	eef4 8acb 	vcmpe.f32	s17, s22
60002546:	ed94 6a00 	vldr	s12, [r4]
6000254a:	ee06 3a90 	vmov	s13, r3
6000254e:	f89d 301e 	ldrb.w	r3, [sp, #30]
60002552:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002556:	ee07 3a10 	vmov	s14, r3
6000255a:	f89d 301d 	ldrb.w	r3, [sp, #29]
6000255e:	ee07 3a90 	vmov	s15, r3
60002562:	d549      	bpl.n	600025f8 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x1d8>
                leds[i].blend(tgx::RGB24((int)(r * brightness), (int)(g * brightness), (int)(b * brightness)), opacity);
60002564:	eef8 7ae7 	vcvt.f32.s32	s15, s15
         * @param   fg_col  The foreground color.
         * @param   alpha   The opacity/alpha multiplier in [0.0f, 1.0f].
         */
        inline void blend(const RGB24 & fg_col, float alpha)
            {
            blend256(fg_col, (uint32_t)(alpha * 256));
60002568:	4630      	mov	r0, r6
6000256a:	eef8 6ae6 	vcvt.f32.s32	s13, s13
6000256e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
60002572:	ee67 7a86 	vmul.f32	s15, s15, s12
60002576:	ee66 6a86 	vmul.f32	s13, s13, s12
6000257a:	ee27 7a06 	vmul.f32	s14, s14, s12
6000257e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
60002582:	eefd 6ae6 	vcvt.s32.f32	s13, s13
60002586:	eebd 7ac7 	vcvt.s32.f32	s14, s14
6000258a:	edcd 7a05 	vstr	s15, [sp, #20]
6000258e:	eddf 7a2c 	vldr	s15, [pc, #176]	; 60002640 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x220>
60002592:	edcd 6a03 	vstr	s13, [sp, #12]
60002596:	ee68 7aa7 	vmul.f32	s15, s17, s15
6000259a:	ed8d 7a04 	vstr	s14, [sp, #16]
6000259e:	f89d 300c 	ldrb.w	r3, [sp, #12]
600025a2:	f89d 2010 	ldrb.w	r2, [sp, #16]
600025a6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
600025aa:	f89d 1014 	ldrb.w	r1, [sp, #20]
600025ae:	edcd 7a00 	vstr	s15, [sp]
600025b2:	f038 ff91 	bl	6003b4d8 <___ZN3tgx5RGB248blend256ERKS0_m.isra.0_veneer>
        for (int i = 0; i < LED_COUNT; ++i) 
600025b6:	f108 0801 	add.w	r8, r8, #1
600025ba:	3603      	adds	r6, #3
600025bc:	f1b8 0f19 	cmp.w	r8, #25
600025c0:	f47f af61 	bne.w	60002486 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x66>
        }
600025c4:	b009      	add	sp, #36	; 0x24
600025c6:	ecbd 8b0a 	vpop	{d8-d12}
600025ca:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            float newLevel = 1.2f * peak / 32768.0f;
600025ce:	ee07 5a10 	vmov	s14, r5
600025d2:	eeb8 8ac7 	vcvt.f32.s32	s16, s14
600025d6:	ed9f 7a1b 	vldr	s14, [pc, #108]	; 60002644 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x224>
600025da:	ee28 8a07 	vmul.f32	s16, s16, s14
600025de:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 60002648 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x228>
600025e2:	ee28 8a07 	vmul.f32	s16, s16, s14
            level = level * 0.7f + newLevel * 0.3f;
600025e6:	ed9f 7a19 	vldr	s14, [pc, #100]	; 6000264c <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x22c>
600025ea:	ee28 8a07 	vmul.f32	s16, s16, s14
600025ee:	ed9f 7a18 	vldr	s14, [pc, #96]	; 60002650 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x230>
600025f2:	eea7 8a87 	vfma.f32	s16, s15, s14
600025f6:	e729      	b.n	6000244c <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x2c>
                leds[i] = tgx::RGB24((int)(r * brightness), (int)(g * brightness), (int)(b * brightness));
600025f8:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
600025fc:	eef8 6ae6 	vcvt.f32.s32	s13, s13
60002600:	eef8 7ae7 	vcvt.f32.s32	s15, s15
60002604:	ee27 7a06 	vmul.f32	s14, s14, s12
60002608:	ee66 6a86 	vmul.f32	s13, s13, s12
6000260c:	ee67 7a86 	vmul.f32	s15, s15, s12
60002610:	eebd 7ac7 	vcvt.s32.f32	s14, s14
60002614:	eefd 7ae7 	vcvt.s32.f32	s15, s15
60002618:	ee17 1a10 	vmov	r1, s14
6000261c:	eebd 7ae6 	vcvt.s32.f32	s14, s13
60002620:	ee17 3a90 	vmov	r3, s15
60002624:	7071      	strb	r1, [r6, #1]
60002626:	ee17 5a10 	vmov	r5, s14
                                                R((uint8_t)r), G((uint8_t)g), B((uint8_t)b)
6000262a:	7033      	strb	r3, [r6, #0]
6000262c:	70b5      	strb	r5, [r6, #2]
6000262e:	e7c2      	b.n	600025b6 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)+0x196>
60002630:	3c23d70a 	.word	0x3c23d70a
60002634:	40c90fd0 	.word	0x40c90fd0
60002638:	43b40000 	.word	0x43b40000
6000263c:	43340000 	.word	0x43340000
60002640:	43800000 	.word	0x43800000
60002644:	3f99999a 	.word	0x3f99999a
60002648:	38000000 	.word	0x38000000
6000264c:	3e99999a 	.word	0x3e99999a
60002650:	3f333333 	.word	0x3f333333

60002654 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)>:
    return tgx::RGBf(rf, gf, bf);
    }



SLOWFUN void AudioLedVoice::create(int32_t peak, tgx::RGB24* leds, float opacity) {
60002654:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
60002658:	4604      	mov	r4, r0
6000265a:	460d      	mov	r5, r1
6000265c:	4617      	mov	r7, r2
6000265e:	ed2d 8b10 	vpush	{d8-d15}
60002662:	b086      	sub	sp, #24
60002664:	eef0 aa40 	vmov.f32	s21, s0
	operator unsigned long () const { return micros() - us; }
60002668:	f038 fcc2 	bl	6003aff0 <__micros_veneer>
6000266c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
6000266e:	1ac6      	subs	r6, r0, r3
	elapsedMicros & operator = (unsigned long val) { us = micros() - val; return *this; }
60002670:	f038 fcbe 	bl	6003aff0 <__micros_veneer>
    const int us = (int)_em;
    _em = 0;
    idleTime += us / 1000000.0f;
    _frame++; // pour le dithering
60002674:	8f23      	ldrh	r3, [r4, #56]	; 0x38
    idleTime += us / 1000000.0f;
60002676:	ee07 6a90 	vmov	s15, r6


    if (tint_period > 0)
6000267a:	6a66      	ldr	r6, [r4, #36]	; 0x24
    _frame++; // pour le dithering
6000267c:	3301      	adds	r3, #1
6000267e:	62a0      	str	r0, [r4, #40]	; 0x28
    idleTime += us / 1000000.0f;
60002680:	eef8 5ae7 	vcvt.f32.s32	s11, s15
60002684:	eddf 7ad3 	vldr	s15, [pc, #844]	; 600029d4 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x380>
    _frame++; // pour le dithering
60002688:	8723      	strh	r3, [r4, #56]	; 0x38
    idleTime += us / 1000000.0f;
6000268a:	ee85 7aa7 	vdiv.f32	s14, s11, s15
6000268e:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
60002692:	ee77 7a87 	vadd.f32	s15, s15, s14
60002696:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    if (tint_period > 0)
6000269a:	b1fe      	cbz	r6, 600026dc <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x88>
6000269c:	4bce      	ldr	r3, [pc, #824]	; (600029d8 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x384>)
        { // recompute tint
        float ff = 360*(((float)(millis() % tint_period)) / ((float)tint_period));
6000269e:	ee07 6a10 	vmov	s14, r6
        tgx::RGBf col = hsvToRgb(ff, 1.0f, 1.0f);
600026a2:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
600026a6:	681b      	ldr	r3, [r3, #0]
        float ff = 360*(((float)(millis() % tint_period)) / ((float)tint_period));
600026a8:	eeb8 7a47 	vcvt.f32.u32	s14, s14
600026ac:	fbb3 f2f6 	udiv	r2, r3, r6
600026b0:	fb06 3312 	mls	r3, r6, r2, r3
        tgx::RGBf col = hsvToRgb(ff, 1.0f, 1.0f);
600026b4:	eef0 0a41 	vmov.f32	s1, s2
        float ff = 360*(((float)(millis() % tint_period)) / ((float)tint_period));
600026b8:	ee07 3a90 	vmov	s15, r3
600026bc:	eef8 7a67 	vcvt.f32.u32	s15, s15
600026c0:	ee87 0a87 	vdiv.f32	s0, s15, s14
        tgx::RGBf col = hsvToRgb(ff, 1.0f, 1.0f);
600026c4:	eddf 7ac5 	vldr	s15, [pc, #788]	; 600029dc <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x388>
600026c8:	ee20 0a27 	vmul.f32	s0, s0, s15
600026cc:	f039 f844 	bl	6003b758 <___ZN9MAX98357A8hsvToRgbEfff_veneer>
        idleTintR = col.R;
        idleTintG = col.G;
600026d0:	edc4 0a07 	vstr	s1, [r4, #28]
        idleTintB = col.B;
600026d4:	ed84 1a08 	vstr	s2, [r4, #32]
        idleTintR = col.R;
600026d8:	ed84 0a06 	vstr	s0, [r4, #24]
        }

    bool voiceDetected = false;

    if (peak < 0) {
600026dc:	2d00      	cmp	r5, #0
600026de:	eeb7 ea00 	vmov.f32	s28, #112	; 0x3f800000  1.0
        voiceLevel *= 0.95f;
600026e2:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
600026e6:	eddf 8abe 	vldr	s17, [pc, #760]	; 600029e0 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x38c>
    if (peak < 0) {
600026ea:	da16      	bge.n	6000271a <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0xc6>
        voiceLevel *= 0.95f;
600026ec:	eddf 7abd 	vldr	s15, [pc, #756]	; 600029e4 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x390>
600026f0:	ee27 7a27 	vmul.f32	s14, s14, s15
600026f4:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c

    if (voiceDetected) {
        idleBlend = 0.0f;
        idleTime = 0.0f;
        } else {
        float delta = us / 800000.0f;
600026f8:	ed9f 7abb 	vldr	s14, [pc, #748]	; 600029e8 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x394>
600026fc:	eec5 7a87 	vdiv.f32	s15, s11, s14
        idleBlend = constrain(idleBlend + delta, 0.0f, 1.0f);
60002700:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
60002704:	ee77 7a87 	vadd.f32	s15, s15, s14
60002708:	eef4 7ae8 	vcmpe.f32	s15, s17
6000270c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002710:	f140 80b9 	bpl.w	60002886 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x232>
60002714:	eef0 7a68 	vmov.f32	s15, s17
60002718:	e0bb      	b.n	60002892 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x23e>
        float newLevel = 1.0f * peak / 32768.0f;
6000271a:	ee07 5a90 	vmov	s15, r5
        voiceLevel = voiceLevel * 0.7f + newLevel * 0.3f;
6000271e:	eddf 6ab3 	vldr	s13, [pc, #716]	; 600029ec <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x398>
        idleBlend = 0.0f;
60002722:	edc4 8a0c 	vstr	s17, [r4, #48]	; 0x30
        float newLevel = 1.0f * peak / 32768.0f;
60002726:	eefa 7ae8 	vcvt.f32.s32	s15, s15, #15
        idleTime = 0.0f;
6000272a:	edc4 8a0d 	vstr	s17, [r4, #52]	; 0x34
        if (newLevel > 1.0f) newLevel = 1.0f;
6000272e:	eef4 7a4e 	vcmp.f32	s15, s28
60002732:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002736:	fe7e 7a27 	vselgt.f32	s15, s28, s15
        voiceLevel = voiceLevel * 0.7f + newLevel * 0.3f;
6000273a:	ee67 7aa6 	vmul.f32	s15, s15, s13
6000273e:	eddf 6aac 	vldr	s13, [pc, #688]	; 600029f0 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x39c>
60002742:	eee7 7a26 	vfma.f32	s15, s14, s13
60002746:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        }

    float baseR = 65, baseG = 135, baseB = 113;
    float activeR = 0, activeG = 255, activeB = 100;
    if (tint_period > 0)
6000274a:	2e00      	cmp	r6, #0
6000274c:	f040 80e2 	bne.w	60002914 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2c0>
        activeB = 255;
        }



    float breathFactor = 1.0f;
60002750:	eef0 ea4e 	vmov.f32	s29, s28
    float activeR = 0, activeG = 255, activeB = 100;
60002754:	ed9f faa7 	vldr	s30, [pc, #668]	; 600029f4 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3a0>
    float baseR = 65, baseG = 135, baseB = 113;
60002758:	ed9f aaa7 	vldr	s20, [pc, #668]	; 600029f8 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3a4>
6000275c:	eddf 9aa7 	vldr	s19, [pc, #668]	; 600029fc <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3a8>
60002760:	ed9f 9aa7 	vldr	s18, [pc, #668]	; 60002a00 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3ac>
    const float brightnessFactor = voiceBrightnessFactor;

    const int mid = LED_COUNT / 2;
    float yTarget = voiceLevel;

    for (int i = 0; i < LED_COUNT; ++i) {
60002764:	2500      	movs	r5, #0
    const float brightnessFactor = voiceBrightnessFactor;
60002766:	ed94 da00 	vldr	s26, [r4]
    float yTarget = voiceLevel;
6000276a:	ed94 ba0b 	vldr	s22, [r4, #44]	; 0x2c
        int sym = (i <= mid) ? i : (LED_COUNT - 1 - i);
6000276e:	463e      	mov	r6, r7
    for (int i = 0; i < LED_COUNT; ++i) {
60002770:	462b      	mov	r3, r5
        float y = (float)sym / mid;
        float dist = fabs(y - yTarget);

        float window = 0.12f;
        float intensity = constrain(1.0f - dist / window, 0.0f, 1.0f);
60002772:	eddf baa4 	vldr	s23, [pc, #656]	; 60002a04 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3b0>
        intensity = intensity * intensity * (3 - 2 * intensity);
        intensity *= voiceLevel;

        float r, g, b;

        if (intensity > 0.01f) {
60002776:	ed9f caa4 	vldr	s24, [pc, #656]	; 60002a08 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3b4>
            // bande active voix
            float cR = baseR * (1 - y) + activeR * y;
            float cG = baseG * (1 - y) + activeG * y;
6000277a:	eddf caa4 	vldr	s25, [pc, #656]	; 60002a0c <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3b8>
        float y = (float)sym / mid;
6000277e:	ee07 3a90 	vmov	s15, r3
60002782:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
60002786:	eef8 7ae7 	vcvt.f32.s32	s15, s15
6000278a:	eec7 6a87 	vdiv.f32	s13, s15, s14
        float dist = fabs(y - yTarget);
6000278e:	ee76 7acb 	vsub.f32	s15, s13, s22
  { return __builtin_fabsf(__x); }
60002792:	eef0 7ae7 	vabs.f32	s15, s15
        float intensity = constrain(1.0f - dist / window, 0.0f, 1.0f);
60002796:	ee87 7aab 	vdiv.f32	s14, s15, s23
6000279a:	ee3e 7a47 	vsub.f32	s14, s28, s14
6000279e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
600027a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600027a6:	f100 80cd 	bmi.w	60002944 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2f0>
600027aa:	eeb4 7a4e 	vcmp.f32	s14, s28
600027ae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
600027b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600027b6:	fe37 7a87 	vselgt.f32	s14, s15, s14
        intensity = intensity * intensity * (3 - 2 * intensity);
600027ba:	eeb0 6a08 	vmov.f32	s12, #8	; 0x40400000  3.0
600027be:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
600027c2:	ee67 7a07 	vmul.f32	s15, s14, s14
600027c6:	eeb0 5a46 	vmov.f32	s10, s12
600027ca:	eea7 5a65 	vfms.f32	s10, s14, s11
600027ce:	ee67 7a85 	vmul.f32	s15, s15, s10
        intensity *= voiceLevel;
600027d2:	ee6b 7a27 	vmul.f32	s15, s22, s15
        if (intensity > 0.01f) {
600027d6:	eef4 7acc 	vcmpe.f32	s15, s24
600027da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600027de:	f340 80b4 	ble.w	6000294a <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2f6>
            float cR = baseR * (1 - y) + activeR * y;
600027e2:	ee3e 7a66 	vsub.f32	s14, s28, s13
600027e6:	ee26 0aa8 	vmul.f32	s0, s13, s17
            float cG = baseG * (1 - y) + activeG * y;
600027ea:	ee66 daac 	vmul.f32	s27, s13, s25
            float cB = baseB * (1 - y) + activeB * y;
600027ee:	ee66 6a8f 	vmul.f32	s13, s13, s30
            float cR = baseR * (1 - y) + activeR * y;
600027f2:	eea7 0a09 	vfma.f32	s0, s14, s18
            float cG = baseG * (1 - y) + activeG * y;
600027f6:	eee7 da29 	vfma.f32	s27, s14, s19
            float cB = baseB * (1 - y) + activeB * y;
600027fa:	eee7 6a0a 	vfma.f32	s13, s14, s20
            r = cR * intensity * voiceBoostFactor;
600027fe:	ed94 7a01 	vldr	s14, [r4, #4]
60002802:	ee27 0a80 	vmul.f32	s0, s15, s0
            g = cG * intensity * voiceBoostFactor;
60002806:	ee67 daad 	vmul.f32	s27, s15, s27
            b = cB * intensity * voiceBoostFactor;
6000280a:	ee67 7aa6 	vmul.f32	s15, s15, s13
            r = cR * intensity * voiceBoostFactor;
6000280e:	ee20 0a07 	vmul.f32	s0, s0, s14
            g = cG * intensity * voiceBoostFactor;
60002812:	ee6d da87 	vmul.f32	s27, s27, s14
            b = cB * intensity * voiceBoostFactor;
60002816:	ee27 8a87 	vmul.f32	s16, s15, s14
            g = baseG * blend * breathFactor * idleTintG * idleGlobalGain;
            b = baseB * blend * breathFactor * idleTintB * idleGlobalGain;
            }

        // Quantification + dithering (limite les paliers de bas niveau)
        const uint8_t R = quantizeWithDither(r, i, brightnessFactor);
6000281a:	eef0 0a4d 	vmov.f32	s1, s26
6000281e:	4629      	mov	r1, r5
60002820:	4620      	mov	r0, r4
60002822:	f039 f9b5 	bl	6003bb90 <___ZN9MAX98357A13AudioLedVoice18quantizeWithDitherEfif_veneer>
        const uint8_t G = quantizeWithDither(g, i + 17, brightnessFactor); // dcalage pour viter corrlations
60002826:	eef0 0a4d 	vmov.f32	s1, s26
6000282a:	eeb0 0a6d 	vmov.f32	s0, s27
6000282e:	f105 0111 	add.w	r1, r5, #17
        const uint8_t R = quantizeWithDither(r, i, brightnessFactor);
60002832:	4680      	mov	r8, r0
        const uint8_t G = quantizeWithDither(g, i + 17, brightnessFactor); // dcalage pour viter corrlations
60002834:	4620      	mov	r0, r4
60002836:	f039 f9ab 	bl	6003bb90 <___ZN9MAX98357A13AudioLedVoice18quantizeWithDitherEfif_veneer>
        const uint8_t B = quantizeWithDither(b, i + 33, brightnessFactor);
6000283a:	eef0 0a4d 	vmov.f32	s1, s26
6000283e:	eeb0 0a48 	vmov.f32	s0, s16
        const uint8_t G = quantizeWithDither(g, i + 17, brightnessFactor); // dcalage pour viter corrlations
60002842:	4607      	mov	r7, r0
        const uint8_t B = quantizeWithDither(b, i + 33, brightnessFactor);
60002844:	f105 0121 	add.w	r1, r5, #33	; 0x21
60002848:	4620      	mov	r0, r4
6000284a:	f039 f9a1 	bl	6003bb90 <___ZN9MAX98357A13AudioLedVoice18quantizeWithDitherEfif_veneer>

        const tgx::RGB24 out(R, G, B);

        if (opacity < 1.0f) {
6000284e:	eef4 aace 	vcmpe.f32	s21, s28
        const uint8_t B = quantizeWithDither(b, i + 33, brightnessFactor);
60002852:	4603      	mov	r3, r0
        if (opacity < 1.0f) {
60002854:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002858:	f140 80b6 	bpl.w	600029c8 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x374>
            blend256(fg_col, (uint32_t)(alpha * 256));
6000285c:	eddf 7a6c 	vldr	s15, [pc, #432]	; 60002a10 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3bc>
60002860:	463a      	mov	r2, r7
60002862:	4641      	mov	r1, r8
60002864:	4630      	mov	r0, r6
60002866:	ee6a 7aa7 	vmul.f32	s15, s21, s15
6000286a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
6000286e:	edcd 7a00 	vstr	s15, [sp]
60002872:	f038 fe31 	bl	6003b4d8 <___ZN3tgx5RGB248blend256ERKS0_m.isra.0_veneer>
    for (int i = 0; i < LED_COUNT; ++i) {
60002876:	3501      	adds	r5, #1
60002878:	2d19      	cmp	r5, #25
6000287a:	d15b      	bne.n	60002934 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2e0>
            leds[i].blend(out, opacity);
            } else {
            leds[i] = out;
            }
        }
    }
6000287c:	b006      	add	sp, #24
6000287e:	ecbd 8b10 	vpop	{d8-d15}
60002882:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        idleBlend = constrain(idleBlend + delta, 0.0f, 1.0f);
60002886:	eef4 7a4e 	vcmp.f32	s15, s28
6000288a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000288e:	fe7e 7a27 	vselgt.f32	s15, s28, s15
60002892:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
    if (tint_period > 0)
60002896:	b3fe      	cbz	r6, 60002918 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2c4>
    bool voiceDetected = false;
60002898:	2300      	movs	r3, #0
        baseR = 200 * idleTintR;
6000289a:	eddf 7a5e 	vldr	s15, [pc, #376]	; 60002a14 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3c0>
6000289e:	ed94 9a06 	vldr	s18, [r4, #24]
        baseG = 200 * idleTintG;
600028a2:	edd4 9a07 	vldr	s19, [r4, #28]
        baseB = 200 * idleTintB;
600028a6:	ed94 aa08 	vldr	s20, [r4, #32]
        baseR = 200 * idleTintR;
600028aa:	ee29 9a27 	vmul.f32	s18, s18, s15
        activeB = 255;
600028ae:	ed9f fa57 	vldr	s30, [pc, #348]	; 60002a0c <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3b8>
        baseG = 200 * idleTintG;
600028b2:	ee69 9aa7 	vmul.f32	s19, s19, s15
        baseB = 200 * idleTintB;
600028b6:	ee2a aa27 	vmul.f32	s20, s20, s15
        activeR = 255;
600028ba:	eef0 8a4f 	vmov.f32	s17, s30
    if (!voiceDetected && idleBlend >= 1.0f) {
600028be:	bbb3      	cbnz	r3, 6000292e <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2da>
600028c0:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
600028c4:	eef4 7ace 	vcmpe.f32	s15, s28
600028c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
600028cc:	db2f      	blt.n	6000292e <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x2da>
        float phase = fmod(idleTime, idleBreathPeriod) / idleBreathPeriod;
600028ce:	ed94 8a02 	vldr	s16, [r4, #8]
  { return __builtin_fmodf(__x, __y); }
600028d2:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
600028d6:	eef0 0a48 	vmov.f32	s1, s16
600028da:	f038 fd55 	bl	6003b388 <__fmodf_veneer>
600028de:	eec0 7a08 	vdiv.f32	s15, s0, s16
        float s = sinf(phase * 2.0f * 3.14159f) * 0.5f + 0.5f; // [0..1]
600028e2:	ed9f 0a4d 	vldr	s0, [pc, #308]	; 60002a18 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3c4>
600028e6:	ee77 7aa7 	vadd.f32	s15, s15, s15
600028ea:	ee27 0a80 	vmul.f32	s0, s15, s0
600028ee:	f038 fb67 	bl	6003afc0 <__sinf_veneer>
600028f2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
        float bf = 1.0f - idleBreathAmplitude + idleBreathAmplitude * s; // [1-A..1]
600028f6:	ed94 7a03 	vldr	s14, [r4, #12]
        breathFactor = powf(bf, idleBreathGamma);
600028fa:	edd4 0a04 	vldr	s1, [r4, #16]
        float s = sinf(phase * 2.0f * 3.14159f) * 0.5f + 0.5f; // [0..1]
600028fe:	eee0 7a27 	vfma.f32	s15, s0, s15
        float bf = 1.0f - idleBreathAmplitude + idleBreathAmplitude * s; // [1-A..1]
60002902:	ee3e 0a47 	vsub.f32	s0, s28, s14
        breathFactor = powf(bf, idleBreathGamma);
60002906:	eea7 0a27 	vfma.f32	s0, s14, s15
6000290a:	f039 f865 	bl	6003b9d8 <__powf_veneer>
6000290e:	eef0 ea40 	vmov.f32	s29, s0
60002912:	e727      	b.n	60002764 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x110>
        voiceDetected = true;
60002914:	2301      	movs	r3, #1
60002916:	e7c0      	b.n	6000289a <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x246>
    float activeR = 0, activeG = 255, activeB = 100;
60002918:	ed9f fa36 	vldr	s30, [pc, #216]	; 600029f4 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3a0>
6000291c:	eddf 8a30 	vldr	s17, [pc, #192]	; 600029e0 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x38c>
    float baseR = 65, baseG = 135, baseB = 113;
60002920:	ed9f aa35 	vldr	s20, [pc, #212]	; 600029f8 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3a4>
60002924:	eddf 9a35 	vldr	s19, [pc, #212]	; 600029fc <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3a8>
60002928:	ed9f 9a35 	vldr	s18, [pc, #212]	; 60002a00 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x3ac>
6000292c:	e7c8      	b.n	600028c0 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x26c>
    float breathFactor = 1.0f;
6000292e:	eef7 ea00 	vmov.f32	s29, #112	; 0x3f800000  1.0
60002932:	e717      	b.n	60002764 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x110>
        int sym = (i <= mid) ? i : (LED_COUNT - 1 - i);
60002934:	2d0c      	cmp	r5, #12
60002936:	f106 0603 	add.w	r6, r6, #3
6000293a:	bfcc      	ite	gt
6000293c:	f1c5 0318 	rsbgt	r3, r5, #24
60002940:	462b      	movle	r3, r5
60002942:	e71c      	b.n	6000277e <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x12a>
        float intensity = constrain(1.0f - dist / window, 0.0f, 1.0f);
60002944:	ed9f 7a26 	vldr	s14, [pc, #152]	; 600029e0 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x38c>
60002948:	e737      	b.n	600027ba <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x166>
            float blend = constrain((idleBlend - threshold) * 4.0f, 0.0f, 1.0f);
6000294a:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
6000294e:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
60002952:	ee37 7a66 	vsub.f32	s14, s14, s13
60002956:	ee27 7a27 	vmul.f32	s14, s14, s15
6000295a:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
6000295e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002962:	d42e      	bmi.n	600029c2 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x36e>
60002964:	eeb4 7a4e 	vcmp.f32	s14, s28
60002968:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
6000296c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002970:	fe37 7a87 	vselgt.f32	s14, s15, s14
            blend = blend * blend * (3 - 2 * blend);
60002974:	eea7 6a65 	vfms.f32	s12, s14, s11
            r = baseR * blend * breathFactor * idleTintR * idleGlobalGain;
60002978:	edd4 6a06 	vldr	s13, [r4, #24]
            blend = blend * blend * (3 - 2 * blend);
6000297c:	ee67 7a07 	vmul.f32	s15, s14, s14
            r = baseR * blend * breathFactor * idleTintR * idleGlobalGain;
60002980:	ed94 7a05 	vldr	s14, [r4, #20]
            blend = blend * blend * (3 - 2 * blend);
60002984:	ee67 7a86 	vmul.f32	s15, s15, s12
            r = baseR * blend * breathFactor * idleTintR * idleGlobalGain;
60002988:	ee27 0a89 	vmul.f32	s0, s15, s18
            g = baseG * blend * breathFactor * idleTintG * idleGlobalGain;
6000298c:	ee67 daa9 	vmul.f32	s27, s15, s19
            b = baseB * blend * breathFactor * idleTintB * idleGlobalGain;
60002990:	ee27 8a8a 	vmul.f32	s16, s15, s20
60002994:	edd4 7a08 	vldr	s15, [r4, #32]
            r = baseR * blend * breathFactor * idleTintR * idleGlobalGain;
60002998:	ee20 0a2e 	vmul.f32	s0, s0, s29
            g = baseG * blend * breathFactor * idleTintG * idleGlobalGain;
6000299c:	ee6d daae 	vmul.f32	s27, s27, s29
            b = baseB * blend * breathFactor * idleTintB * idleGlobalGain;
600029a0:	ee28 8a2e 	vmul.f32	s16, s16, s29
            r = baseR * blend * breathFactor * idleTintR * idleGlobalGain;
600029a4:	ee20 0a26 	vmul.f32	s0, s0, s13
            g = baseG * blend * breathFactor * idleTintG * idleGlobalGain;
600029a8:	edd4 6a07 	vldr	s13, [r4, #28]
            b = baseB * blend * breathFactor * idleTintB * idleGlobalGain;
600029ac:	ee28 8a27 	vmul.f32	s16, s16, s15
            g = baseG * blend * breathFactor * idleTintG * idleGlobalGain;
600029b0:	ee6d daa6 	vmul.f32	s27, s27, s13
            r = baseR * blend * breathFactor * idleTintR * idleGlobalGain;
600029b4:	ee20 0a07 	vmul.f32	s0, s0, s14
            b = baseB * blend * breathFactor * idleTintB * idleGlobalGain;
600029b8:	ee28 8a07 	vmul.f32	s16, s16, s14
            g = baseG * blend * breathFactor * idleTintG * idleGlobalGain;
600029bc:	ee6d da87 	vmul.f32	s27, s27, s14
            b = baseB * blend * breathFactor * idleTintB * idleGlobalGain;
600029c0:	e72b      	b.n	6000281a <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x1c6>
            float blend = constrain((idleBlend - threshold) * 4.0f, 0.0f, 1.0f);
600029c2:	ed9f 7a07 	vldr	s14, [pc, #28]	; 600029e0 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x38c>
600029c6:	e7d5      	b.n	60002974 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x320>
            leds[i] = out;
600029c8:	f886 8000 	strb.w	r8, [r6]
600029cc:	7077      	strb	r7, [r6, #1]
600029ce:	70b0      	strb	r0, [r6, #2]
600029d0:	e751      	b.n	60002876 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)+0x222>
600029d2:	bf00      	nop
600029d4:	49742400 	.word	0x49742400
600029d8:	2001a5d4 	.word	0x2001a5d4
600029dc:	43b40000 	.word	0x43b40000
600029e0:	00000000 	.word	0x00000000
600029e4:	3f733333 	.word	0x3f733333
600029e8:	49435000 	.word	0x49435000
600029ec:	3e99999a 	.word	0x3e99999a
600029f0:	3f333333 	.word	0x3f333333
600029f4:	42c80000 	.word	0x42c80000
600029f8:	42e20000 	.word	0x42e20000
600029fc:	43070000 	.word	0x43070000
60002a00:	42820000 	.word	0x42820000
60002a04:	3df5c28f 	.word	0x3df5c28f
60002a08:	3c23d70a 	.word	0x3c23d70a
60002a0c:	437f0000 	.word	0x437f0000
60002a10:	43800000 	.word	0x43800000
60002a14:	43480000 	.word	0x43480000
60002a18:	40490fd0 	.word	0x40490fd0

60002a1c <MAX98357A::AudioLed::update()>:




    SLOWFUN void AudioLed::update()
        {
60002a1c:	b5f0      	push	{r4, r5, r6, r7, lr}
        audio_block_t* block = receiveReadOnly();
60002a1e:	2100      	movs	r1, #0
        {
60002a20:	b097      	sub	sp, #92	; 0x5c
60002a22:	4606      	mov	r6, r0
        audio_block_t* block = receiveReadOnly();
60002a24:	f039 f8e0 	bl	6003bbe8 <___ZN11AudioStream15receiveReadOnlyEj_veneer>
60002a28:	4605      	mov	r5, r0

        faceAction::audioReact(block);
60002a2a:	f004 f919 	bl	60006c60 <faceAction::audioReact(audio_block_struct*)>

        int32_t peak = 0;
        if (!block)
60002a2e:	b95d      	cbnz	r5, 60002a48 <MAX98357A::AudioLed::update()+0x2c>
            {
            _minv_audio_block = 0;
60002a30:	4b37      	ldr	r3, [pc, #220]	; (60002b10 <MAX98357A::AudioLed::update()+0xf4>)
            //_maxv_audio_block = 0;
            peak = -1;
60002a32:	f04f 34ff 	mov.w	r4, #4294967295
            _minv_audio_block = 0;
60002a36:	601d      	str	r5, [r3, #0]
            _minv_audio_block = minv; // store the minimum value
            _maxv_audio_block = maxv; // store the maximum value
            release(block);
            }

        if (_drivertype == DRIVER_NONE)
60002a38:	69f3      	ldr	r3, [r6, #28]
60002a3a:	bb23      	cbnz	r3, 60002a86 <MAX98357A::AudioLed::update()+0x6a>
            {// no driver selected
            _minv_audio_block = 0;
60002a3c:	4a34      	ldr	r2, [pc, #208]	; (60002b10 <MAX98357A::AudioLed::update()+0xf4>)
60002a3e:	6013      	str	r3, [r2, #0]
            _maxv_audio_block = 0;
60002a40:	4a34      	ldr	r2, [pc, #208]	; (60002b14 <MAX98357A::AudioLed::update()+0xf8>)
60002a42:	6013      	str	r3, [r2, #0]
        for (int i = 0; i < LED_COUNT; ++i)
            {
            LedStrip::setLedAudio(i, leds[i].R, leds[i].G, leds[i].B, 0);
            }
        LedStrip::showAudio();
        }
60002a44:	b017      	add	sp, #92	; 0x5c
60002a46:	bdf0      	pop	{r4, r5, r6, r7, pc}
60002a48:	1ca8      	adds	r0, r5, #2
60002a4a:	f505 7781 	add.w	r7, r5, #258	; 0x102
            int maxv = -100000; // min and max values in the block
60002a4e:	4a32      	ldr	r2, [pc, #200]	; (60002b18 <MAX98357A::AudioLed::update()+0xfc>)
        int32_t peak = 0;
60002a50:	2400      	movs	r4, #0
            int minv = 100000; 
60002a52:	4932      	ldr	r1, [pc, #200]	; (60002b1c <MAX98357A::AudioLed::update()+0x100>)
                if (block->data[i] < minv) minv = block->data[i]; // find the minimum value
60002a54:	f930 3f02 	ldrsh.w	r3, [r0, #2]!
60002a58:	4299      	cmp	r1, r3
60002a5a:	bfa8      	it	ge
60002a5c:	4619      	movge	r1, r3
                if (block->data[i] > maxv) maxv = block->data[i]; // find the maximum value
60002a5e:	429a      	cmp	r2, r3
60002a60:	bfb8      	it	lt
60002a62:	461a      	movlt	r2, r3
                int32_t s = abs(block->data[i]);
60002a64:	2b00      	cmp	r3, #0
60002a66:	bfb8      	it	lt
60002a68:	425b      	neglt	r3, r3
60002a6a:	b29b      	uxth	r3, r3
60002a6c:	429c      	cmp	r4, r3
60002a6e:	bfb8      	it	lt
60002a70:	461c      	movlt	r4, r3
            for (int i = 0; i < AUDIO_BLOCK_SAMPLES; ++i)
60002a72:	4287      	cmp	r7, r0
60002a74:	d1ee      	bne.n	60002a54 <MAX98357A::AudioLed::update()+0x38>
            _minv_audio_block = minv; // store the minimum value
60002a76:	4b26      	ldr	r3, [pc, #152]	; (60002b10 <MAX98357A::AudioLed::update()+0xf4>)
            release(block);
60002a78:	4628      	mov	r0, r5
            _minv_audio_block = minv; // store the minimum value
60002a7a:	6019      	str	r1, [r3, #0]
            _maxv_audio_block = maxv; // store the maximum value
60002a7c:	4b25      	ldr	r3, [pc, #148]	; (60002b14 <MAX98357A::AudioLed::update()+0xf8>)
60002a7e:	601a      	str	r2, [r3, #0]
            release(block);
60002a80:	f038 fff6 	bl	6003ba70 <___ZN11AudioStream7releaseEP18audio_block_struct_veneer>
60002a84:	e7d8      	b.n	60002a38 <MAX98357A::AudioLed::update()+0x1c>
        memset(leds, 0, sizeof(leds)); // clear the led colors
60002a86:	224b      	movs	r2, #75	; 0x4b
60002a88:	2100      	movs	r1, #0
60002a8a:	a803      	add	r0, sp, #12
60002a8c:	f038 fb54 	bl	6003b138 <__memset_veneer>
        if (_drivertype == DRIVER_VOICE)
60002a90:	69f3      	ldr	r3, [r6, #28]
60002a92:	2b01      	cmp	r3, #1
60002a94:	d125      	bne.n	60002ae2 <MAX98357A::AudioLed::update()+0xc6>
            if (peak >= 0) peak = (int32_t)(peak * AUDIOLED_VOICE_BRIGHTNESS);
60002a96:	1c62      	adds	r2, r4, #1
60002a98:	d00b      	beq.n	60002ab2 <MAX98357A::AudioLed::update()+0x96>
60002a9a:	ee07 4a90 	vmov	s15, r4
60002a9e:	ed9f 7a20 	vldr	s14, [pc, #128]	; 60002b20 <MAX98357A::AudioLed::update()+0x104>
60002aa2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
60002aa6:	ee67 7a87 	vmul.f32	s15, s15, s14
60002aaa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
60002aae:	ee17 4a90 	vmov	r4, s15
            audioLedVoice.create(peak, leds, opacity);
60002ab2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
60002ab6:	aa03      	add	r2, sp, #12
60002ab8:	4621      	mov	r1, r4
60002aba:	481a      	ldr	r0, [pc, #104]	; (60002b24 <MAX98357A::AudioLed::update()+0x108>)
60002abc:	f7ff fdca 	bl	60002654 <MAX98357A::AudioLedVoice::create(long, tgx::RGB24*, float)>
            peak = -1;
60002ac0:	2500      	movs	r5, #0
60002ac2:	ac03      	add	r4, sp, #12
            LedStrip::setLedAudio(i, leds[i].R, leds[i].G, leds[i].B, 0);
60002ac4:	462e      	mov	r6, r5
60002ac6:	4628      	mov	r0, r5
        for (int i = 0; i < LED_COUNT; ++i)
60002ac8:	3501      	adds	r5, #1
            LedStrip::setLedAudio(i, leds[i].R, leds[i].G, leds[i].B, 0);
60002aca:	78a3      	ldrb	r3, [r4, #2]
60002acc:	7862      	ldrb	r2, [r4, #1]
60002ace:	9600      	str	r6, [sp, #0]
60002ad0:	f814 1b03 	ldrb.w	r1, [r4], #3
60002ad4:	f007 f89a 	bl	60009c0c <LedStrip::setLedAudio(int, unsigned char, unsigned char, unsigned char, unsigned char)>
        for (int i = 0; i < LED_COUNT; ++i)
60002ad8:	2d19      	cmp	r5, #25
60002ada:	d1f4      	bne.n	60002ac6 <MAX98357A::AudioLed::update()+0xaa>
        LedStrip::showAudio();
60002adc:	f007 f8b0 	bl	60009c40 <LedStrip::showAudio()>
60002ae0:	e7b0      	b.n	60002a44 <MAX98357A::AudioLed::update()+0x28>
            if (peak >= 0) peak = (int32_t)(peak * AUDIOLED_MUSIC_BRIGHTNESS);
60002ae2:	1c63      	adds	r3, r4, #1
60002ae4:	d00b      	beq.n	60002afe <MAX98357A::AudioLed::update()+0xe2>
60002ae6:	ee07 4a90 	vmov	s15, r4
60002aea:	ed9f 7a0f 	vldr	s14, [pc, #60]	; 60002b28 <MAX98357A::AudioLed::update()+0x10c>
60002aee:	eef8 7ae7 	vcvt.f32.s32	s15, s15
60002af2:	ee67 7a87 	vmul.f32	s15, s15, s14
60002af6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
60002afa:	ee17 4a90 	vmov	r4, s15
            audioLedMusic.create(peak, leds, opacity);
60002afe:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
60002b02:	aa03      	add	r2, sp, #12
60002b04:	4621      	mov	r1, r4
60002b06:	4809      	ldr	r0, [pc, #36]	; (60002b2c <MAX98357A::AudioLed::update()+0x110>)
60002b08:	f7ff fc8a 	bl	60002420 <MAX98357A::AudioLedMusic::create(long, tgx::RGB24*, float)>
60002b0c:	e7d8      	b.n	60002ac0 <MAX98357A::AudioLed::update()+0xa4>
60002b0e:	bf00      	nop
60002b10:	2001985c 	.word	0x2001985c
60002b14:	20019858 	.word	0x20019858
60002b18:	fffe7960 	.word	0xfffe7960
60002b1c:	000186a0 	.word	0x000186a0
60002b20:	3f333333 	.word	0x3f333333
60002b24:	20019818 	.word	0x20019818
60002b28:	3f4ccccd 	.word	0x3f4ccccd
60002b2c:	20019794 	.word	0x20019794

60002b30 <MAX98357A::AudioLed::setDriver(int)>:
        noInterrupts();
60002b30:	b672      	cpsid	i
        _drivertype = driver;
60002b32:	61c1      	str	r1, [r0, #28]
        interrupts();
60002b34:	b662      	cpsie	i
        }
60002b36:	4770      	bx	lr

60002b38 <MAX98357A::AudioLed::setVoiceLedTint(float, float, float)>:
        idleTintR = R;
60002b38:	4b04      	ldr	r3, [pc, #16]	; (60002b4c <MAX98357A::AudioLed::setVoiceLedTint(float, float, float)+0x14>)
        tint_period = 0;
60002b3a:	2200      	movs	r2, #0
        idleTintR = R;
60002b3c:	ed83 0a06 	vstr	s0, [r3, #24]
        idleTintG = G;
60002b40:	edc3 0a07 	vstr	s1, [r3, #28]
        idleTintB = B;
60002b44:	ed83 1a08 	vstr	s2, [r3, #32]
        tint_period = 0;
60002b48:	625a      	str	r2, [r3, #36]	; 0x24
        }
60002b4a:	4770      	bx	lr
60002b4c:	20019818 	.word	0x20019818

60002b50 <MAX98357A::AudioLed::setVoiceLedTintAuto(unsigned long)>:
        tint_period = period;
60002b50:	4b01      	ldr	r3, [pc, #4]	; (60002b58 <MAX98357A::AudioLed::setVoiceLedTintAuto(unsigned long)+0x8>)
60002b52:	6259      	str	r1, [r3, #36]	; 0x24
        }
60002b54:	4770      	bx	lr
60002b56:	bf00      	nop
60002b58:	20019818 	.word	0x20019818

60002b5c <MAX98357A::AudioLed::getCurrentTint()>:
        return tgx::RGBf(idleTintR, idleTintG, idleTintB);
60002b5c:	4b04      	ldr	r3, [pc, #16]	; (60002b70 <MAX98357A::AudioLed::getCurrentTint()+0x14>)
        {
60002b5e:	b088      	sub	sp, #32
        }
60002b60:	ed93 0a06 	vldr	s0, [r3, #24]
60002b64:	edd3 0a07 	vldr	s1, [r3, #28]
60002b68:	ed93 1a08 	vldr	s2, [r3, #32]
60002b6c:	b008      	add	sp, #32
60002b6e:	4770      	bx	lr
60002b70:	20019818 	.word	0x20019818

60002b74 <MAX98357A::disable()>:
        }


    SLOWFUN void disable()
        {
        digitalWrite(PIN_MAX98357A_PWR_CTRL, LOW); // turn on the power        
60002b74:	2100      	movs	r1, #0
60002b76:	2006      	movs	r0, #6
60002b78:	f038 bd72 	b.w	6003b660 <__digitalWrite_veneer>

60002b7c <MAX98357A::setAudioLevelVoice(float)>:
        fade1.fadeOut(ms);
        }

    SLOWFUN void setAudioLevelVoice(float level)
        {
        if (level < 0.0f) level = 0.0f;
60002b7c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
60002b80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002b84:	d421      	bmi.n	60002bca <MAX98357A::setAudioLevelVoice(float)+0x4e>
        if (level > 3.0f) level = 3.0f;
60002b86:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
60002b8a:	eeb4 0a67 	vcmp.f32	s0, s15
60002b8e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002b92:	fe37 0a80 	vselgt.f32	s0, s15, s0
        mixer.gain(2, DEFAULT_SOUND_LEVEL_VOICE * level); // set the gain for the espeak channel
60002b96:	eddf 7a10 	vldr	s15, [pc, #64]	; 60002bd8 <MAX98357A::setAudioLevelVoice(float)+0x5c>
60002b9a:	ee20 0a27 	vmul.f32	s0, s0, s15
		for (int i=0; i<4; i++) multiplier[i] = 65536;
	}
	virtual void update(void);
	void gain(unsigned int channel, float gain) {
		if (channel >= 4) return;
		if (gain > 32767.0f) gain = 32767.0f;
60002b9e:	eddf 7a0f 	vldr	s15, [pc, #60]	; 60002bdc <MAX98357A::setAudioLevelVoice(float)+0x60>
60002ba2:	eeb4 0ae7 	vcmpe.f32	s0, s15
60002ba6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002baa:	dc11      	bgt.n	60002bd0 <MAX98357A::setAudioLevelVoice(float)+0x54>
		else if (gain < -32767.0f) gain = -32767.0f;
60002bac:	eddf 7a0c 	vldr	s15, [pc, #48]	; 60002be0 <MAX98357A::setAudioLevelVoice(float)+0x64>
60002bb0:	eeb4 0a67 	vcmp.f32	s0, s15
60002bb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002bb8:	bf48      	it	mi
60002bba:	eeb0 0a67 	vmovmi.f32	s0, s15
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002bbe:	eebe 0ac8 	vcvt.s32.f32	s0, s0, #16
60002bc2:	4b08      	ldr	r3, [pc, #32]	; (60002be4 <MAX98357A::setAudioLevelVoice(float)+0x68>)
60002bc4:	ed83 0a08 	vstr	s0, [r3, #32]
        }
60002bc8:	4770      	bx	lr
        if (level < 0.0f) level = 0.0f;
60002bca:	ed9f 0a07 	vldr	s0, [pc, #28]	; 60002be8 <MAX98357A::setAudioLevelVoice(float)+0x6c>
60002bce:	e7e2      	b.n	60002b96 <MAX98357A::setAudioLevelVoice(float)+0x1a>
		if (gain > 32767.0f) gain = 32767.0f;
60002bd0:	eeb0 0a67 	vmov.f32	s0, s15
60002bd4:	e7f3      	b.n	60002bbe <MAX98357A::setAudioLevelVoice(float)+0x42>
60002bd6:	bf00      	nop
60002bd8:	3f333333 	.word	0x3f333333
60002bdc:	46fffe00 	.word	0x46fffe00
60002be0:	c6fffe00 	.word	0xc6fffe00
60002be4:	200198d0 	.word	0x200198d0
60002be8:	00000000 	.word	0x00000000

60002bec <MAX98357A::stopMusic()>:
        }


    void stopMusic()
        {
        playWav.stop();
60002bec:	4801      	ldr	r0, [pc, #4]	; (60002bf4 <MAX98357A::stopMusic()+0x8>)
60002bee:	f038 bd7b 	b.w	6003b6e8 <___ZN14AudioPlaySdWav4stopEv_veneer>
60002bf2:	bf00      	nop
60002bf4:	20019908 	.word	0x20019908

60002bf8 <MAX98357A::musicLenghtMs()>:
        return playWav.lengthMillis();
60002bf8:	4801      	ldr	r0, [pc, #4]	; (60002c00 <MAX98357A::musicLenghtMs()+0x8>)
60002bfa:	f038 bfe9 	b.w	6003bbd0 <___ZN14AudioPlaySdWav12lengthMillisEv_veneer>
60002bfe:	bf00      	nop
60002c00:	20019908 	.word	0x20019908

60002c04 <MAX98357A::musicPositionMs()>:
        return playWav.positionMillis();
60002c04:	4801      	ldr	r0, [pc, #4]	; (60002c0c <MAX98357A::musicPositionMs()+0x8>)
60002c06:	f039 b80f 	b.w	6003bc28 <___ZN14AudioPlaySdWav14positionMillisEv_veneer>
60002c0a:	bf00      	nop
60002c0c:	20019908 	.word	0x20019908

60002c10 <MAX98357A::stopSpeak()>:
        }



    SLOWFUN void stopSpeak()
        {
60002c10:	b510      	push	{r4, lr}
        if (_is_speaking)
60002c12:	4c0a      	ldr	r4, [pc, #40]	; (60002c3c <MAX98357A::stopSpeak()+0x2c>)
60002c14:	6823      	ldr	r3, [r4, #0]
60002c16:	b933      	cbnz	r3, 60002c26 <MAX98357A::stopSpeak()+0x16>
                espeak.sendAbortSignal(); // send the abort signal to espeak
                threads.yield();
                }
            threads.wait(_th_speak, 1); // wait for the speak thread to finish
            }        
        }
60002c18:	bd10      	pop	{r4, pc}
                espeak.sendAbortSignal(); // send the abort signal to espeak
60002c1a:	f038 fd4d 	bl	6003b6b8 <___ZN8EspeakNG11getInstanceEv_veneer>
60002c1e:	f00f f915 	bl	60011e4c <EspeakNG::sendAbortSignal()>
                threads.yield();
60002c22:	f038 f9b9 	bl	6003af98 <___ZN7Threads5yieldEv_veneer>
            while (_is_speaking) 
60002c26:	6823      	ldr	r3, [r4, #0]
60002c28:	2b00      	cmp	r3, #0
60002c2a:	d1f6      	bne.n	60002c1a <MAX98357A::stopSpeak()+0xa>
            threads.wait(_th_speak, 1); // wait for the speak thread to finish
60002c2c:	4b04      	ldr	r3, [pc, #16]	; (60002c40 <MAX98357A::stopSpeak()+0x30>)
60002c2e:	2201      	movs	r2, #1
60002c30:	4804      	ldr	r0, [pc, #16]	; (60002c44 <MAX98357A::stopSpeak()+0x34>)
60002c32:	6819      	ldr	r1, [r3, #0]
        }
60002c34:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            threads.wait(_th_speak, 1); // wait for the speak thread to finish
60002c38:	f038 be5a 	b.w	6003b8f0 <___ZN7Threads4waitEij_veneer>
60002c3c:	20019790 	.word	0x20019790
60002c40:	20019b7c 	.word	0x20019b7c
60002c44:	2001a5e4 	.word	0x2001a5e4

60002c48 <MAX98357A::waitEndSpeak()>:
        return (_is_speaking != 0);
        }


    SLOWFUN void waitEndSpeak()
        {
60002c48:	b538      	push	{r3, r4, r5, lr}
        while (_is_speaking)
60002c4a:	4c07      	ldr	r4, [pc, #28]	; (60002c68 <MAX98357A::waitEndSpeak()+0x20>)
            {
            if (getPanicFlag()) { return; }
            threads.delay(1); 
60002c4c:	4d07      	ldr	r5, [pc, #28]	; (60002c6c <MAX98357A::waitEndSpeak()+0x24>)
        while (_is_speaking)
60002c4e:	6823      	ldr	r3, [r4, #0]
60002c50:	b903      	cbnz	r3, 60002c54 <MAX98357A::waitEndSpeak()+0xc>
            }
        }
60002c52:	bd38      	pop	{r3, r4, r5, pc}
            if (getPanicFlag()) { return; }
60002c54:	f039 f884 	bl	6003bd60 <___Z12getPanicFlagv_veneer>
60002c58:	2800      	cmp	r0, #0
60002c5a:	d1fa      	bne.n	60002c52 <MAX98357A::waitEndSpeak()+0xa>
            threads.delay(1); 
60002c5c:	2101      	movs	r1, #1
60002c5e:	4628      	mov	r0, r5
60002c60:	f038 f98a 	bl	6003af78 <___ZN7Threads5delayEi_veneer>
60002c64:	e7f3      	b.n	60002c4e <MAX98357A::waitEndSpeak()+0x6>
60002c66:	bf00      	nop
60002c68:	20019790 	.word	0x20019790
60002c6c:	2001a5e4 	.word	0x2001a5e4

60002c70 <MAX98357A::fadeInMusic(int)>:
        {
60002c70:	b507      	push	{r0, r1, r2, lr}
60002c72:	4601      	mov	r1, r0
        fade0.fadeIn(ms);
60002c74:	9001      	str	r0, [sp, #4]
60002c76:	4805      	ldr	r0, [pc, #20]	; (60002c8c <MAX98357A::fadeInMusic(int)+0x1c>)
60002c78:	f038 f99e 	bl	6003afb8 <___ZN15AudioEffectFade6fadeInEm_veneer>
        fade1.fadeIn(ms);
60002c7c:	9901      	ldr	r1, [sp, #4]
60002c7e:	4804      	ldr	r0, [pc, #16]	; (60002c90 <MAX98357A::fadeInMusic(int)+0x20>)
60002c80:	f038 f99a 	bl	6003afb8 <___ZN15AudioEffectFade6fadeInEm_veneer>
        }
60002c84:	b003      	add	sp, #12
60002c86:	f85d fb04 	ldr.w	pc, [sp], #4
60002c8a:	bf00      	nop
60002c8c:	20019880 	.word	0x20019880
60002c90:	200198a8 	.word	0x200198a8

60002c94 <MAX98357A::setAudioLevelMusic(float)>:
        {
60002c94:	b508      	push	{r3, lr}
60002c96:	ed2d 8b02 	vpush	{d8}
60002c9a:	eeb0 8a40 	vmov.f32	s16, s0
        fadeInMusic();
60002c9e:	2064      	movs	r0, #100	; 0x64
60002ca0:	f7ff ffe6 	bl	60002c70 <MAX98357A::fadeInMusic(int)>
        if (level < 0.0f) level = 0.0f;
60002ca4:	ed9f 7a21 	vldr	s14, [pc, #132]	; 60002d2c <MAX98357A::setAudioLevelMusic(float)+0x98>
60002ca8:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
60002cac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002cb0:	d42e      	bmi.n	60002d10 <MAX98357A::setAudioLevelMusic(float)+0x7c>
        if (level > 3.0f) level = 3.0f;
60002cb2:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
60002cb6:	eeb4 8ae7 	vcmpe.f32	s16, s15
60002cba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002cbe:	dc2c      	bgt.n	60002d1a <MAX98357A::setAudioLevelMusic(float)+0x86>
60002cc0:	eeb4 8ac7 	vcmpe.f32	s16, s14
60002cc4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002cc8:	dc2a      	bgt.n	60002d20 <MAX98357A::setAudioLevelMusic(float)+0x8c>
		else if (gain < -32767.0f) gain = -32767.0f;
60002cca:	eddf 7a19 	vldr	s15, [pc, #100]	; 60002d30 <MAX98357A::setAudioLevelMusic(float)+0x9c>
60002cce:	eeb4 8ae7 	vcmpe.f32	s16, s15
60002cd2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002cd6:	bf58      	it	pl
60002cd8:	eef0 7a48 	vmovpl.f32	s15, s16
		if (gain > 32767.0f) gain = 32767.0f;
60002cdc:	eeb4 8ac7 	vcmpe.f32	s16, s14
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002ce0:	4b14      	ldr	r3, [pc, #80]	; (60002d34 <MAX98357A::setAudioLevelMusic(float)+0xa0>)
60002ce2:	eefe 7ac8 	vcvt.s32.f32	s15, s15, #16
		if (gain > 32767.0f) gain = 32767.0f;
60002ce6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002cea:	edc3 7a06 	vstr	s15, [r3, #24]
		if (gain > 32767.0f) gain = 32767.0f;
60002cee:	dc1a      	bgt.n	60002d26 <MAX98357A::setAudioLevelMusic(float)+0x92>
		else if (gain < -32767.0f) gain = -32767.0f;
60002cf0:	eddf 7a0f 	vldr	s15, [pc, #60]	; 60002d30 <MAX98357A::setAudioLevelMusic(float)+0x9c>
60002cf4:	eeb4 8a67 	vcmp.f32	s16, s15
60002cf8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60002cfc:	bf48      	it	mi
60002cfe:	eeb0 8a67 	vmovmi.f32	s16, s15
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002d02:	eebe 8ac8 	vcvt.s32.f32	s16, s16, #16
60002d06:	ed83 8a07 	vstr	s16, [r3, #28]
        }
60002d0a:	ecbd 8b02 	vpop	{d8}
60002d0e:	bd08      	pop	{r3, pc}
        if (level < 0.0f) level = 0.0f;
60002d10:	ed9f 8a09 	vldr	s16, [pc, #36]	; 60002d38 <MAX98357A::setAudioLevelMusic(float)+0xa4>
        if (level > 3.0f) level = 3.0f;
60002d14:	eef0 7a48 	vmov.f32	s15, s16
60002d18:	e7e0      	b.n	60002cdc <MAX98357A::setAudioLevelMusic(float)+0x48>
60002d1a:	eeb0 8a67 	vmov.f32	s16, s15
60002d1e:	e7f9      	b.n	60002d14 <MAX98357A::setAudioLevelMusic(float)+0x80>
		if (gain > 32767.0f) gain = 32767.0f;
60002d20:	eef0 7a47 	vmov.f32	s15, s14
60002d24:	e7da      	b.n	60002cdc <MAX98357A::setAudioLevelMusic(float)+0x48>
60002d26:	ed9f 8a01 	vldr	s16, [pc, #4]	; 60002d2c <MAX98357A::setAudioLevelMusic(float)+0x98>
60002d2a:	e7ea      	b.n	60002d02 <MAX98357A::setAudioLevelMusic(float)+0x6e>
60002d2c:	46fffe00 	.word	0x46fffe00
60002d30:	c6fffe00 	.word	0xc6fffe00
60002d34:	200198d0 	.word	0x200198d0
60002d38:	00000000 	.word	0x00000000

60002d3c <MAX98357A::setAudioLevel(float)>:
        {
60002d3c:	b508      	push	{r3, lr}
60002d3e:	ed2d 8b02 	vpush	{d8}
60002d42:	eeb0 8a40 	vmov.f32	s16, s0
        setAudioLevelMusic(level);
60002d46:	f7ff ffa5 	bl	60002c94 <MAX98357A::setAudioLevelMusic(float)>
        setAudioLevelVoice(level);
60002d4a:	eeb0 0a48 	vmov.f32	s0, s16
        }
60002d4e:	ecbd 8b02 	vpop	{d8}
60002d52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        setAudioLevelVoice(level);
60002d56:	f7ff bf11 	b.w	60002b7c <MAX98357A::setAudioLevelVoice(float)>

60002d5a <MAX98357A::fadeOutMusic(int)>:
        {
60002d5a:	b507      	push	{r0, r1, r2, lr}
60002d5c:	4601      	mov	r1, r0
        fade0.fadeOut(ms);
60002d5e:	9001      	str	r0, [sp, #4]
60002d60:	4804      	ldr	r0, [pc, #16]	; (60002d74 <MAX98357A::fadeOutMusic(int)+0x1a>)
60002d62:	f038 fcc5 	bl	6003b6f0 <___ZN15AudioEffectFade7fadeOutEm_veneer>
        fade1.fadeOut(ms);
60002d66:	9901      	ldr	r1, [sp, #4]
60002d68:	4803      	ldr	r0, [pc, #12]	; (60002d78 <MAX98357A::fadeOutMusic(int)+0x1e>)
60002d6a:	f038 fcc1 	bl	6003b6f0 <___ZN15AudioEffectFade7fadeOutEm_veneer>
        }
60002d6e:	b003      	add	sp, #12
60002d70:	f85d fb04 	ldr.w	pc, [sp], #4
60002d74:	20019880 	.word	0x20019880
60002d78:	200198a8 	.word	0x200198a8

60002d7c <MAX98357A::waitEndPlayMusic()>:
        {
60002d7c:	b510      	push	{r4, lr}
            threads.delay(1);
60002d7e:	4c07      	ldr	r4, [pc, #28]	; (60002d9c <MAX98357A::waitEndPlayMusic()+0x20>)
        threads.delay(25);
60002d80:	2119      	movs	r1, #25
60002d82:	4806      	ldr	r0, [pc, #24]	; (60002d9c <MAX98357A::waitEndPlayMusic()+0x20>)
60002d84:	f038 f8f8 	bl	6003af78 <___ZN7Threads5delayEi_veneer>
        while (isPlayingMusic())
60002d88:	f038 f93a 	bl	6003b000 <___ZN9MAX98357A14isPlayingMusicEv_veneer>
60002d8c:	b900      	cbnz	r0, 60002d90 <MAX98357A::waitEndPlayMusic()+0x14>
        }
60002d8e:	bd10      	pop	{r4, pc}
            threads.delay(1);
60002d90:	2101      	movs	r1, #1
60002d92:	4620      	mov	r0, r4
60002d94:	f038 f8f0 	bl	6003af78 <___ZN7Threads5delayEi_veneer>
60002d98:	e7f6      	b.n	60002d88 <MAX98357A::waitEndPlayMusic()+0xc>
60002d9a:	bf00      	nop
60002d9c:	2001a5e4 	.word	0x2001a5e4

60002da0 <MAX98357A::playMusic(char const*, bool)>:
        {
60002da0:	b510      	push	{r4, lr}
60002da2:	460c      	mov	r4, r1
        playWav.play(filename);
60002da4:	4601      	mov	r1, r0
60002da6:	4804      	ldr	r0, [pc, #16]	; (60002db8 <MAX98357A::playMusic(char const*, bool)+0x18>)
60002da8:	f038 fa32 	bl	6003b210 <___ZN14AudioPlaySdWav4playEPKc_veneer>
        if (wait)
60002dac:	b11c      	cbz	r4, 60002db6 <MAX98357A::playMusic(char const*, bool)+0x16>
        }
60002dae:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            waitEndPlayMusic();
60002db2:	f7ff bfe3 	b.w	60002d7c <MAX98357A::waitEndPlayMusic()>
        }
60002db6:	bd10      	pop	{r4, pc}
60002db8:	20019908 	.word	0x20019908

60002dbc <MAX98357A::init()>:
        {
60002dbc:	b537      	push	{r0, r1, r2, r4, r5, lr}
        AudioMemory(AUDIO_MEMORY_BLOCKS); // <- this is a macro that performs static allocation in DMAMEM for a given number of blocks
60002dbe:	210c      	movs	r1, #12
60002dc0:	4857      	ldr	r0, [pc, #348]	; (60002f20 <MAX98357A::init()+0x164>)
60002dc2:	f037 fa3b 	bl	6003a23c <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>
        if (_init_done) return;
60002dc6:	4b57      	ldr	r3, [pc, #348]	; (60002f24 <MAX98357A::init()+0x168>)
60002dc8:	f993 2000 	ldrsb.w	r2, [r3]
60002dcc:	2a00      	cmp	r2, #0
60002dce:	f040 80a5 	bne.w	60002f1c <MAX98357A::init()+0x160>
        _init_done = 1;
60002dd2:	2201      	movs	r2, #1
        DEBUG("MAX98357A::init() started")
60002dd4:	4954      	ldr	r1, [pc, #336]	; (60002f28 <MAX98357A::init()+0x16c>)
60002dd6:	4855      	ldr	r0, [pc, #340]	; (60002f2c <MAX98357A::init()+0x170>)
        _init_done = 1;
60002dd8:	701a      	strb	r2, [r3, #0]
        DEBUG("MAX98357A::init() started")
60002dda:	f038 ff21 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002dde:	4954      	ldr	r1, [pc, #336]	; (60002f30 <MAX98357A::init()+0x174>)
60002de0:	f038 fba6 	bl	6003b530 <___ZN5debug4CoutI17usb_serial2_classElsIA57_cEERS2_RKT__veneer>
60002de4:	4953      	ldr	r1, [pc, #332]	; (60002f34 <MAX98357A::init()+0x178>)
60002de6:	f038 ff1b 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002dea:	234a      	movs	r3, #74	; 0x4a
60002dec:	a901      	add	r1, sp, #4
60002dee:	9301      	str	r3, [sp, #4]
60002df0:	f038 fb5a 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60002df4:	4950      	ldr	r1, [pc, #320]	; (60002f38 <MAX98357A::init()+0x17c>)
60002df6:	f038 fbc3 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60002dfa:	4604      	mov	r4, r0
        {
            Cout() : _serial(nullptr) {}

            template<typename T>  SLOWFUN Cout& operator<<(const T& v)
                {
                if (_serial) _serial->print(v);
60002dfc:	6800      	ldr	r0, [r0, #0]
60002dfe:	b110      	cbz	r0, 60002e06 <MAX98357A::init()+0x4a>
60002e00:	494e      	ldr	r1, [pc, #312]	; (60002f3c <MAX98357A::init()+0x180>)
60002e02:	f038 ffb5 	bl	6003bd70 <___ZN5Print5printEPKc.isra.0_veneer>
60002e06:	4620      	mov	r0, r4
60002e08:	4c48      	ldr	r4, [pc, #288]	; (60002f2c <MAX98357A::init()+0x170>)
60002e0a:	494d      	ldr	r1, [pc, #308]	; (60002f40 <MAX98357A::init()+0x184>)
60002e0c:	f038 f8e8 	bl	6003afe0 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60002e10:	6820      	ldr	r0, [r4, #0]
60002e12:	f038 fda5 	bl	6003b960 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
        pinMode(PIN_MAX98357A_PWR_CTRL, OUTPUT);
60002e16:	2101      	movs	r1, #1
60002e18:	2006      	movs	r0, #6
60002e1a:	f038 fc25 	bl	6003b668 <__pinMode_veneer>
        digitalWrite(PIN_MAX98357A_PWR_CTRL, HIGH); // turn on the power        
60002e1e:	2101      	movs	r1, #1
60002e20:	2006      	movs	r0, #6
60002e22:	f038 fc1d 	bl	6003b660 <__digitalWrite_veneer>
        if (!(SD.begin(BUILTIN_SDCARD)))
60002e26:	21fe      	movs	r1, #254	; 0xfe
60002e28:	4846      	ldr	r0, [pc, #280]	; (60002f44 <MAX98357A::init()+0x188>)
60002e2a:	f038 f961 	bl	6003b0f0 <___ZN7SDClass5beginEh_veneer>
60002e2e:	bb48      	cbnz	r0, 60002e84 <MAX98357A::init()+0xc8>
            ABORT("SD card initialization failed!");
60002e30:	f038 fe2e 	bl	6003ba90 <___Z8is_panicv_veneer>
60002e34:	bb30      	cbnz	r0, 60002e84 <MAX98357A::init()+0xc8>
60002e36:	493c      	ldr	r1, [pc, #240]	; (60002f28 <MAX98357A::init()+0x16c>)
60002e38:	4620      	mov	r0, r4
60002e3a:	f038 fef1 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002e3e:	493c      	ldr	r1, [pc, #240]	; (60002f30 <MAX98357A::init()+0x174>)
60002e40:	f038 fb76 	bl	6003b530 <___ZN5debug4CoutI17usb_serial2_classElsIA57_cEERS2_RKT__veneer>
60002e44:	493b      	ldr	r1, [pc, #236]	; (60002f34 <MAX98357A::init()+0x178>)
60002e46:	f038 feeb 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002e4a:	2352      	movs	r3, #82	; 0x52
60002e4c:	a901      	add	r1, sp, #4
60002e4e:	9301      	str	r3, [sp, #4]
60002e50:	f038 fb2a 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60002e54:	4938      	ldr	r1, [pc, #224]	; (60002f38 <MAX98357A::init()+0x17c>)
60002e56:	f038 fb93 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60002e5a:	4605      	mov	r5, r0
60002e5c:	6800      	ldr	r0, [r0, #0]
60002e5e:	b110      	cbz	r0, 60002e66 <MAX98357A::init()+0xaa>
60002e60:	4939      	ldr	r1, [pc, #228]	; (60002f48 <MAX98357A::init()+0x18c>)
60002e62:	f038 ff85 	bl	6003bd70 <___ZN5Print5printEPKc.isra.0_veneer>
60002e66:	4936      	ldr	r1, [pc, #216]	; (60002f40 <MAX98357A::init()+0x184>)
60002e68:	4628      	mov	r0, r5
60002e6a:	f038 f8b9 	bl	6003afe0 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60002e6e:	6820      	ldr	r0, [r4, #0]
60002e70:	f038 fd76 	bl	6003b960 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
                print(v); 
60002e74:	4934      	ldr	r1, [pc, #208]	; (60002f48 <MAX98357A::init()+0x18c>)
60002e76:	4835      	ldr	r0, [pc, #212]	; (60002f4c <MAX98357A::init()+0x190>)
60002e78:	f038 ff7a 	bl	6003bd70 <___ZN5Print5printEPKc.isra.0_veneer>
60002e7c:	f038 fcbc 	bl	6003b7f8 <___Z9set_panicv_veneer>
60002e80:	f007 febe 	bl	6000ac00 <hang()>
        playWav.begin();        
60002e84:	4832      	ldr	r0, [pc, #200]	; (60002f50 <MAX98357A::init()+0x194>)
60002e86:	f038 ff3b 	bl	6003bd00 <___ZN14AudioPlaySdWav5beginEv_veneer>
        espeak.begin(1); // memory in extmem
60002e8a:	f038 fc15 	bl	6003b6b8 <___ZN8EspeakNG11getInstanceEv_veneer>
60002e8e:	2101      	movs	r1, #1
60002e90:	f00e fc74 	bl	6001177c <EspeakNG::begin(int)>
        espeak.setDelayFunction(espeakDelay); // set the delay function for espeak using teensythread
60002e94:	f038 fc10 	bl	6003b6b8 <___ZN8EspeakNG11getInstanceEv_veneer>
        * 
        * Call this method without paramter to restore the default Arduino's delay().
        **/
        void setDelayFunction(p_delay_cb delay_function = nullptr)
            {
            _delay_fun = (!delay_function) ? _default_delay : delay_function;
60002e98:	4b2e      	ldr	r3, [pc, #184]	; (60002f54 <MAX98357A::init()+0x198>)
60002e9a:	6503      	str	r3, [r0, #80]	; 0x50
        espeak.registerVariant("sarcasm_voice", espeak_ng_data_sarcasm_voice, espeak_ng_data_sarcasm_voice_len);
60002e9c:	f038 fc0c 	bl	6003b6b8 <___ZN8EspeakNG11getInstanceEv_veneer>
60002ea0:	f44f 73c1 	mov.w	r3, #386	; 0x182
60002ea4:	4a2c      	ldr	r2, [pc, #176]	; (60002f58 <MAX98357A::init()+0x19c>)
60002ea6:	492d      	ldr	r1, [pc, #180]	; (60002f5c <MAX98357A::init()+0x1a0>)
60002ea8:	f00e fc99 	bl	600117de <EspeakNG::registerVariant(char const*, unsigned char const*, int)>
        espeak.setRate(120);
60002eac:	f038 fc04 	bl	6003b6b8 <___ZN8EspeakNG11getInstanceEv_veneer>
60002eb0:	2178      	movs	r1, #120	; 0x78
60002eb2:	f00e ff1f 	bl	60011cf4 <EspeakNG::setRate(int)>
        espeak.setVoice("en+sarcasm_voice"); // set the voice to use
60002eb6:	f038 fbff 	bl	6003b6b8 <___ZN8EspeakNG11getInstanceEv_veneer>
60002eba:	4929      	ldr	r1, [pc, #164]	; (60002f60 <MAX98357A::init()+0x1a4>)
60002ebc:	f00e fc96 	bl	600117ec <EspeakNG::setVoice(char const*)>
		multiplier[channel] = gain * 65536.0f; // TODO: proper roundoff?
60002ec0:	f44f 3280 	mov.w	r2, #65536	; 0x10000
60002ec4:	4b27      	ldr	r3, [pc, #156]	; (60002f64 <MAX98357A::init()+0x1a8>)
60002ec6:	f24b 3033 	movw	r0, #45875	; 0xb333
60002eca:	2100      	movs	r1, #0
60002ecc:	e9c3 2206 	strd	r2, r2, [r3, #24]
60002ed0:	e9c3 0108 	strd	r0, r1, [r3, #32]
	}
	virtual void update(void);
	void gain(float n) {
		if (n > 32767.0f) n = 32767.0f;
		else if (n < -32767.0f) n = -32767.0f;
		multiplier = n * 65536.0f;
60002ed4:	4b24      	ldr	r3, [pc, #144]	; (60002f68 <MAX98357A::init()+0x1ac>)
        DEBUG("MAX98357A::init() completed.\n")
60002ed6:	4914      	ldr	r1, [pc, #80]	; (60002f28 <MAX98357A::init()+0x16c>)
60002ed8:	4814      	ldr	r0, [pc, #80]	; (60002f2c <MAX98357A::init()+0x170>)
60002eda:	619a      	str	r2, [r3, #24]
60002edc:	f038 fea0 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002ee0:	4913      	ldr	r1, [pc, #76]	; (60002f30 <MAX98357A::init()+0x174>)
60002ee2:	f038 fb25 	bl	6003b530 <___ZN5debug4CoutI17usb_serial2_classElsIA57_cEERS2_RKT__veneer>
60002ee6:	4913      	ldr	r1, [pc, #76]	; (60002f34 <MAX98357A::init()+0x178>)
60002ee8:	f038 fe9a 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002eec:	2361      	movs	r3, #97	; 0x61
60002eee:	a901      	add	r1, sp, #4
60002ef0:	9301      	str	r3, [sp, #4]
60002ef2:	f038 fad9 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60002ef6:	4910      	ldr	r1, [pc, #64]	; (60002f38 <MAX98357A::init()+0x17c>)
60002ef8:	f038 fb42 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60002efc:	4605      	mov	r5, r0
                if (_serial) _serial->print(v);
60002efe:	6800      	ldr	r0, [r0, #0]
60002f00:	b110      	cbz	r0, 60002f08 <MAX98357A::init()+0x14c>
60002f02:	491a      	ldr	r1, [pc, #104]	; (60002f6c <MAX98357A::init()+0x1b0>)
60002f04:	f038 ff34 	bl	6003bd70 <___ZN5Print5printEPKc.isra.0_veneer>
60002f08:	4628      	mov	r0, r5
60002f0a:	490d      	ldr	r1, [pc, #52]	; (60002f40 <MAX98357A::init()+0x184>)
60002f0c:	f038 f868 	bl	6003afe0 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60002f10:	6820      	ldr	r0, [r4, #0]
        }
60002f12:	b003      	add	sp, #12
60002f14:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        DEBUG("MAX98357A::init() completed.\n")
60002f18:	f038 bd22 	b.w	6003b960 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
        }
60002f1c:	b003      	add	sp, #12
60002f1e:	bd30      	pop	{r4, r5, pc}
60002f20:	20200000 	.word	0x20200000
60002f24:	20044393 	.word	0x20044393
60002f28:	2000662d 	.word	0x2000662d
60002f2c:	2001546c 	.word	0x2001546c
60002f30:	20006634 	.word	0x20006634
60002f34:	2000666d 	.word	0x2000666d
60002f38:	20006674 	.word	0x20006674
60002f3c:	20006677 	.word	0x20006677
60002f40:	2000aaf4 	.word	0x2000aaf4
60002f44:	20013e3c 	.word	0x20013e3c
60002f48:	20006691 	.word	0x20006691
60002f4c:	70000064 	.word	0x70000064
60002f50:	20019908 	.word	0x20019908
60002f54:	00000c2d 	.word	0x00000c2d
60002f58:	6003bed8 	.word	0x6003bed8
60002f5c:	200066b3 	.word	0x200066b3
60002f60:	200066b0 	.word	0x200066b0
60002f64:	200198d0 	.word	0x200198d0
60002f68:	20019860 	.word	0x20019860
60002f6c:	200066c1 	.word	0x200066c1

60002f70 <MAX98357A::speak(char const*, Print*)>:
        {
60002f70:	b530      	push	{r4, r5, lr}
        if (_is_speaking) // if we are already speaking, stop the current speak
60002f72:	4d27      	ldr	r5, [pc, #156]	; (60003010 <MAX98357A::speak(char const*, Print*)+0xa0>)
        {
60002f74:	b087      	sub	sp, #28
60002f76:	4602      	mov	r2, r0
60002f78:	460c      	mov	r4, r1
        if (_is_speaking) // if we are already speaking, stop the current speak
60002f7a:	682b      	ldr	r3, [r5, #0]
60002f7c:	b11b      	cbz	r3, 60002f86 <MAX98357A::speak(char const*, Print*)+0x16>
60002f7e:	9003      	str	r0, [sp, #12]
            stopSpeak();
60002f80:	f7ff fe46 	bl	60002c10 <MAX98357A::stopSpeak()>
60002f84:	9a03      	ldr	r2, [sp, #12]
        _is_speaking = 1; 
60002f86:	2301      	movs	r3, #1
        _th_speak = threads.addThread(speakThread, (void*)text, ESPEAK_STACK_SIZE, Memory::espeak_stack);
60002f88:	4922      	ldr	r1, [pc, #136]	; (60003014 <MAX98357A::speak(char const*, Print*)+0xa4>)
60002f8a:	4823      	ldr	r0, [pc, #140]	; (60003018 <MAX98357A::speak(char const*, Print*)+0xa8>)
        _is_speaking = 1; 
60002f8c:	602b      	str	r3, [r5, #0]
        _speakTextOutput = textOutput;
60002f8e:	4b23      	ldr	r3, [pc, #140]	; (6000301c <MAX98357A::speak(char const*, Print*)+0xac>)
        _th_speak = threads.addThread(speakThread, (void*)text, ESPEAK_STACK_SIZE, Memory::espeak_stack);
60002f90:	4d23      	ldr	r5, [pc, #140]	; (60003020 <MAX98357A::speak(char const*, Print*)+0xb0>)
        _speakTextOutput = textOutput;
60002f92:	601c      	str	r4, [r3, #0]
        _th_speak = threads.addThread(speakThread, (void*)text, ESPEAK_STACK_SIZE, Memory::espeak_stack);
60002f94:	4b23      	ldr	r3, [pc, #140]	; (60003024 <MAX98357A::speak(char const*, Print*)+0xb4>)
60002f96:	9300      	str	r3, [sp, #0]
60002f98:	f242 7310 	movw	r3, #10000	; 0x2710
60002f9c:	f038 fccc 	bl	6003b938 <___ZN7Threads9addThreadEPFvPvES0_iS0__veneer>
60002fa0:	6028      	str	r0, [r5, #0]
        if (_th_speak < 0) { ABORT("MAX98357A::speak() failed to start thread !"); }
60002fa2:	682b      	ldr	r3, [r5, #0]
60002fa4:	2b00      	cmp	r3, #0
60002fa6:	da2a      	bge.n	60002ffe <MAX98357A::speak(char const*, Print*)+0x8e>
60002fa8:	f038 fd72 	bl	6003ba90 <___Z8is_panicv_veneer>
60002fac:	bb38      	cbnz	r0, 60002ffe <MAX98357A::speak(char const*, Print*)+0x8e>
60002fae:	491e      	ldr	r1, [pc, #120]	; (60003028 <MAX98357A::speak(char const*, Print*)+0xb8>)
60002fb0:	481e      	ldr	r0, [pc, #120]	; (6000302c <MAX98357A::speak(char const*, Print*)+0xbc>)
60002fb2:	f038 fe35 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002fb6:	491e      	ldr	r1, [pc, #120]	; (60003030 <MAX98357A::speak(char const*, Print*)+0xc0>)
60002fb8:	f038 faba 	bl	6003b530 <___ZN5debug4CoutI17usb_serial2_classElsIA57_cEERS2_RKT__veneer>
60002fbc:	491d      	ldr	r1, [pc, #116]	; (60003034 <MAX98357A::speak(char const*, Print*)+0xc4>)
60002fbe:	f038 fe2f 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60002fc2:	23cf      	movs	r3, #207	; 0xcf
60002fc4:	a905      	add	r1, sp, #20
60002fc6:	9305      	str	r3, [sp, #20]
60002fc8:	f038 fa6e 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60002fcc:	491a      	ldr	r1, [pc, #104]	; (60003038 <MAX98357A::speak(char const*, Print*)+0xc8>)
60002fce:	f038 fad7 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60002fd2:	4604      	mov	r4, r0
60002fd4:	6800      	ldr	r0, [r0, #0]
60002fd6:	b110      	cbz	r0, 60002fde <MAX98357A::speak(char const*, Print*)+0x6e>
60002fd8:	4918      	ldr	r1, [pc, #96]	; (6000303c <MAX98357A::speak(char const*, Print*)+0xcc>)
60002fda:	f038 fec9 	bl	6003bd70 <___ZN5Print5printEPKc.isra.0_veneer>
60002fde:	4918      	ldr	r1, [pc, #96]	; (60003040 <MAX98357A::speak(char const*, Print*)+0xd0>)
60002fe0:	4620      	mov	r0, r4
60002fe2:	f037 fffd 	bl	6003afe0 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60002fe6:	4b11      	ldr	r3, [pc, #68]	; (6000302c <MAX98357A::speak(char const*, Print*)+0xbc>)
60002fe8:	6818      	ldr	r0, [r3, #0]
60002fea:	f038 fcb9 	bl	6003b960 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
                print(v); 
60002fee:	4913      	ldr	r1, [pc, #76]	; (6000303c <MAX98357A::speak(char const*, Print*)+0xcc>)
60002ff0:	4814      	ldr	r0, [pc, #80]	; (60003044 <MAX98357A::speak(char const*, Print*)+0xd4>)
60002ff2:	f038 febd 	bl	6003bd70 <___ZN5Print5printEPKc.isra.0_veneer>
60002ff6:	f038 fbff 	bl	6003b7f8 <___Z9set_panicv_veneer>
60002ffa:	f007 fe01 	bl	6000ac00 <hang()>
        teensythread::speedUp(_th_speak, 5.0f); // thread needs compute time in the beginning but will yield later
60002ffe:	eeb1 0a04 	vmov.f32	s0, #20	; 0x40a00000  5.0
60003002:	6828      	ldr	r0, [r5, #0]
        }
60003004:	b007      	add	sp, #28
60003006:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        teensythread::speedUp(_th_speak, 5.0f); // thread needs compute time in the beginning but will yield later
6000300a:	f00d bd71 	b.w	60010af0 <teensythread::speedUp(int, float)>
6000300e:	bf00      	nop
60003010:	20019790 	.word	0x20019790
60003014:	00000c39 	.word	0x00000c39
60003018:	2001a5e4 	.word	0x2001a5e4
6000301c:	20019854 	.word	0x20019854
60003020:	20019b7c 	.word	0x20019b7c
60003024:	20201830 	.word	0x20201830
60003028:	2000662d 	.word	0x2000662d
6000302c:	2001546c 	.word	0x2001546c
60003030:	20006634 	.word	0x20006634
60003034:	2000666d 	.word	0x2000666d
60003038:	20006674 	.word	0x20006674
6000303c:	200066df 	.word	0x200066df
60003040:	2000aaf4 	.word	0x2000aaf4
60003044:	70000064 	.word	0x70000064

60003048 <MAX98357A::speakformatted(char const*, int, int, int, Print*)>:
        {
60003048:	b537      	push	{r0, r1, r2, r4, r5, lr}
        misc::formatText(Memory::speak_text_buffer, text, v1, v2, v3);
6000304a:	4c08      	ldr	r4, [pc, #32]	; (6000306c <MAX98357A::speakformatted(char const*, int, int, int, Print*)+0x24>)
        {
6000304c:	9d06      	ldr	r5, [sp, #24]
        misc::formatText(Memory::speak_text_buffer, text, v1, v2, v3);
6000304e:	9300      	str	r3, [sp, #0]
60003050:	4613      	mov	r3, r2
60003052:	460a      	mov	r2, r1
60003054:	4601      	mov	r1, r0
60003056:	4620      	mov	r0, r4
60003058:	f007 fda8 	bl	6000abac <misc::formatText(char*, char const*, int, int, int)>
        speak(Memory::speak_text_buffer, textOutput);
6000305c:	4629      	mov	r1, r5
6000305e:	4620      	mov	r0, r4
        }
60003060:	b003      	add	sp, #12
60003062:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
        speak(Memory::speak_text_buffer, textOutput);
60003066:	f7ff bf83 	b.w	60002f70 <MAX98357A::speak(char const*, Print*)>
6000306a:	bf00      	nop
6000306c:	70000874 	.word	0x70000874

60003070 <batteryAnimation(int, bool)>:
    return tgx::RGB565(r, g, b);
    }


SLOWFUN int batteryAnimation(int code, bool clearConsole)
    {
60003070:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003074:	ed2d 8b02 	vpush	{d8}
60003078:	b08d      	sub	sp, #52	; 0x34
6000307a:	4606      	mov	r6, r0
6000307c:	460c      	mov	r4, r1
    const uint32_t lt = Display::touchedTime();
6000307e:	f000 ffef 	bl	60004060 <Display::touchedTime()>
60003082:	9001      	str	r0, [sp, #4]

    if (MAX98357A::isSpeaking()) 
60003084:	f038 fc68 	bl	6003b958 <___ZN9MAX98357A10isSpeakingEv_veneer>
60003088:	2800      	cmp	r0, #0
6000308a:	f000 80ac 	beq.w	600031e6 <batteryAnimation(int, bool)+0x176>
        { // force clear when interrupting speech
        MAX98357A::stopSpeak(); 
6000308e:	f7ff fdbf 	bl	60002c10 <MAX98357A::stopSpeak()>
        }  
    int y;
    if (clearConsole)
        { // clear
        Console::console.clear(); 
        y = 0;
60003092:	2700      	movs	r7, #0
        Console::console.clear(); 
60003094:	489c      	ldr	r0, [pc, #624]	; (60003308 <batteryAnimation(int, bool)+0x298>)
60003096:	f000 faaf 	bl	600035f8 <Console::TFTConsole::clear()>
        { // skip 2 lines. 
        y = Console::console.getCursor().y;
        } 
        
    // beep sound
    MAX98357A::setAudioLevelMusic(0.5f * TRANSITION_TAG_SOUND_LEVEL);
6000309a:	eeb5 0a00 	vmov.f32	s0, #80	; 0x3e800000  0.250
6000309e:	f7ff fdf9 	bl	60002c94 <MAX98357A::setAudioLevelMusic(float)>
    MAX98357A::audioLed.setDriver(MAX98357A::AudioLed::DRIVER_MUSIC);
600030a2:	2102      	movs	r1, #2
600030a4:	4899      	ldr	r0, [pc, #612]	; (6000330c <batteryAnimation(int, bool)+0x29c>)
600030a6:	f7ff fd43 	bl	60002b30 <MAX98357A::AudioLed::setDriver(int)>
    MAX98357A::playMusic((code == CODE_CHARGING_START) ? FILENAME_SOUND_CHARGING_ON : ((code == CODE_CHARGING_STOP) ? FILENAME_SOUND_CHARGING_OFF : FILENAME_SOUND_BATTERY_STATUS));
600030aa:	2e03      	cmp	r6, #3
600030ac:	f000 80a4 	beq.w	600031f8 <batteryAnimation(int, bool)+0x188>
600030b0:	4897      	ldr	r0, [pc, #604]	; (60003310 <batteryAnimation(int, bool)+0x2a0>)
600030b2:	f1a0 033b 	sub.w	r3, r0, #59	; 0x3b
600030b6:	2e04      	cmp	r6, #4
600030b8:	bf18      	it	ne
600030ba:	4618      	movne	r0, r3
600030bc:	2100      	movs	r1, #0
600030be:	f7ff fe6f 	bl	60002da0 <MAX98357A::playMusic(char const*, bool)>

    // create the full tag
    char msg[26];
    memset(msg, ' ', 25); 
600030c2:	2219      	movs	r2, #25
600030c4:	2120      	movs	r1, #32
600030c6:	a805      	add	r0, sp, #20
600030c8:	f038 f836 	bl	6003b138 <__memset_veneer>
    msg[25] = 0;
600030cc:	2300      	movs	r3, #0
    strcpy(msg, (code == CODE_CHARGING_START) ? TAG_CHARGE_ON : ((code == CODE_CHARGING_STOP) ? TAG_CHARGE_OFF : TAG_BATTERY));
600030ce:	2e03      	cmp	r6, #3
    msg[25] = 0;
600030d0:	f88d 302d 	strb.w	r3, [sp, #45]	; 0x2d
    strcpy(msg, (code == CODE_CHARGING_START) ? TAG_CHARGE_ON : ((code == CODE_CHARGING_STOP) ? TAG_CHARGE_OFF : TAG_BATTERY));
600030d4:	f000 8092 	beq.w	600031fc <batteryAnimation(int, bool)+0x18c>
600030d8:	498e      	ldr	r1, [pc, #568]	; (60003314 <batteryAnimation(int, bool)+0x2a4>)
600030da:	f1a1 0325 	sub.w	r3, r1, #37	; 0x25
600030de:	2e04      	cmp	r6, #4
600030e0:	bf18      	it	ne
600030e2:	4619      	movne	r1, r3
600030e4:	a805      	add	r0, sp, #20
600030e6:	f037 ffef 	bl	6003b0c8 <__strcpy_veneer>
    msg[strlen(msg)] = ' ';
600030ea:	a805      	add	r0, sp, #20
600030ec:	f038 fcf8 	bl	6003bae0 <__strlen_veneer>
600030f0:	f100 0330 	add.w	r3, r0, #48	; 0x30
600030f4:	eb0d 0003 	add.w	r0, sp, r3
600030f8:	2320      	movs	r3, #32
600030fa:	f800 3c1c 	strb.w	r3, [r0, #-28]
    int iC; // index where color changes
    tgx::RGB565 C;  // color to use
    const int st = FBSensors::peekChargeStatus();
600030fe:	f038 fb6f 	bl	6003b7e0 <___ZN9FBSensors16peekChargeStatusEv_veneer>
60003102:	4680      	mov	r8, r0
    const int pct = FBSensors::getBatteryPercent();    
60003104:	f037 ff3c 	bl	6003af80 <___ZN9FBSensors17getBatteryPercentEv_veneer>
    if (code == CODE_CHARGING_START)
60003108:	2e03      	cmp	r6, #3
    const int pct = FBSensors::getBatteryPercent();    
6000310a:	ee08 0a10 	vmov	s16, r0
    if (code == CODE_CHARGING_START)
6000310e:	f040 809a 	bne.w	60003246 <batteryAnimation(int, bool)+0x1d6>
        { // display the current in format "234mA" or "1.23A"
        const int mA = (int)(FBSensors::getChargingCurrent() * 1000); // in mA
60003112:	f038 fbd1 	bl	6003b8b8 <___ZN9FBSensors18getChargingCurrentEv_veneer>
60003116:	eddf 7a80 	vldr	s15, [pc, #512]	; 60003318 <batteryAnimation(int, bool)+0x2a8>
6000311a:	ee20 0a27 	vmul.f32	s0, s0, s15
6000311e:	eefd 7ac0 	vcvt.s32.f32	s15, s0
60003122:	ee17 3a90 	vmov	r3, s15
        if (mA > 1000)
60003126:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
6000312a:	dd69      	ble.n	60003200 <batteryAnimation(int, bool)+0x190>
            {
            msg[20] = '0' + ((mA / 1000) % 10);
6000312c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
60003130:	210a      	movs	r1, #10
60003132:	fb93 f2f2 	sdiv	r2, r3, r2
60003136:	fbb2 f0f1 	udiv	r0, r2, r1
6000313a:	fb01 2210 	mls	r2, r1, r0, r2
6000313e:	3230      	adds	r2, #48	; 0x30
60003140:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
            msg[21] = '.';
60003144:	222e      	movs	r2, #46	; 0x2e
60003146:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
            msg[22] = '0' + ((mA / 100) % 10);
6000314a:	2264      	movs	r2, #100	; 0x64
6000314c:	fb93 f2f2 	sdiv	r2, r3, r2
            msg[23] = '0' + ((mA / 10) % 10);
60003150:	fb93 f3f1 	sdiv	r3, r3, r1
            msg[22] = '0' + ((mA / 100) % 10);
60003154:	fbb2 f0f1 	udiv	r0, r2, r1
60003158:	fb01 2210 	mls	r2, r1, r0, r2
            msg[23] = '0' + ((mA / 10) % 10);
6000315c:	fbb3 f0f1 	udiv	r0, r3, r1
60003160:	fb01 3310 	mls	r3, r1, r0, r3
            msg[22] = '0' + ((mA / 100) % 10);
60003164:	3230      	adds	r2, #48	; 0x30
            msg[23] = '0' + ((mA / 10) % 10);
60003166:	3330      	adds	r3, #48	; 0x30
            msg[22] = '0' + ((mA / 100) % 10);
60003168:	b2d2      	uxtb	r2, r2
            msg[23] = '0' + ((mA / 10) % 10);
6000316a:	b2db      	uxtb	r3, r3
6000316c:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
            if (mA >= 10) { msg[21] = '0' + ((mA / 10) % 10); }
            msg[22] = '0' + (mA % 10);
            msg[23] = 'm';
            msg[24] = 'A';
            }
        C = TFT_CONSOLE_MESSAGE_COLOR_DONE;
60003170:	f240 4465 	movw	r4, #1125	; 0x465
            msg[24] = 'A';
60003174:	2341      	movs	r3, #65	; 0x41
        iC = 20; 
60003176:	f04f 0914 	mov.w	r9, #20
            msg[22] = '0' + ((mA / 100) % 10);
6000317a:	f88d 202a 	strb.w	r2, [sp, #42]	; 0x2a
            msg[24] = 'A';
6000317e:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
            C = batteryColorRGB565(pct);
            }
        }

    // print the tag progressively, char by char
    Console::console.setCurrentColor(TFT_CONSOLE_MESSAGE_COLOR);
60003182:	f244 414e 	movw	r1, #17486	; 0x444e
60003186:	4860      	ldr	r0, [pc, #384]	; (60003308 <batteryAnimation(int, bool)+0x298>)
60003188:	f000 fa4b 	bl	60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>
    Console::console.setCursor(0, y);
6000318c:	463a      	mov	r2, r7
6000318e:	2100      	movs	r1, #0
60003190:	485d      	ldr	r0, [pc, #372]	; (60003308 <batteryAnimation(int, bool)+0x298>)
60003192:	f000 fa91 	bl	600036b8 <Console::TFTConsole::setCursor(int, int)>
60003196:	4b61      	ldr	r3, [pc, #388]	; (6000331c <batteryAnimation(int, bool)+0x2ac>)
    int i = 0;
60003198:	f04f 0a00 	mov.w	sl, #0
    elapsedMillis em = 0;
    while (msg[i])
        {
        if (i == iC) { Console::console.setCurrentColor(C); } // change color
6000319c:	f8df b168 	ldr.w	fp, [pc, #360]	; 60003308 <batteryAnimation(int, bool)+0x298>
600031a0:	681b      	ldr	r3, [r3, #0]
600031a2:	9300      	str	r3, [sp, #0]
    while (msg[i])
600031a4:	f10a 0330 	add.w	r3, sl, #48	; 0x30
600031a8:	eb0d 0503 	add.w	r5, sp, r3
600031ac:	f815 1c1c 	ldrb.w	r1, [r5, #-28]
600031b0:	2900      	cmp	r1, #0
600031b2:	f040 80c1 	bne.w	60003338 <batteryAnimation(int, bool)+0x2c8>
        graphics3D::updateAll(0);
        threads.yield();
        }

    // speak the text
    Console::console.setCursor(0, y);
600031b6:	463a      	mov	r2, r7
600031b8:	4853      	ldr	r0, [pc, #332]	; (60003308 <batteryAnimation(int, bool)+0x298>)
600031ba:	f000 fa7d 	bl	600036b8 <Console::TFTConsole::setCursor(int, int)>
    Console::console.print("\n\n");
600031be:	4958      	ldr	r1, [pc, #352]	; (60003320 <batteryAnimation(int, bool)+0x2b0>)
600031c0:	4851      	ldr	r0, [pc, #324]	; (60003308 <batteryAnimation(int, bool)+0x298>)
600031c2:	f037 ff99 	bl	6003b0f8 <___ZN5Print5printEPKc.isra.0_veneer>
    Console::console.showCursor(true);
600031c6:	2101      	movs	r1, #1
600031c8:	484f      	ldr	r0, [pc, #316]	; (60003308 <batteryAnimation(int, bool)+0x298>)
600031ca:	f000 fa27 	bl	6000361c <Console::TFTConsole::showCursor(bool)>
    Console::console.setCurrentColor(TFT_CONSOLE_COLOR);
600031ce:	4b55      	ldr	r3, [pc, #340]	; (60003324 <batteryAnimation(int, bool)+0x2b4>)
600031d0:	484d      	ldr	r0, [pc, #308]	; (60003308 <batteryAnimation(int, bool)+0x298>)
600031d2:	8819      	ldrh	r1, [r3, #0]
600031d4:	f000 fa25 	bl	60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>
    const char* text;
    if (code == CODE_CHARGING_START)
600031d8:	2e03      	cmp	r6, #3
600031da:	f040 8116 	bne.w	6000340a <batteryAnimation(int, bool)+0x39a>
        {
        text = sentences::picker_power_on.next_str(); 
600031de:	4852      	ldr	r0, [pc, #328]	; (60003328 <batteryAnimation(int, bool)+0x2b8>)
            {
            text = sentences::picker_battery_critical.next_str();
            }
        else
            {
            text = sentences::picker_battery_ok.next_str();
600031e0:	f038 f9d6 	bl	6003b590 <___ZN11IndexPickerILi13EE8next_strEv_veneer>
600031e4:	e116      	b.n	60003414 <batteryAnimation(int, bool)+0x3a4>
    if (clearConsole)
600031e6:	2c00      	cmp	r4, #0
600031e8:	f47f af53 	bne.w	60003092 <batteryAnimation(int, bool)+0x22>
        y = Console::console.getCursor().y;
600031ec:	4946      	ldr	r1, [pc, #280]	; (60003308 <batteryAnimation(int, bool)+0x298>)
600031ee:	a805      	add	r0, sp, #20
600031f0:	f000 fa70 	bl	600036d4 <Console::TFTConsole::getCursor()>
600031f4:	9f06      	ldr	r7, [sp, #24]
600031f6:	e750      	b.n	6000309a <batteryAnimation(int, bool)+0x2a>
    MAX98357A::playMusic((code == CODE_CHARGING_START) ? FILENAME_SOUND_CHARGING_ON : ((code == CODE_CHARGING_STOP) ? FILENAME_SOUND_CHARGING_OFF : FILENAME_SOUND_BATTERY_STATUS));
600031f8:	484c      	ldr	r0, [pc, #304]	; (6000332c <batteryAnimation(int, bool)+0x2bc>)
600031fa:	e75f      	b.n	600030bc <batteryAnimation(int, bool)+0x4c>
    strcpy(msg, (code == CODE_CHARGING_START) ? TAG_CHARGE_ON : ((code == CODE_CHARGING_STOP) ? TAG_CHARGE_OFF : TAG_BATTERY));
600031fc:	494c      	ldr	r1, [pc, #304]	; (60003330 <batteryAnimation(int, bool)+0x2c0>)
600031fe:	e771      	b.n	600030e4 <batteryAnimation(int, bool)+0x74>
            if (mA >= 100) { msg[20] = '0' + ((mA / 100) % 10); }
60003200:	2b63      	cmp	r3, #99	; 0x63
60003202:	dd15      	ble.n	60003230 <batteryAnimation(int, bool)+0x1c0>
60003204:	2264      	movs	r2, #100	; 0x64
60003206:	210a      	movs	r1, #10
60003208:	fb93 f2f2 	sdiv	r2, r3, r2
6000320c:	fbb2 f0f1 	udiv	r0, r2, r1
60003210:	fb01 2210 	mls	r2, r1, r0, r2
60003214:	3230      	adds	r2, #48	; 0x30
60003216:	f88d 2028 	strb.w	r2, [sp, #40]	; 0x28
            if (mA >= 10) { msg[21] = '0' + ((mA / 10) % 10); }
6000321a:	210a      	movs	r1, #10
6000321c:	fb93 f2f1 	sdiv	r2, r3, r1
60003220:	fbb2 f0f1 	udiv	r0, r2, r1
60003224:	fb01 2210 	mls	r2, r1, r0, r2
60003228:	3230      	adds	r2, #48	; 0x30
6000322a:	f88d 2029 	strb.w	r2, [sp, #41]	; 0x29
6000322e:	e001      	b.n	60003234 <batteryAnimation(int, bool)+0x1c4>
60003230:	2b09      	cmp	r3, #9
60003232:	dcf2      	bgt.n	6000321a <batteryAnimation(int, bool)+0x1aa>
            msg[22] = '0' + (mA % 10);
60003234:	220a      	movs	r2, #10
60003236:	fb93 f1f2 	sdiv	r1, r3, r2
6000323a:	fb02 3311 	mls	r3, r2, r1, r3
6000323e:	3330      	adds	r3, #48	; 0x30
60003240:	b2da      	uxtb	r2, r3
60003242:	236d      	movs	r3, #109	; 0x6d
60003244:	e792      	b.n	6000316c <batteryAnimation(int, bool)+0xfc>
        if ((st == CODE_CHARGING) || (st == CODE_CHARGING_START))
60003246:	f1b8 0f06 	cmp.w	r8, #6
6000324a:	d002      	beq.n	60003252 <batteryAnimation(int, bool)+0x1e2>
6000324c:	f1b8 0f03 	cmp.w	r8, #3
60003250:	d109      	bne.n	60003266 <batteryAnimation(int, bool)+0x1f6>
            strcpy(msg + iC, "CHARGING");
60003252:	4938      	ldr	r1, [pc, #224]	; (60003334 <batteryAnimation(int, bool)+0x2c4>)
60003254:	f10d 0025 	add.w	r0, sp, #37	; 0x25
            C = TFT_CONSOLE_MESSAGE_COLOR_DONE;
60003258:	f240 4465 	movw	r4, #1125	; 0x465
            iC = 17;
6000325c:	f04f 0911 	mov.w	r9, #17
            strcpy(msg + iC, "CHARGING");
60003260:	f037 ff32 	bl	6003b0c8 <__strcpy_veneer>
            C = TFT_CONSOLE_MESSAGE_COLOR_DONE;
60003264:	e78d      	b.n	60003182 <batteryAnimation(int, bool)+0x112>
            int pct = FBSensors::getBatteryPercent();
60003266:	f037 fe8b 	bl	6003af80 <___ZN9FBSensors17getBatteryPercentEv_veneer>
            if (pct >= 100) { msg[21] = '0' + ((pct / 100) % 10); }
6000326a:	2863      	cmp	r0, #99	; 0x63
6000326c:	dd15      	ble.n	6000329a <batteryAnimation(int, bool)+0x22a>
6000326e:	2364      	movs	r3, #100	; 0x64
60003270:	220a      	movs	r2, #10
60003272:	fb90 f3f3 	sdiv	r3, r0, r3
60003276:	fbb3 f1f2 	udiv	r1, r3, r2
6000327a:	fb02 3311 	mls	r3, r2, r1, r3
6000327e:	3330      	adds	r3, #48	; 0x30
60003280:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
            if (pct >= 10) { msg[22] = '0' + ((pct / 10) % 10); }
60003284:	220a      	movs	r2, #10
60003286:	fb90 f3f2 	sdiv	r3, r0, r2
6000328a:	fbb3 f1f2 	udiv	r1, r3, r2
6000328e:	fb02 3311 	mls	r3, r2, r1, r3
60003292:	3330      	adds	r3, #48	; 0x30
60003294:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
60003298:	e001      	b.n	6000329e <batteryAnimation(int, bool)+0x22e>
6000329a:	2809      	cmp	r0, #9
6000329c:	dcf2      	bgt.n	60003284 <batteryAnimation(int, bool)+0x214>
            msg[23] = '0' + (pct % 10);
6000329e:	220a      	movs	r2, #10
    if (p < 0) { p = 0; } else if (p > 100) { p = 100; }
600032a0:	2800      	cmp	r0, #0
            msg[23] = '0' + (pct % 10);
600032a2:	fb90 f3f2 	sdiv	r3, r0, r2
600032a6:	fb02 0313 	mls	r3, r2, r3, r0
600032aa:	f103 0330 	add.w	r3, r3, #48	; 0x30
600032ae:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
            msg[24] = '%';
600032b2:	f04f 0325 	mov.w	r3, #37	; 0x25
600032b6:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
    if (p < 0) { p = 0; } else if (p > 100) { p = 100; }
600032ba:	db12      	blt.n	600032e2 <batteryAnimation(int, bool)+0x272>
600032bc:	2864      	cmp	r0, #100	; 0x64
600032be:	dc12      	bgt.n	600032e6 <batteryAnimation(int, bool)+0x276>
    if (p <= 50) 
600032c0:	2832      	cmp	r0, #50	; 0x32
600032c2:	dc11      	bgt.n	600032e8 <batteryAnimation(int, bool)+0x278>
        g = (G_red * q + G_yel * p + 25) / 50;
600032c4:	2223      	movs	r2, #35	; 0x23
600032c6:	2332      	movs	r3, #50	; 0x32
        b = (B_red * q + B_yel * p + 25) / 50;
600032c8:	2400      	movs	r4, #0
        g = (G_red * q + G_yel * p + 25) / 50;
600032ca:	4342      	muls	r2, r0
600032cc:	3219      	adds	r2, #25
600032ce:	fbb2 f2f3 	udiv	r2, r2, r3
        r = (R_red * q + R_yel * p + 25) / 50;
600032d2:	2312      	movs	r3, #18
        constexpr RGB565(int r, int g, int b) : 
600032d4:	ea44 1442 	orr.w	r4, r4, r2, lsl #5
            iC = 21;
600032d8:	f04f 0915 	mov.w	r9, #21
600032dc:	ea44 24c3 	orr.w	r4, r4, r3, lsl #11
    return tgx::RGB565(r, g, b);
600032e0:	e74f      	b.n	60003182 <batteryAnimation(int, bool)+0x112>
    if (p < 0) { p = 0; } else if (p > 100) { p = 100; }
600032e2:	2000      	movs	r0, #0
600032e4:	e7ee      	b.n	600032c4 <batteryAnimation(int, bool)+0x254>
600032e6:	2064      	movs	r0, #100	; 0x64
        r = (R_yel * q + R_grn * p + 25) / 50;
600032e8:	2212      	movs	r2, #18
        const int q = 50 - p;
600032ea:	f1c0 0364 	rsb	r3, r0, #100	; 0x64
        b = (B_yel * q + B_grn * p + 25) / 50;
600032ee:	eb00 0480 	add.w	r4, r0, r0, lsl #2
        r = (R_yel * q + R_grn * p + 25) / 50;
600032f2:	4353      	muls	r3, r2
600032f4:	2232      	movs	r2, #50	; 0x32
        b = (B_yel * q + B_grn * p + 25) / 50;
600032f6:	3ce1      	subs	r4, #225	; 0xe1
        r = (R_yel * q + R_grn * p + 25) / 50;
600032f8:	3319      	adds	r3, #25
        b = (B_yel * q + B_grn * p + 25) / 50;
600032fa:	fbb4 f4f2 	udiv	r4, r4, r2
        r = (R_yel * q + R_grn * p + 25) / 50;
600032fe:	fbb3 f3f2 	udiv	r3, r3, r2
        g = (G_yel * q + G_grn * p + 25) / 50;
60003302:	2223      	movs	r2, #35	; 0x23
60003304:	e7e6      	b.n	600032d4 <batteryAnimation(int, bool)+0x264>
60003306:	bf00      	nop
60003308:	20018e1c 	.word	0x20018e1c
6000330c:	200196ac 	.word	0x200196ac
60003310:	6003c095 	.word	0x6003c095
60003314:	6003c0d8 	.word	0x6003c0d8
60003318:	447a0000 	.word	0x447a0000
6000331c:	2001a5d4 	.word	0x2001a5d4
60003320:	2000aaf3 	.word	0x2000aaf3
60003324:	200047f4 	.word	0x200047f4
60003328:	20019c54 	.word	0x20019c54
6000332c:	6003c078 	.word	0x6003c078
60003330:	6003c0c4 	.word	0x6003c0c4
60003334:	2000670b 	.word	0x2000670b
        if (i == iC) { Console::console.setCurrentColor(C); } // change color
60003338:	45d1      	cmp	r9, sl
6000333a:	d103      	bne.n	60003344 <batteryAnimation(int, bool)+0x2d4>
6000333c:	4621      	mov	r1, r4
6000333e:	4658      	mov	r0, fp
60003340:	f000 f96f 	bl	60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>
60003344:	4b56      	ldr	r3, [pc, #344]	; (600034a0 <batteryAnimation(int, bool)+0x430>)
	operator unsigned long () const { return millis() - ms; }
60003346:	9a00      	ldr	r2, [sp, #0]
60003348:	681b      	ldr	r3, [r3, #0]
6000334a:	1a9b      	subs	r3, r3, r2
        if (em > 60) { Console::console.print(msg[i]); em = 0; i++; };
6000334c:	2b3c      	cmp	r3, #60	; 0x3c
6000334e:	d909      	bls.n	60003364 <batteryAnimation(int, bool)+0x2f4>
	virtual void flush()				{ }
	size_t write(const char *buffer, size_t size)	{ return write((const uint8_t *)buffer, size); }
	// Print a string
	size_t print(const String &s);
	// Print a single character
	size_t print(char c)				{ return write((uint8_t)c); }
60003350:	f815 1c1c 	ldrb.w	r1, [r5, #-28]
60003354:	4658      	mov	r0, fp
60003356:	f000 f8b9 	bl	600034cc <Console::TFTConsole::write(unsigned char)>
6000335a:	4b51      	ldr	r3, [pc, #324]	; (600034a0 <batteryAnimation(int, bool)+0x430>)
6000335c:	f10a 0a01 	add.w	sl, sl, #1
60003360:	681b      	ldr	r3, [r3, #0]
60003362:	9300      	str	r3, [sp, #0]
        if (CraddleMove::status() == CODE_SPINNED)
60003364:	f038 fa28 	bl	6003b7b8 <___ZN11CraddleMove6statusEv_veneer>
60003368:	2802      	cmp	r0, #2
6000336a:	4605      	mov	r5, r0
6000336c:	d145      	bne.n	600033fa <batteryAnimation(int, bool)+0x38a>
            MAX98357A::audioLed.setDriver(MAX98357A::AudioLed::DRIVER_MUSIC);
6000336e:	4601      	mov	r1, r0
60003370:	484c      	ldr	r0, [pc, #304]	; (600034a4 <batteryAnimation(int, bool)+0x434>)
60003372:	f7ff fbdd 	bl	60002b30 <MAX98357A::AudioLed::setDriver(int)>
            MAX98357A::playMusic(FILENAME_SOUND_ABORT_CHARGING);
60003376:	2100      	movs	r1, #0
60003378:	484b      	ldr	r0, [pc, #300]	; (600034a8 <batteryAnimation(int, bool)+0x438>)
            msg[iC - 1] = 0; 
6000337a:	f04f 0800 	mov.w	r8, #0
            MAX98357A::playMusic(FILENAME_SOUND_ABORT_CHARGING);
6000337e:	f7ff fd0f 	bl	60002da0 <MAX98357A::playMusic(char const*, bool)>
            Console::console.eraseLine(y);
60003382:	4639      	mov	r1, r7
60003384:	4849      	ldr	r0, [pc, #292]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
            Console::console.setText({ 0, y }, msg);
60003386:	ae03      	add	r6, sp, #12
            Console::console.eraseLine(y);
60003388:	f000 f94e 	bl	60003628 <Console::TFTConsole::eraseLine(int)>
            msg[iC - 1] = 0; 
6000338c:	f109 0330 	add.w	r3, r9, #48	; 0x30
            Console::console.setCurrentColor(TFT_CONSOLE_MESSAGE_COLOR);
60003390:	f244 414e 	movw	r1, #17486	; 0x444e
60003394:	4845      	ldr	r0, [pc, #276]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
            msg[iC - 1] = 0; 
60003396:	446b      	add	r3, sp
60003398:	f803 8c1d 	strb.w	r8, [r3, #-29]
            Console::console.setCurrentColor(TFT_CONSOLE_MESSAGE_COLOR);
6000339c:	f000 f941 	bl	60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>
            Console::console.setText({ 0, y }, msg);
600033a0:	ab05      	add	r3, sp, #20
600033a2:	4842      	ldr	r0, [pc, #264]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033a4:	e9cd 8703 	strd	r8, r7, [sp, #12]
600033a8:	e896 0006 	ldmia.w	r6, {r1, r2}
600033ac:	f000 f961 	bl	60003672 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)>
            Console::console.setCurrentColor(C);
600033b0:	4621      	mov	r1, r4
600033b2:	483e      	ldr	r0, [pc, #248]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033b4:	f000 f935 	bl	60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>
            Console::console.setText({ iC, y }, msg + iC);
600033b8:	ab05      	add	r3, sp, #20
600033ba:	483c      	ldr	r0, [pc, #240]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033bc:	444b      	add	r3, r9
600033be:	e9cd 9703 	strd	r9, r7, [sp, #12]
600033c2:	e896 0006 	ldmia.w	r6, {r1, r2}
600033c6:	f000 f954 	bl	60003672 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)>
            Console::console.setCursor( 0, y);
600033ca:	463a      	mov	r2, r7
600033cc:	4641      	mov	r1, r8
600033ce:	4837      	ldr	r0, [pc, #220]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033d0:	f000 f972 	bl	600036b8 <Console::TFTConsole::setCursor(int, int)>
            Console::console.print("\n");
600033d4:	4936      	ldr	r1, [pc, #216]	; (600034b0 <batteryAnimation(int, bool)+0x440>)
600033d6:	4835      	ldr	r0, [pc, #212]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033d8:	f037 fe8e 	bl	6003b0f8 <___ZN5Print5printEPKc.isra.0_veneer>
            Console::console.showCursor(true); // show the cursor again   
600033dc:	2101      	movs	r1, #1
600033de:	4833      	ldr	r0, [pc, #204]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033e0:	f000 f91c 	bl	6000361c <Console::TFTConsole::showCursor(bool)>
            Console::console.setCurrentColor(TFT_CONSOLE_COLOR);
600033e4:	4b33      	ldr	r3, [pc, #204]	; (600034b4 <batteryAnimation(int, bool)+0x444>)
600033e6:	4831      	ldr	r0, [pc, #196]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
600033e8:	8819      	ldrh	r1, [r3, #0]
600033ea:	f000 f91a 	bl	60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>
        threads.yield(); // 
        }
    Console::console.print("\n");
    FBSensors::chargeStatus();// discard change in battery status
    return ((CraddleMove::status() == CODE_SPINNED) ? CODE_SPINNED : ((Display::touchedTime()  > lt + 200) ? CODE_TOUCHED_SCREEN : 0));
    }
600033ee:	4628      	mov	r0, r5
600033f0:	b00d      	add	sp, #52	; 0x34
600033f2:	ecbd 8b02 	vpop	{d8}
600033f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        graphics3D::updateAll(0);
600033fa:	2200      	movs	r2, #0
600033fc:	4611      	mov	r1, r2
600033fe:	4610      	mov	r0, r2
60003400:	f004 fd6a 	bl	60007ed8 <graphics3D::updateAll(int, int, tgx::Mat4<float> const*)>
        threads.yield();
60003404:	f037 fdc8 	bl	6003af98 <___ZN7Threads5yieldEv_veneer>
60003408:	e6cc      	b.n	600031a4 <batteryAnimation(int, bool)+0x134>
    else if (code == CODE_CHARGING_STOP)
6000340a:	2e04      	cmp	r6, #4
6000340c:	d122      	bne.n	60003454 <batteryAnimation(int, bool)+0x3e4>
        text = sentences::picker_power_off.next_str();
6000340e:	482a      	ldr	r0, [pc, #168]	; (600034b8 <batteryAnimation(int, bool)+0x448>)
60003410:	f038 f9aa 	bl	6003b768 <___ZN11IndexPickerILi16EE8next_strEv_veneer>
            text = sentences::picker_battery_ok.next_str();
60003414:	4604      	mov	r4, r0
    MAX98357A::audioLed.setDriver(MAX98357A::AudioLed::DRIVER_VOICE);
60003416:	2101      	movs	r1, #1
60003418:	4822      	ldr	r0, [pc, #136]	; (600034a4 <batteryAnimation(int, bool)+0x434>)
6000341a:	f7ff fb89 	bl	60002b30 <MAX98357A::AudioLed::setDriver(int)>
    MAX98357A::speak(text);
6000341e:	4923      	ldr	r1, [pc, #140]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
60003420:	4620      	mov	r0, r4
60003422:	f7ff fda5 	bl	60002f70 <MAX98357A::speak(char const*, Print*)>
    while (MAX98357A::isSpeaking())
60003426:	f038 fa97 	bl	6003b958 <___ZN9MAX98357A10isSpeakingEv_veneer>
6000342a:	bb48      	cbnz	r0, 60003480 <batteryAnimation(int, bool)+0x410>
    Console::console.print("\n");
6000342c:	4920      	ldr	r1, [pc, #128]	; (600034b0 <batteryAnimation(int, bool)+0x440>)
6000342e:	481f      	ldr	r0, [pc, #124]	; (600034ac <batteryAnimation(int, bool)+0x43c>)
60003430:	f037 fe62 	bl	6003b0f8 <___ZN5Print5printEPKc.isra.0_veneer>
    FBSensors::chargeStatus();// discard change in battery status
60003434:	f038 faa0 	bl	6003b978 <___ZN9FBSensors12chargeStatusEv_veneer>
    return ((CraddleMove::status() == CODE_SPINNED) ? CODE_SPINNED : ((Display::touchedTime()  > lt + 200) ? CODE_TOUCHED_SCREEN : 0));
60003438:	f038 f9be 	bl	6003b7b8 <___ZN11CraddleMove6statusEv_veneer>
6000343c:	2802      	cmp	r0, #2
6000343e:	4605      	mov	r5, r0
60003440:	d0d5      	beq.n	600033ee <batteryAnimation(int, bool)+0x37e>
60003442:	f000 fe0d 	bl	60004060 <Display::touchedTime()>
60003446:	9b01      	ldr	r3, [sp, #4]
60003448:	33c8      	adds	r3, #200	; 0xc8
6000344a:	4298      	cmp	r0, r3
6000344c:	bf94      	ite	ls
6000344e:	2500      	movls	r5, #0
60003450:	2501      	movhi	r5, #1
60003452:	e7cc      	b.n	600033ee <batteryAnimation(int, bool)+0x37e>
    else if ((st == CODE_CHARGING) || (st == CODE_CHARGING_START))
60003454:	f1b8 0f06 	cmp.w	r8, #6
60003458:	d002      	beq.n	60003460 <batteryAnimation(int, bool)+0x3f0>
6000345a:	f1b8 0f03 	cmp.w	r8, #3
6000345e:	d103      	bne.n	60003468 <batteryAnimation(int, bool)+0x3f8>
        text = sentences::picker_battery_charging.next_str();
60003460:	4816      	ldr	r0, [pc, #88]	; (600034bc <batteryAnimation(int, bool)+0x44c>)
60003462:	f038 f835 	bl	6003b4d0 <___ZN11IndexPickerILi18EE8next_strEv_veneer>
60003466:	e7d5      	b.n	60003414 <batteryAnimation(int, bool)+0x3a4>
        if (pct <= VOLTAGE_THRESHOLD_LOW)
60003468:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
6000346c:	eddf 7a14 	vldr	s15, [pc, #80]	; 600034c0 <batteryAnimation(int, bool)+0x450>
60003470:	eeb4 8ae7 	vcmpe.f32	s16, s15
60003474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            text = sentences::picker_battery_critical.next_str();
60003478:	bf94      	ite	ls
6000347a:	4812      	ldrls	r0, [pc, #72]	; (600034c4 <batteryAnimation(int, bool)+0x454>)
            text = sentences::picker_battery_ok.next_str();
6000347c:	4812      	ldrhi	r0, [pc, #72]	; (600034c8 <batteryAnimation(int, bool)+0x458>)
6000347e:	e6af      	b.n	600031e0 <batteryAnimation(int, bool)+0x170>
        if (CraddleMove::status() == CODE_SPINNED) 
60003480:	f038 f99a 	bl	6003b7b8 <___ZN11CraddleMove6statusEv_veneer>
60003484:	2802      	cmp	r0, #2
60003486:	4605      	mov	r5, r0
60003488:	d102      	bne.n	60003490 <batteryAnimation(int, bool)+0x420>
            FBSensors::chargeStatus(); 
6000348a:	f038 fa75 	bl	6003b978 <___ZN9FBSensors12chargeStatusEv_veneer>
            return CODE_SPINNED; 
6000348e:	e7ae      	b.n	600033ee <batteryAnimation(int, bool)+0x37e>
        graphics3D::updateAll(0); // redraw the screen
60003490:	2200      	movs	r2, #0
60003492:	4611      	mov	r1, r2
60003494:	4610      	mov	r0, r2
60003496:	f004 fd1f 	bl	60007ed8 <graphics3D::updateAll(int, int, tgx::Mat4<float> const*)>
        threads.yield(); // 
6000349a:	f037 fd7d 	bl	6003af98 <___ZN7Threads5yieldEv_veneer>
6000349e:	e7c2      	b.n	60003426 <batteryAnimation(int, bool)+0x3b6>
600034a0:	2001a5d4 	.word	0x2001a5d4
600034a4:	200196ac 	.word	0x200196ac
600034a8:	6003c0ea 	.word	0x6003c0ea
600034ac:	20018e1c 	.word	0x20018e1c
600034b0:	2000aaf4 	.word	0x2000aaf4
600034b4:	200047f4 	.word	0x200047f4
600034b8:	20019c9c 	.word	0x20019c9c
600034bc:	20019e14 	.word	0x20019e14
600034c0:	40eccccd 	.word	0x40eccccd
600034c4:	20019e38 	.word	0x20019e38
600034c8:	20019cc0 	.word	0x20019cc0

600034cc <Console::TFTConsole::write(unsigned char)>:
        }


    SLOWFUN size_t TFTConsole::write(uint8_t c)
        {
        if (c != '\n')
600034cc:	290a      	cmp	r1, #10
        {
600034ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
600034d0:	4604      	mov	r4, r0
        if (c != '\n')
600034d2:	d016      	beq.n	60003502 <Console::TFTConsole::write(unsigned char)+0x36>
            { // regular char
            if (c < 32) c = 32;  // replace control characters with space
            const int o = (_cy * TFT_CONSOLE_CHAR_LX) + _cx; // offset in the buffer
600034d4:	68c2      	ldr	r2, [r0, #12]
            _buffer[o] = c;
600034d6:	2920      	cmp	r1, #32
            const int o = (_cy * TFT_CONSOLE_CHAR_LX) + _cx; // offset in the buffer
600034d8:	6883      	ldr	r3, [r0, #8]
600034da:	f04f 0019 	mov.w	r0, #25
            _buffer[o] = c;
600034de:	bf38      	it	cc
600034e0:	2120      	movcc	r1, #32
            const int o = (_cy * TFT_CONSOLE_CHAR_LX) + _cx; // offset in the buffer
600034e2:	fb00 3302 	mla	r3, r0, r2, r3
            _buffer[o] = c;
600034e6:	18e2      	adds	r2, r4, r3
            _color[o] = _currentcolor;
600034e8:	eb04 0343 	add.w	r3, r4, r3, lsl #1
            _buffer[o] = c;
600034ec:	7411      	strb	r1, [r2, #16]
            _color[o] = _currentcolor;
600034ee:	f8b4 22fe 	ldrh.w	r2, [r4, #766]	; 0x2fe
600034f2:	f8a3 210a 	strh.w	r2, [r3, #266]	; 0x10a
            _cx++; // now update the cursor position            
600034f6:	68a3      	ldr	r3, [r4, #8]
600034f8:	3301      	adds	r3, #1
600034fa:	60a3      	str	r3, [r4, #8]
            if (_cx >= TFT_CONSOLE_CHAR_LX)
600034fc:	68a3      	ldr	r3, [r4, #8]
600034fe:	2b18      	cmp	r3, #24
60003500:	dd04      	ble.n	6000350c <Console::TFTConsole::write(unsigned char)+0x40>
                _cy++; // move to the next line
                }
            } 
        else
            { // new line
            _cx = 0;
60003502:	2300      	movs	r3, #0
60003504:	60a3      	str	r3, [r4, #8]
            _cy++;
60003506:	68e3      	ldr	r3, [r4, #12]
60003508:	3301      	adds	r3, #1
6000350a:	60e3      	str	r3, [r4, #12]
            }
            if (_cy >= TFT_CONSOLE_CHAR_LY)
6000350c:	68e3      	ldr	r3, [r4, #12]
6000350e:	2b09      	cmp	r3, #9
60003510:	dd2d      	ble.n	6000356e <Console::TFTConsole::write(unsigned char)+0xa2>
                { // scrolling required
                _cy = TFT_CONSOLE_CHAR_LY - 1; // keep the cursor at the last line
60003512:	2309      	movs	r3, #9
60003514:	f104 0010 	add.w	r0, r4, #16
60003518:	f504 7285 	add.w	r2, r4, #266	; 0x10a
6000351c:	f104 05f1 	add.w	r5, r4, #241	; 0xf1
60003520:	60e3      	str	r3, [r4, #12]
                for (int j = 0; j < TFT_CONSOLE_CHAR_LY - 1; j++)
                    {
                    for (int i = 0; i < TFT_CONSOLE_CHAR_LX; i++)
60003522:	4603      	mov	r3, r0
60003524:	3019      	adds	r0, #25
                        {
                        const int o = (j * TFT_CONSOLE_CHAR_LX) + i; // offset in the buffer
                        _buffer[o] = _buffer[o + TFT_CONSOLE_CHAR_LX]; // move the character from the next line to the current line
60003526:	4601      	mov	r1, r0
60003528:	f100 0618 	add.w	r6, r0, #24
6000352c:	f851 7b04 	ldr.w	r7, [r1], #4
60003530:	42b1      	cmp	r1, r6
60003532:	f843 7b04 	str.w	r7, [r3], #4
60003536:	d1f9      	bne.n	6000352c <Console::TFTConsole::write(unsigned char)+0x60>
60003538:	7809      	ldrb	r1, [r1, #0]
6000353a:	7019      	strb	r1, [r3, #0]
6000353c:	4613      	mov	r3, r2
6000353e:	3232      	adds	r2, #50	; 0x32
                        _color[o] = _color[o + TFT_CONSOLE_CHAR_LX];
60003540:	4611      	mov	r1, r2
60003542:	f102 0630 	add.w	r6, r2, #48	; 0x30
60003546:	f851 7b04 	ldr.w	r7, [r1], #4
6000354a:	42b1      	cmp	r1, r6
6000354c:	f843 7b04 	str.w	r7, [r3], #4
60003550:	d1f9      	bne.n	60003546 <Console::TFTConsole::write(unsigned char)+0x7a>
60003552:	8809      	ldrh	r1, [r1, #0]
                for (int j = 0; j < TFT_CONSOLE_CHAR_LY - 1; j++)
60003554:	42a8      	cmp	r0, r5
                        _color[o] = _color[o + TFT_CONSOLE_CHAR_LX];
60003556:	8019      	strh	r1, [r3, #0]
                for (int j = 0; j < TFT_CONSOLE_CHAR_LY - 1; j++)
60003558:	d1e3      	bne.n	60003522 <Console::TFTConsole::write(unsigned char)+0x56>
                        }
                    }
                memset(_buffer + ((TFT_CONSOLE_CHAR_LY - 1) * TFT_CONSOLE_CHAR_LX), ' ', TFT_CONSOLE_CHAR_LX); // clear the last line
6000355a:	2219      	movs	r2, #25
6000355c:	2120      	movs	r1, #32
6000355e:	f037 fdeb 	bl	6003b138 <__memset_veneer>
                memset(_color + ((TFT_CONSOLE_CHAR_LY - 1) * TFT_CONSOLE_CHAR_LX), 0, TFT_CONSOLE_CHAR_LX*sizeof(uint16_t)); // clear the last line
60003562:	2232      	movs	r2, #50	; 0x32
60003564:	2100      	movs	r1, #0
60003566:	f504 7033 	add.w	r0, r4, #716	; 0x2cc
6000356a:	f037 fde5 	bl	6003b138 <__memset_veneer>
6000356e:	4b03      	ldr	r3, [pc, #12]	; (6000357c <Console::TFTConsole::write(unsigned char)+0xb0>)
                }
            _em = 0; // reset the elapsed millis for the cursor
            return 1;
        }
60003570:	2001      	movs	r0, #1
60003572:	681b      	ldr	r3, [r3, #0]
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
60003574:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
60003578:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
6000357a:	bf00      	nop
6000357c:	2001a5d4 	.word	0x2001a5d4

60003580 <Console::getCharBox(tgx::Vec2<int> const&)>:
        const int xx = TFT_CONSOLE_OFF_X + TFT_CONSOLE_FONT_WIDTH * pos.x;
60003580:	220c      	movs	r2, #12
        {
60003582:	b510      	push	{r4, lr}
        const int xx = TFT_CONSOLE_OFF_X + TFT_CONSOLE_FONT_WIDTH * pos.x;
60003584:	680c      	ldr	r4, [r1, #0]
60003586:	4354      	muls	r4, r2
        const int yy = TFT_CONSOLE_OFF_Y + TFT_CONSOLE_FONT_HEIGHT * pos.y;
60003588:	684a      	ldr	r2, [r1, #4]
6000358a:	2114      	movs	r1, #20
6000358c:	434a      	muls	r2, r1
        const int xx = TFT_CONSOLE_OFF_X + TFT_CONSOLE_FONT_WIDTH * pos.x;
6000358e:	f104 010b 	add.w	r1, r4, #11
        return tgx::iBox2(xx, xx + TFT_CONSOLE_FONT_WIDTH, yy, yy + TFT_CONSOLE_FONT_HEIGHT);
60003592:	3417      	adds	r4, #23


        /**
         * Constructor with explicit dimensions.
         */
        constexpr Box2(const T minx, const T maxx, const T miny, const T maxy) : minX(minx), maxX(maxx), minY(miny), maxY(maxy)
60003594:	6001      	str	r1, [r0, #0]
        const int yy = TFT_CONSOLE_OFF_Y + TFT_CONSOLE_FONT_HEIGHT * pos.y;
60003596:	f102 011e 	add.w	r1, r2, #30
        return tgx::iBox2(xx, xx + TFT_CONSOLE_FONT_WIDTH, yy, yy + TFT_CONSOLE_FONT_HEIGHT);
6000359a:	3232      	adds	r2, #50	; 0x32
6000359c:	6044      	str	r4, [r0, #4]
6000359e:	6081      	str	r1, [r0, #8]
600035a0:	60c2      	str	r2, [r0, #12]
        }
600035a2:	bd10      	pop	{r4, pc}

600035a4 <Console::TFTConsole::TFTConsole()>:
    SLOWFUN TFTConsole::TFTConsole() : _cx(0), _cy(0), _currentcolor((uint16_t)TFT_CONSOLE_COLOR), _cursor_on(true), _em(0)
600035a4:	b538      	push	{r3, r4, r5, lr}
600035a6:	4b11      	ldr	r3, [pc, #68]	; (600035ec <Console::TFTConsole::TFTConsole()+0x48>)
	constexpr Print() : write_error(0) {}
600035a8:	2500      	movs	r5, #0
600035aa:	4604      	mov	r4, r0
        memset(_buffer, ' ', sizeof(_buffer));
600035ac:	22fa      	movs	r2, #250	; 0xfa
    SLOWFUN TFTConsole::TFTConsole() : _cx(0), _cy(0), _currentcolor((uint16_t)TFT_CONSOLE_COLOR), _cursor_on(true), _em(0)
600035ae:	6003      	str	r3, [r0, #0]
        memset(_buffer, ' ', sizeof(_buffer));
600035b0:	2120      	movs	r1, #32
    SLOWFUN TFTConsole::TFTConsole() : _cx(0), _cy(0), _currentcolor((uint16_t)TFT_CONSOLE_COLOR), _cursor_on(true), _em(0)
600035b2:	4b0f      	ldr	r3, [pc, #60]	; (600035f0 <Console::TFTConsole::TFTConsole()+0x4c>)
        memset(_buffer, ' ', sizeof(_buffer));
600035b4:	3010      	adds	r0, #16
    SLOWFUN TFTConsole::TFTConsole() : _cx(0), _cy(0), _currentcolor((uint16_t)TFT_CONSOLE_COLOR), _cursor_on(true), _em(0)
600035b6:	f840 5c08 	str.w	r5, [r0, #-8]
600035ba:	881b      	ldrh	r3, [r3, #0]
600035bc:	f840 5c04 	str.w	r5, [r0, #-4]
600035c0:	f8a0 32ee 	strh.w	r3, [r0, #750]	; 0x2ee
600035c4:	2301      	movs	r3, #1
600035c6:	f840 5c0c 	str.w	r5, [r0, #-12]
600035ca:	f880 32f0 	strb.w	r3, [r0, #752]	; 0x2f0
600035ce:	4b09      	ldr	r3, [pc, #36]	; (600035f4 <Console::TFTConsole::TFTConsole()+0x50>)
600035d0:	681b      	ldr	r3, [r3, #0]
	elapsedMillis(unsigned long val) { ms = millis() - val; }
600035d2:	f8c0 32f4 	str.w	r3, [r0, #756]	; 0x2f4
        memset(_buffer, ' ', sizeof(_buffer));
600035d6:	f037 fdaf 	bl	6003b138 <__memset_veneer>
        memset(_color, 0, sizeof(_color)); // initialize the color buffer to 0 (black)
600035da:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
600035de:	4629      	mov	r1, r5
600035e0:	f504 7085 	add.w	r0, r4, #266	; 0x10a
600035e4:	f037 fda8 	bl	6003b138 <__memset_veneer>
        }
600035e8:	4620      	mov	r0, r4
600035ea:	bd38      	pop	{r3, r4, r5, pc}
600035ec:	20003624 	.word	0x20003624
600035f0:	200047f4 	.word	0x200047f4
600035f4:	2001a5d4 	.word	0x2001a5d4

600035f8 <Console::TFTConsole::clear()>:
        {
600035f8:	b510      	push	{r4, lr}
600035fa:	4604      	mov	r4, r0
        memset(_buffer, ' ', sizeof(_buffer));
600035fc:	22fa      	movs	r2, #250	; 0xfa
600035fe:	2120      	movs	r1, #32
60003600:	3010      	adds	r0, #16
60003602:	f037 fd99 	bl	6003b138 <__memset_veneer>
        memset(_color, 0, sizeof(_color)); // initialize the color buffer to 0 (black)
60003606:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
6000360a:	2100      	movs	r1, #0
6000360c:	f504 7085 	add.w	r0, r4, #266	; 0x10a
60003610:	f037 fd92 	bl	6003b138 <__memset_veneer>
        _cx = 0;
60003614:	2300      	movs	r3, #0
60003616:	60a3      	str	r3, [r4, #8]
        _cy = 0;
60003618:	60e3      	str	r3, [r4, #12]
        }
6000361a:	bd10      	pop	{r4, pc}

6000361c <Console::TFTConsole::showCursor(bool)>:
        _cursor_on = show;
6000361c:	f880 1300 	strb.w	r1, [r0, #768]	; 0x300
        }
60003620:	4770      	bx	lr

60003622 <Console::TFTConsole::setCurrentColor(tgx::RGB565)>:
        _currentcolor = (uint16_t)color; // set the current color
60003622:	f8a0 12fe 	strh.w	r1, [r0, #766]	; 0x2fe
        }
60003626:	4770      	bx	lr

60003628 <Console::TFTConsole::eraseLine(int)>:
        if ((y < 0) || (y >= TFT_CONSOLE_CHAR_LY)) return; // out of bounds
60003628:	2909      	cmp	r1, #9
        {
6000362a:	460b      	mov	r3, r1
        if ((y < 0) || (y >= TFT_CONSOLE_CHAR_LY)) return; // out of bounds
6000362c:	d806      	bhi.n	6000363c <Console::TFTConsole::eraseLine(int)+0x14>
        memset(_buffer + o, ' ', TFT_CONSOLE_CHAR_LX); // clear the line
6000362e:	3010      	adds	r0, #16
60003630:	2219      	movs	r2, #25
60003632:	2120      	movs	r1, #32
60003634:	fb02 0003 	mla	r0, r2, r3, r0
60003638:	f037 bd7e 	b.w	6003b138 <__memset_veneer>
        }
6000363c:	4770      	bx	lr

6000363e <Console::TFTConsole::setChar(tgx::Vec2<int>, char)>:
        {
6000363e:	b513      	push	{r0, r1, r4, lr}
        if ((pos.x < 0) || (pos.x >= TFT_CONSOLE_CHAR_LX) || (pos.y < 0) || (pos.y >= TFT_CONSOLE_CHAR_LY)) return; // out of bounds
60003640:	2918      	cmp	r1, #24
        {
60003642:	ac02      	add	r4, sp, #8
60003644:	e904 0006 	stmdb	r4, {r1, r2}
60003648:	460a      	mov	r2, r1
        if ((pos.x < 0) || (pos.x >= TFT_CONSOLE_CHAR_LX) || (pos.y < 0) || (pos.y >= TFT_CONSOLE_CHAR_LY)) return; // out of bounds
6000364a:	d810      	bhi.n	6000366e <Console::TFTConsole::setChar(tgx::Vec2<int>, char)+0x30>
6000364c:	9901      	ldr	r1, [sp, #4]
6000364e:	2909      	cmp	r1, #9
60003650:	d80d      	bhi.n	6000366e <Console::TFTConsole::setChar(tgx::Vec2<int>, char)+0x30>
        const int o = (pos.y * TFT_CONSOLE_CHAR_LX) + pos.x; // offset in the buffer
60003652:	2419      	movs	r4, #25
        _buffer[o] = c; // set the character
60003654:	2b20      	cmp	r3, #32
        const int o = (pos.y * TFT_CONSOLE_CHAR_LX) + pos.x; // offset in the buffer
60003656:	fb04 2201 	mla	r2, r4, r1, r2
        _buffer[o] = c; // set the character
6000365a:	bf38      	it	cc
6000365c:	2320      	movcc	r3, #32
6000365e:	1881      	adds	r1, r0, r2
        _color[o] = _currentcolor; // set the color of the character
60003660:	eb00 0242 	add.w	r2, r0, r2, lsl #1
        _buffer[o] = c; // set the character
60003664:	740b      	strb	r3, [r1, #16]
        _color[o] = _currentcolor; // set the color of the character
60003666:	f8b0 32fe 	ldrh.w	r3, [r0, #766]	; 0x2fe
6000366a:	f8a2 310a 	strh.w	r3, [r2, #266]	; 0x10a
        }
6000366e:	b002      	add	sp, #8
60003670:	bd10      	pop	{r4, pc}

60003672 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)>:
        {
60003672:	b537      	push	{r0, r1, r2, r4, r5, lr}
        if ((pos.x < 0) || (pos.x >= TFT_CONSOLE_CHAR_LX) || (pos.y < 0) || (pos.y >= TFT_CONSOLE_CHAR_LY)) return; // out of bounds
60003674:	2918      	cmp	r1, #24
        {
60003676:	ac02      	add	r4, sp, #8
60003678:	e904 0006 	stmdb	r4, {r1, r2}
        if ((pos.x < 0) || (pos.x >= TFT_CONSOLE_CHAR_LX) || (pos.y < 0) || (pos.y >= TFT_CONSOLE_CHAR_LY)) return; // out of bounds
6000367c:	d810      	bhi.n	600036a0 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)+0x2e>
6000367e:	2a09      	cmp	r2, #9
60003680:	d80e      	bhi.n	600036a0 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)+0x2e>
            auto o = (pos.y * TFT_CONSOLE_CHAR_LX) + pos.x + i;
60003682:	2519      	movs	r5, #25
60003684:	1e5c      	subs	r4, r3, #1
60003686:	fb05 1202 	mla	r2, r5, r2, r1
6000368a:	1a69      	subs	r1, r5, r1
            _color[o] = _currentcolor; // set the color of the character
6000368c:	f1c0 05ea 	rsb	r5, r0, #234	; 0xea
60003690:	320f      	adds	r2, #15
60003692:	440b      	add	r3, r1
60003694:	4402      	add	r2, r0
        while (txt[i] && (i + pos.x < TFT_CONSOLE_CHAR_LX))
60003696:	f814 1f01 	ldrb.w	r1, [r4, #1]!
6000369a:	b109      	cbz	r1, 600036a0 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)+0x2e>
6000369c:	429c      	cmp	r4, r3
6000369e:	d101      	bne.n	600036a4 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)+0x32>
        }
600036a0:	b003      	add	sp, #12
600036a2:	bd30      	pop	{r4, r5, pc}
            if (txt[i] < 32) _buffer[o] = ' '; else _buffer[o] = txt[i];
600036a4:	2920      	cmp	r1, #32
600036a6:	bf38      	it	cc
600036a8:	2120      	movcc	r1, #32
600036aa:	f802 1f01 	strb.w	r1, [r2, #1]!
            _color[o] = _currentcolor; // set the color of the character
600036ae:	f8b0 12fe 	ldrh.w	r1, [r0, #766]	; 0x2fe
600036b2:	f825 1012 	strh.w	r1, [r5, r2, lsl #1]
            i++;
600036b6:	e7ee      	b.n	60003696 <Console::TFTConsole::setText(tgx::Vec2<int>, char const*)+0x24>

600036b8 <Console::TFTConsole::setCursor(int, int)>:


    SLOWFUN void TFTConsole::setCursor(int x, int y)
        {
        if (x < 0 || x >= TFT_CONSOLE_CHAR_LX || y < 0 || y >= TFT_CONSOLE_CHAR_LY) return; // out of bounds
600036b8:	2918      	cmp	r1, #24
600036ba:	d807      	bhi.n	600036cc <Console::TFTConsole::setCursor(int, int)+0x14>
600036bc:	2a09      	cmp	r2, #9
600036be:	d805      	bhi.n	600036cc <Console::TFTConsole::setCursor(int, int)+0x14>
600036c0:	4b03      	ldr	r3, [pc, #12]	; (600036d0 <Console::TFTConsole::setCursor(int, int)+0x18>)
        _cx = x;
600036c2:	6081      	str	r1, [r0, #8]
        _cy = y;
600036c4:	60c2      	str	r2, [r0, #12]
600036c6:	681b      	ldr	r3, [r3, #0]
	elapsedMillis & operator = (unsigned long val) { ms = millis() - val; return *this; }
600036c8:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
        _em = 0; // reset cursor timer
        }
600036cc:	4770      	bx	lr
600036ce:	bf00      	nop
600036d0:	2001a5d4 	.word	0x2001a5d4

600036d4 <Console::TFTConsole::getCursor()>:


    SLOWFUN tgx::iVec2 TFTConsole::getCursor()
        {
600036d4:	b510      	push	{r4, lr}
        return { _cx, _cy }; 
600036d6:	688c      	ldr	r4, [r1, #8]
600036d8:	68ca      	ldr	r2, [r1, #12]
600036da:	e9c0 4200 	strd	r4, r2, [r0]
        }
600036de:	bd10      	pop	{r4, pc}

600036e0 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)>:



    SLOWFUN void TFTConsole::_drawChar(tgx::Image<tgx::RGB565>& im, int i, int j, float opacity)
        {
600036e0:	b570      	push	{r4, r5, r6, lr}
        const int o = i + (j * TFT_CONSOLE_CHAR_LX);
600036e2:	2519      	movs	r5, #25
        {
600036e4:	4614      	mov	r4, r2
600036e6:	b088      	sub	sp, #32
        const int o = i + (j * TFT_CONSOLE_CHAR_LX);
600036e8:	fb05 2503 	mla	r5, r5, r3, r2
        const char c = _buffer[o];
600036ec:	1942      	adds	r2, r0, r5
        const tgx::RGB565 color = _color[o];
600036ee:	eb00 0045 	add.w	r0, r0, r5, lsl #1
        const int x = TFT_CONSOLE_OFF_X + TFT_CONSOLE_FONT_WIDTH * i;
600036f2:	250c      	movs	r5, #12
        const tgx::RGB565 color = _color[o];
600036f4:	f8b0 010a 	ldrh.w	r0, [r0, #266]	; 0x10a
        const int x = TFT_CONSOLE_OFF_X + TFT_CONSOLE_FONT_WIDTH * i;
600036f8:	436c      	muls	r4, r5
        const int y = TFT_CONSOLE_OFF_Y + TFT_CONSOLE_FONT_HEIGHT * j;
600036fa:	2514      	movs	r5, #20
        const char c = _buffer[o];
600036fc:	7c12      	ldrb	r2, [r2, #16]
        const int y = TFT_CONSOLE_OFF_Y + TFT_CONSOLE_FONT_HEIGHT * j;
600036fe:	436b      	muls	r3, r5
            return(val == c.val);
60003700:	4d28      	ldr	r5, [pc, #160]	; (600037a4 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0xc4>)
        const int x = TFT_CONSOLE_OFF_X + TFT_CONSOLE_FONT_WIDTH * i;
60003702:	340b      	adds	r4, #11
        if ((color == TFT_CONSOLE_COLOR) && (opacity >= 1.0f))
60003704:	882d      	ldrh	r5, [r5, #0]
60003706:	4285      	cmp	r5, r0
60003708:	d109      	bne.n	6000371e <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x3e>
            { // hack : yellow text is semi transparent. 
            opacity = 0.6f; 
6000370a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
6000370e:	eeb4 0a67 	vcmp.f32	s0, s15
60003712:	eddf 7a25 	vldr	s15, [pc, #148]	; 600037a8 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0xc8>
60003716:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000371a:	fe27 0a80 	vselge.f32	s0, s15, s0
            }
        if ((color == TFT_CONSOLE_MESSAGE_COLOR)||(color == TFT_CONSOLE_MESSAGE_COUNT) ||(color == TFT_CONSOLE_MESSAGE_COUNT) || (color == TFT_CONSOLE_MESSAGE_COLOR_ABORT) || (color == TFT_CONSOLE_MESSAGE_COLOR_DONE))
6000371e:	f244 464e 	movw	r6, #17486	; 0x444e
        /**
         * Query if the image is valid.
         *
         * @returns True if the image if valid, false otherwise.
         */
        inline TGX_INLINE bool isValid() const { return (_buffer != nullptr); }
60003722:	680d      	ldr	r5, [r1, #0]
60003724:	42b0      	cmp	r0, r6
60003726:	d026      	beq.n	60003776 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x96>
60003728:	f5b0 4f10 	cmp.w	r0, #36864	; 0x9000
6000372c:	d023      	beq.n	60003776 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x96>
6000372e:	f240 4665 	movw	r6, #1125	; 0x465
60003732:	42b0      	cmp	r0, r6
60003734:	d01f      	beq.n	60003776 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x96>
            { // hack, use bold font
            im.drawChar(c, { x, y + TFT_CONSOLE_BASELINE_OFF - 1}, TFT_CONSOLE_FONT_BOLD, color, opacity); // draw the character
            }
        else
            {
            im.drawChar(c, { x, y + TFT_CONSOLE_BASELINE_OFF }, TFT_CONSOLE_FONT, color, opacity); // draw the character
60003736:	332d      	adds	r3, #45	; 0x2d
60003738:	9406      	str	r4, [sp, #24]
6000373a:	9307      	str	r3, [sp, #28]
        }

    template<typename color_t>
    iVec2 Image<color_t>::drawChar(char c, iVec2 pos, const ILI9341_t3_font_t& font, color_t color, float opacity)
        {
        if (!isValid()) return pos; 
6000373c:	b1b5      	cbz	r5, 6000376c <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x8c>
        if ((opacity < 0) || (opacity > 1)) opacity = 1.0f;
6000373e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
60003742:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
60003746:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000374a:	d411      	bmi.n	60003770 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x90>
6000374c:	eeb4 0a67 	vcmp.f32	s0, s15
60003750:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60003754:	fe37 0a80 	vselgt.f32	s0, s15, s0
            auto B = measureChar(c, pos, font, DEFAULT_TEXT_ANCHOR);
            iVec2 pos2 = B.getAnchor(anchor);
            pos += pos - pos2;
            }
        */
        return _drawCharILI<false>(c, pos, color, font, opacity);
60003758:	4b14      	ldr	r3, [pc, #80]	; (600037ac <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0xcc>)
6000375a:	9302      	str	r3, [sp, #8]
6000375c:	9b07      	ldr	r3, [sp, #28]
6000375e:	f8ad 0004 	strh.w	r0, [sp, #4]
60003762:	a804      	add	r0, sp, #16
60003764:	9300      	str	r3, [sp, #0]
60003766:	9b06      	ldr	r3, [sp, #24]
60003768:	f037 fdce 	bl	6003b308 <___ZN3tgx5ImageINS_6RGB565EE12_drawCharILIILb0EEENS_4Vec2IiEEcS5_S1_RK17ILI9341_t3_font_tf_veneer>
            }
        
        }
6000376c:	b008      	add	sp, #32
6000376e:	bd70      	pop	{r4, r5, r6, pc}
        if ((opacity < 0) || (opacity > 1)) opacity = 1.0f;
60003770:	eeb0 0a67 	vmov.f32	s0, s15
60003774:	e7f0      	b.n	60003758 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x78>
            im.drawChar(c, { x, y + TFT_CONSOLE_BASELINE_OFF - 1}, TFT_CONSOLE_FONT_BOLD, color, opacity); // draw the character
60003776:	332c      	adds	r3, #44	; 0x2c
60003778:	9406      	str	r4, [sp, #24]
6000377a:	9307      	str	r3, [sp, #28]
        if (!isValid()) return pos; 
6000377c:	2d00      	cmp	r5, #0
6000377e:	d0f5      	beq.n	6000376c <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x8c>
        if ((opacity < 0) || (opacity > 1)) opacity = 1.0f;
60003780:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
60003784:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
60003788:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
6000378c:	d407      	bmi.n	6000379e <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0xbe>
6000378e:	eeb4 0a67 	vcmp.f32	s0, s15
60003792:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60003796:	fe37 0a80 	vselgt.f32	s0, s15, s0
        return _drawCharILI<false>(c, pos, color, font, opacity);
6000379a:	4b05      	ldr	r3, [pc, #20]	; (600037b0 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0xd0>)
6000379c:	e7dd      	b.n	6000375a <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0x7a>
        if ((opacity < 0) || (opacity > 1)) opacity = 1.0f;
6000379e:	eeb0 0a67 	vmov.f32	s0, s15
600037a2:	e7fa      	b.n	6000379a <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)+0xba>
600037a4:	200047f4 	.word	0x200047f4
600037a8:	3f19999a 	.word	0x3f19999a
600037ac:	60058cac 	.word	0x60058cac
600037b0:	60084790 	.word	0x60084790

600037b4 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)>:


    SLOWFUN void TFTConsole::draw(tgx::Image<tgx::RGB565>& im, bool force_cursor)
        {
        static bool first_draw = true;
        if (first_draw)
600037b4:	4b4c      	ldr	r3, [pc, #304]	; (600038e8 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x134>)
        {
600037b6:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
600037ba:	4692      	mov	sl, r2
        if (first_draw)
600037bc:	781a      	ldrb	r2, [r3, #0]
        {
600037be:	4606      	mov	r6, r0
600037c0:	460d      	mov	r5, r1
        if (first_draw)
600037c2:	b12a      	cbz	r2, 600037d0 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x1c>
            { // first time we draw: restart cursor timer
            first_draw = false; // only do this once
600037c4:	2200      	movs	r2, #0
600037c6:	701a      	strb	r2, [r3, #0]
600037c8:	4b48      	ldr	r3, [pc, #288]	; (600038ec <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x138>)
600037ca:	681b      	ldr	r3, [r3, #0]
600037cc:	f8c0 3304 	str.w	r3, [r0, #772]	; 0x304
            _em = 0;
            }
        const int cx = _cx;
600037d0:	68b7      	ldr	r7, [r6, #8]
        const int cy = _cy;
        for (int j = 0; j < TFT_CONSOLE_CHAR_LY; j++)
600037d2:	f04f 0900 	mov.w	r9, #0
        const int cy = _cy;
600037d6:	68f4      	ldr	r4, [r6, #12]
            {
            for (int i = 0; i < TFT_CONSOLE_CHAR_LX; i++)
600037d8:	f04f 0800 	mov.w	r8, #0
                {

                _drawChar(im, i, j, 1.0f); // draw the character at (i,j)
600037dc:	4642      	mov	r2, r8
            for (int i = 0; i < TFT_CONSOLE_CHAR_LX; i++)
600037de:	f108 0801 	add.w	r8, r8, #1
                _drawChar(im, i, j, 1.0f); // draw the character at (i,j)
600037e2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
600037e6:	464b      	mov	r3, r9
600037e8:	4629      	mov	r1, r5
600037ea:	4630      	mov	r0, r6
600037ec:	f7ff ff78 	bl	600036e0 <Console::TFTConsole::_drawChar(tgx::Image<tgx::RGB565>&, int, int, float)>
            for (int i = 0; i < TFT_CONSOLE_CHAR_LX; i++)
600037f0:	f1b8 0f19 	cmp.w	r8, #25
600037f4:	d1f2      	bne.n	600037dc <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x28>
        for (int j = 0; j < TFT_CONSOLE_CHAR_LY; j++)
600037f6:	f109 0901 	add.w	r9, r9, #1
600037fa:	f1b9 0f0a 	cmp.w	r9, #10
600037fe:	d1eb      	bne.n	600037d8 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x24>
                }
            }
        if (force_cursor) { _em = 0; }
60003800:	4b3a      	ldr	r3, [pc, #232]	; (600038ec <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x138>)
60003802:	f1ba 0f00 	cmp.w	sl, #0
60003806:	d002      	beq.n	6000380e <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x5a>
60003808:	681a      	ldr	r2, [r3, #0]
6000380a:	f8c6 2304 	str.w	r2, [r6, #772]	; 0x304
	operator unsigned long () const { return millis() - ms; }
6000380e:	f8d6 2304 	ldr.w	r2, [r6, #772]	; 0x304
60003812:	681b      	ldr	r3, [r3, #0]
60003814:	1a9b      	subs	r3, r3, r2
        const bool cursor_visible = ((_em % (TFT_CONSOLE_CURSOR_ON_MS + TFT_CONSOLE_CURSOR_OFF_MS)) < TFT_CONSOLE_CURSOR_ON_MS);
60003816:	f44f 7261 	mov.w	r2, #900	; 0x384
6000381a:	fbb3 f1f2 	udiv	r1, r3, r2
6000381e:	fb02 3311 	mls	r3, r2, r1, r3
        if ((cursor_visible)&&(_cursor_on))
60003822:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
60003826:	d246      	bcs.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
60003828:	f896 3300 	ldrb.w	r3, [r6, #768]	; 0x300
6000382c:	2b00      	cmp	r3, #0
6000382e:	d042      	beq.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
60003830:	6829      	ldr	r1, [r5, #0]
        if (!isValid()) return;
60003832:	2900      	cmp	r1, #0
60003834:	d03f      	beq.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
        /**
         * Return the image dimension as a box.
         *
         * @returns a box of the form {0, width-1, 0 height-1 } or an empty box if the image is invalid.
         */
        inline TGX_INLINE iBox2 imageBox() const { return iBox2(0, _lx - 1, 0, _ly - 1); }
60003836:	e9d5 3201 	ldrd	r3, r2, [r5, #4]


        /** 
        * Return true if the box is empty. 
        */
        constexpr inline bool isEmpty() const { return ((maxX < minX) || (maxY < minY)); }
6000383a:	1e58      	subs	r0, r3, #1
6000383c:	f102 3cff 	add.w	ip, r2, #4294967295
60003840:	d439      	bmi.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
60003842:	f1bc 0f00 	cmp.w	ip, #0
60003846:	db36      	blt.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
            {
            im.fillRect({ TFT_CONSOLE_CURSOR_OFF_X + (TFT_CONSOLE_FONT_WIDTH * cx), TFT_CONSOLE_CURSOR_OFF_X + (TFT_CONSOLE_FONT_WIDTH * cx) + TFT_CONSOLE_CURSOR_LX,
60003848:	220c      	movs	r2, #12
                          TFT_CONSOLE_CURSOR_OFF_Y + (TFT_CONSOLE_FONT_HEIGHT * cy), TFT_CONSOLE_CURSOR_OFF_Y + (TFT_CONSOLE_FONT_HEIGHT * cy) + TFT_CONSOLE_CURSOR_LY }, _currentcolor, 1.0f);
6000384a:	2314      	movs	r3, #20
            im.fillRect({ TFT_CONSOLE_CURSOR_OFF_X + (TFT_CONSOLE_FONT_WIDTH * cx), TFT_CONSOLE_CURSOR_OFF_X + (TFT_CONSOLE_FONT_WIDTH * cx) + TFT_CONSOLE_CURSOR_LX,
6000384c:	fb07 2202 	mla	r2, r7, r2, r2
                          TFT_CONSOLE_CURSOR_OFF_Y + (TFT_CONSOLE_FONT_HEIGHT * cy), TFT_CONSOLE_CURSOR_OFF_Y + (TFT_CONSOLE_FONT_HEIGHT * cy) + TFT_CONSOLE_CURSOR_LY }, _currentcolor, 1.0f);
60003850:	435c      	muls	r4, r3
60003852:	ea22 73e2 	bic.w	r3, r2, r2, asr #31
            im.fillRect({ TFT_CONSOLE_CURSOR_OFF_X + (TFT_CONSOLE_FONT_WIDTH * cx), TFT_CONSOLE_CURSOR_OFF_X + (TFT_CONSOLE_FONT_WIDTH * cx) + TFT_CONSOLE_CURSOR_LX,
60003856:	3208      	adds	r2, #8
60003858:	4282      	cmp	r2, r0
6000385a:	bfa8      	it	ge
6000385c:	4602      	movge	r2, r0
6000385e:	f104 002b 	add.w	r0, r4, #43	; 0x2b
60003862:	342e      	adds	r4, #46	; 0x2e
60003864:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
60003868:	4564      	cmp	r4, ip
6000386a:	bfa8      	it	ge
6000386c:	4664      	movge	r4, ip
6000386e:	4293      	cmp	r3, r2
60003870:	dc21      	bgt.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
60003872:	42a0      	cmp	r0, r4
60003874:	dc1f      	bgt.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
         */
        inline T lx() const 
            {
            if (std::is_integral<T>::value) // compiler optimize this away. 
                {
                return (maxX - minX + 1); // for integer, return the number of points
60003876:	1ad7      	subs	r7, r2, r3
        color_t * p = _buffer + TGX_CAST32(B.minX) + TGX_CAST32(B.minY) * TGX_CAST32(_stride);
60003878:	68ed      	ldr	r5, [r5, #12]
         */
        inline T ly() const
            {
            if (std::is_integral<T>::value) // compiler optimize this away. 
                {
                return (maxY - minY + 1); // for integer, return the number of points
6000387a:	1a24      	subs	r4, r4, r0
6000387c:	f8b6 62fe 	ldrh.w	r6, [r6, #766]	; 0x2fe
                return (maxX - minX + 1); // for integer, return the number of points
60003880:	f107 0c01 	add.w	ip, r7, #1
60003884:	fb00 3005 	mla	r0, r0, r5, r3
                return (maxY - minY + 1); // for integer, return the number of points
60003888:	3401      	adds	r4, #1
        if (sx == _stride) 
6000388a:	45ac      	cmp	ip, r5
        color_t * p = _buffer + TGX_CAST32(B.minX) + TGX_CAST32(B.minY) * TGX_CAST32(_stride);
6000388c:	eb01 0040 	add.w	r0, r1, r0, lsl #1
        if (sx == _stride) 
60003890:	d00d      	beq.n	600038ae <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0xfa>
                    p += (_stride - sx);
60003892:	eba5 050c 	sub.w	r5, r5, ip
60003896:	007b      	lsls	r3, r7, #1
60003898:	006d      	lsls	r5, r5, #1
6000389a:	eb05 0547 	add.w	r5, r5, r7, lsl #1
6000389e:	1c9f      	adds	r7, r3, #2
600038a0:	3502      	adds	r5, #2
                while (sy-- > 0)
600038a2:	2c00      	cmp	r4, #0
600038a4:	dd07      	ble.n	600038b6 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x102>
600038a6:	4681      	mov	r9, r0
600038a8:	eb07 0800 	add.w	r8, r7, r0
600038ac:	e016      	b.n	600038dc <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x128>
            int32_t len = TGX_CAST32(sy) * TGX_CAST32(_stride);
600038ae:	fb0c f404 	mul.w	r4, ip, r4
                while (len-- > 0) { (*(p++)).blend(color, opacity); }
600038b2:	2c00      	cmp	r4, #0
600038b4:	dc01      	bgt.n	600038ba <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x106>
            }
        }
600038b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
600038ba:	1c85      	adds	r5, r0, #2
            blend256(fg_col, (uint32_t)(alpha * 256));
600038bc:	f44f 7280 	mov.w	r2, #256	; 0x100
600038c0:	4631      	mov	r1, r6
600038c2:	3c01      	subs	r4, #1
600038c4:	f037 fec0 	bl	6003b648 <___ZN3tgx6RGB5658blend256ERKS0_m.isra.0_veneer>
600038c8:	4628      	mov	r0, r5
600038ca:	e7f2      	b.n	600038b2 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0xfe>
                    while (len-- > 0) { (*(p++)).blend(color, opacity); }
600038cc:	f100 0a02 	add.w	sl, r0, #2
600038d0:	f44f 7280 	mov.w	r2, #256	; 0x100
600038d4:	4631      	mov	r1, r6
600038d6:	f037 feb7 	bl	6003b648 <___ZN3tgx6RGB5658blend256ERKS0_m.isra.0_veneer>
600038da:	4650      	mov	r0, sl
600038dc:	4540      	cmp	r0, r8
600038de:	d1f5      	bne.n	600038cc <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0x118>
600038e0:	eb05 0009 	add.w	r0, r5, r9
600038e4:	3c01      	subs	r4, #1
600038e6:	e7dc      	b.n	600038a2 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)+0xee>
600038e8:	2000cfbd 	.word	0x2000cfbd
600038ec:	2001a5d4 	.word	0x2001a5d4

600038f0 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)>:
        {        
600038f0:	b082      	sub	sp, #8
600038f2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
600038f6:	ed2d 8b02 	vpush	{d8}
600038fa:	b08f      	sub	sp, #60	; 0x3c
600038fc:	4690      	mov	r8, r2
600038fe:	2400      	movs	r4, #0
60003900:	ad1a      	add	r5, sp, #104	; 0x68
60003902:	af06      	add	r7, sp, #24
60003904:	f845 3f04 	str.w	r3, [r5, #4]!
        inline TGX_INLINE int ly() const { return _ly; }
60003908:	e9d2 2301 	ldrd	r2, r3, [r2, #4]
6000390c:	e887 0003 	stmia.w	r7, {r0, r1}
60003910:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
        if (!_blitClip(sprite, dest_x, dest_y, sprite_x, sprite_y, sx, sy)) return;
60003914:	ab0d      	add	r3, sp, #52	; 0x34
60003916:	aa08      	add	r2, sp, #32
60003918:	4641      	mov	r1, r8
6000391a:	4628      	mov	r0, r5
6000391c:	9303      	str	r3, [sp, #12]
6000391e:	ab0c      	add	r3, sp, #48	; 0x30
60003920:	9302      	str	r3, [sp, #8]
60003922:	ab0b      	add	r3, sp, #44	; 0x2c
60003924:	9301      	str	r3, [sp, #4]
60003926:	ab0a      	add	r3, sp, #40	; 0x28
60003928:	9300      	str	r3, [sp, #0]
6000392a:	ab09      	add	r3, sp, #36	; 0x24
6000392c:	e9cd 4408 	strd	r4, r4, [sp, #32]
60003930:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
60003934:	f037 fe00 	bl	6003b538 <___ZN3tgx5ImageINS_6RGB565EE9_blitClipIS1_EEbRKNS0_IT_EERiS8_S8_S8_S8_S8__veneer>
60003938:	bb00      	cbnz	r0, 6000397c <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x8c>
        UI::drawMainUI(im_dest);
6000393a:	4628      	mov	r0, r5
6000393c:	f00d fcaa 	bl	60011294 <UI::drawMainUI(tgx::Image<tgx::RGB565>&)>
        UI::drawUIactivity(im_dest, act); // draw the current activity bar
60003940:	4628      	mov	r0, r5
60003942:	e897 0006 	ldmia.w	r7, {r1, r2}
60003946:	f037 fc0f 	bl	6003b168 <___ZN2UI14drawUIactivityERN3tgx5ImageINS0_6RGB565EEENS0_4Vec2IiEE_veneer>
        UI::drawUIvoltage(im_dest, FBSensors::getVoltage(), FBSensors::getChargingCurrent()); // draw the voltage/charge status
6000394a:	f037 fe4d 	bl	6003b5e8 <___ZN9FBSensors10getVoltageEv_veneer>
6000394e:	eeb0 8a40 	vmov.f32	s16, s0
60003952:	f037 ffb1 	bl	6003b8b8 <___ZN9FBSensors18getChargingCurrentEv_veneer>
60003956:	4628      	mov	r0, r5
60003958:	eef0 0a40 	vmov.f32	s1, s0
6000395c:	eeb0 0a48 	vmov.f32	s0, s16
60003960:	f037 fe76 	bl	6003b650 <___ZN2UI13drawUIvoltageERN3tgx5ImageINS0_6RGB565EEEff_veneer>
        Console::console.draw(im_dest); // draw the text of the console on the image
60003964:	2200      	movs	r2, #0
60003966:	4629      	mov	r1, r5
60003968:	482b      	ldr	r0, [pc, #172]	; (60003a18 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x128>)
6000396a:	f7ff ff23 	bl	600037b4 <Console::TFTConsole::draw(tgx::Image<tgx::RGB565>&, bool)>
        }
6000396e:	b00f      	add	sp, #60	; 0x3c
60003970:	ecbd 8b02 	vpop	{d8}
60003974:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003978:	b002      	add	sp, #8
6000397a:	4770      	bx	lr
        _blitRegion(_buffer + TGX_CAST32(dest_y) * TGX_CAST32(_stride) + TGX_CAST32(dest_x), _stride, sprite._buffer + TGX_CAST32(sprite_y) * TGX_CAST32(sprite._stride) + TGX_CAST32(sprite_x), sprite._stride, sx, sy);
6000397c:	e9dd 3208 	ldrd	r3, r2, [sp, #32]
60003980:	9e1e      	ldr	r6, [sp, #120]	; 0x78
60003982:	981b      	ldr	r0, [sp, #108]	; 0x6c
60003984:	fb02 3306 	mla	r3, r2, r6, r3
60003988:	f8d8 c00c 	ldr.w	ip, [r8, #12]
6000398c:	eb00 0043 	add.w	r0, r0, r3, lsl #1
60003990:	e9dd 320a 	ldrd	r3, r2, [sp, #40]	; 0x28
60003994:	fb02 330c 	mla	r3, r2, ip, r3
60003998:	f8d8 2000 	ldr.w	r2, [r8]
6000399c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
600039a0:	e9dd 920c 	ldrd	r9, r2, [sp, #48]	; 0x30

        template<typename color_t_src> bool _blitClip(const Image<color_t_src>& sprite, int& dest_x, int& dest_y, int& sprite_x, int& sprite_y, int& sx, int& sy);
        bool _blitClip(int sprite_lx, int sprite_ly, int& dest_x, int& dest_y, int& sprite_x, int& sprite_y, int& sx, int& sy);

        void _blit(const Image& sprite, int dest_x, int dest_y, int sprite_x, int sprite_y, int sx, int sy);
        static void _blitRegion(color_t* pdest, int dest_stride, color_t* psrc, int src_stride, int sx, int sy) { if ((size_t)pdest <= (size_t)psrc) _blitRegionUp(pdest, dest_stride, psrc, src_stride, sx, sy); else _blitRegionDown(pdest, dest_stride, psrc, src_stride, sx, sy); }
600039a4:	4298      	cmp	r0, r3
600039a6:	9205      	str	r2, [sp, #20]
600039a8:	d817      	bhi.n	600039da <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0xea>
600039aa:	46a6      	mov	lr, r4
        for (int j = 0; j < sy; j++)
600039ac:	4621      	mov	r1, r4
600039ae:	9a05      	ldr	r2, [sp, #20]
600039b0:	428a      	cmp	r2, r1
600039b2:	ddc2      	ble.n	6000393a <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x4a>
600039b4:	eb03 0b4e 	add.w	fp, r3, lr, lsl #1
            for (int i = 0; i < sx; i++) { pdest2[i] = psrc2[i]; }
600039b8:	f04f 0800 	mov.w	r8, #0
600039bc:	eb00 0244 	add.w	r2, r0, r4, lsl #1
600039c0:	45c1      	cmp	r9, r8
600039c2:	dc03      	bgt.n	600039cc <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0xdc>
        for (int j = 0; j < sy; j++)
600039c4:	3101      	adds	r1, #1
600039c6:	44e6      	add	lr, ip
600039c8:	4434      	add	r4, r6
600039ca:	e7f0      	b.n	600039ae <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0xbe>
            for (int i = 0; i < sx; i++) { pdest2[i] = psrc2[i]; }
600039cc:	f83b ab02 	ldrh.w	sl, [fp], #2
600039d0:	f108 0801 	add.w	r8, r8, #1
600039d4:	f822 ab02 	strh.w	sl, [r2], #2
600039d8:	e7f2      	b.n	600039c0 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0xd0>
        for (int j = sy - 1; j >= 0; j--)
600039da:	9a05      	ldr	r2, [sp, #20]
600039dc:	f06f 0101 	mvn.w	r1, #1
600039e0:	3a01      	subs	r2, #1
600039e2:	fb01 f40c 	mul.w	r4, r1, ip
600039e6:	fb02 fc0c 	mul.w	ip, r2, ip
600039ea:	eb03 034c 	add.w	r3, r3, ip, lsl #1
600039ee:	fb01 fc06 	mul.w	ip, r1, r6
600039f2:	4356      	muls	r6, r2
600039f4:	eb00 0046 	add.w	r0, r0, r6, lsl #1
600039f8:	2a00      	cmp	r2, #0
600039fa:	db9e      	blt.n	6000393a <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x4a>
            for (int i = sx - 1; i >= 0; i--) { pdest2[i] = psrc2[i]; }
600039fc:	f109 31ff 	add.w	r1, r9, #4294967295
60003a00:	2900      	cmp	r1, #0
60003a02:	da03      	bge.n	60003a0c <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x11c>
        for (int j = sy - 1; j >= 0; j--)
60003a04:	3a01      	subs	r2, #1
60003a06:	4423      	add	r3, r4
60003a08:	4460      	add	r0, ip
60003a0a:	e7f5      	b.n	600039f8 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x108>
            for (int i = sx - 1; i >= 0; i--) { pdest2[i] = psrc2[i]; }
60003a0c:	f833 6011 	ldrh.w	r6, [r3, r1, lsl #1]
60003a10:	f820 6011 	strh.w	r6, [r0, r1, lsl #1]
60003a14:	3901      	subs	r1, #1
60003a16:	e7f3      	b.n	60003a00 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)+0x110>
60003a18:	20018e1c 	.word	0x20018e1c

60003a1c <Console::drawFromBlank(tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)>:
        {        
60003a1c:	b084      	sub	sp, #16
60003a1e:	b530      	push	{r4, r5, lr}
60003a20:	b087      	sub	sp, #28
60003a22:	4605      	mov	r5, r0
        drawFromBlankActivity(MAX98357A::activityLevel(), im_ui_blank, im_dest);
60003a24:	ac04      	add	r4, sp, #16
        {        
60003a26:	a80b      	add	r0, sp, #44	; 0x2c
60003a28:	e880 000e 	stmia.w	r0, {r1, r2, r3}
        drawFromBlankActivity(MAX98357A::activityLevel(), im_ui_blank, im_dest);
60003a2c:	4620      	mov	r0, r4
60003a2e:	f7fe fc6f 	bl	60002310 <MAX98357A::activityLevel()>
60003a32:	ab0c      	add	r3, sp, #48	; 0x30
60003a34:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
60003a38:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
60003a3a:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
60003a3e:	462a      	mov	r2, r5
60003a40:	e894 0003 	ldmia.w	r4, {r0, r1}
60003a44:	f7ff ff54 	bl	600038f0 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)>
        }
60003a48:	b007      	add	sp, #28
60003a4a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
60003a4e:	b004      	add	sp, #16
60003a50:	4770      	bx	lr

60003a52 <Console::drawFromBlank(tgx::Image<tgx::RGB565> const&)>:
        drawFromBlank(im_ui_blank, Display::image_main);
60003a52:	4b05      	ldr	r3, [pc, #20]	; (60003a68 <Console::drawFromBlank(tgx::Image<tgx::RGB565> const&)+0x16>)
        {
60003a54:	b507      	push	{r0, r1, r2, lr}
        drawFromBlank(im_ui_blank, Display::image_main);
60003a56:	68da      	ldr	r2, [r3, #12]
60003a58:	9200      	str	r2, [sp, #0]
60003a5a:	cb0e      	ldmia	r3, {r1, r2, r3}
60003a5c:	f7ff ffde 	bl	60003a1c <Console::drawFromBlank(tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)>
        }
60003a60:	b003      	add	sp, #12
60003a62:	f85d fb04 	ldr.w	pc, [sp], #4
60003a66:	bf00      	nop
60003a68:	20019184 	.word	0x20019184

60003a6c <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&)>:
        {
60003a6c:	b570      	push	{r4, r5, r6, lr}
        drawFromBlankActivity(act, im_ui_blank, Display::image_main);
60003a6e:	4d09      	ldr	r5, [pc, #36]	; (60003a94 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&)+0x28>)
        {
60003a70:	b086      	sub	sp, #24
60003a72:	4616      	mov	r6, r2
60003a74:	ac04      	add	r4, sp, #16
        drawFromBlankActivity(act, im_ui_blank, Display::image_main);
60003a76:	1d2b      	adds	r3, r5, #4
        {
60003a78:	e884 0003 	stmia.w	r4, {r0, r1}
        drawFromBlankActivity(act, im_ui_blank, Display::image_main);
60003a7c:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
60003a80:	682b      	ldr	r3, [r5, #0]
60003a82:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
60003a86:	4632      	mov	r2, r6
60003a88:	e894 0003 	ldmia.w	r4, {r0, r1}
60003a8c:	f7ff ff30 	bl	600038f0 <Console::drawFromBlankActivity(tgx::Vec2<int>, tgx::Image<tgx::RGB565> const&, tgx::Image<tgx::RGB565>)>
        }
60003a90:	b006      	add	sp, #24
60003a92:	bd70      	pop	{r4, r5, r6, pc}
60003a94:	20019184 	.word	0x20019184

60003a98 <CubeRead::_playIntroCube(int)>:
    const float CUBE_3D_INTRO_NB_TURN = 1;


    SLOWFUN static void _playIntroCube(int em)
        {
        float r = ((int)em) / ((float)CUBE_3D_INTRO_MS);
60003a98:	ee07 0a90 	vmov	s15, r0
60003a9c:	ed9f 7a56 	vldr	s14, [pc, #344]	; 60003bf8 <CubeRead::_playIntroCube(int)+0x160>
60003aa0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        {
60003aa4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
60003aa8:	ed2d 8b04 	vpush	{d8-d9}
        float r = ((int)em) / ((float)CUBE_3D_INTRO_MS);
60003aac:	ee87 8a87 	vdiv.f32	s16, s15, s14
        if (r < 0.01f) r = 0.01f;
60003ab0:	eddf 7a52 	vldr	s15, [pc, #328]	; 60003bfc <CubeRead::_playIntroCube(int)+0x164>
        {
60003ab4:	b0b1      	sub	sp, #196	; 0xc4
60003ab6:	eef7 9a00 	vmov.f32	s19, #112	; 0x3f800000  1.0
        if (r < 0.01f) r = 0.01f;
60003aba:	eeb4 8ae7 	vcmpe.f32	s16, s15
60003abe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60003ac2:	f100 8096 	bmi.w	60003bf2 <CubeRead::_playIntroCube(int)+0x15a>
        if (r > 1.0f) r = 1.0f;
60003ac6:	eeb4 8a69 	vcmp.f32	s16, s19
60003aca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
60003ace:	fe39 8a88 	vselgt.f32	s16, s19, s16
         *
         * @param   x,y,z   scale factors along the x, y, and z axes respectively.   
        **/
        void setScale(T x, T y, T z)
            {
            memset(M, 0, 16 * sizeof(T));
60003ad2:	2238      	movs	r2, #56	; 0x38
60003ad4:	2100      	movs	r1, #0
60003ad6:	a801      	add	r0, sp, #4
60003ad8:	ad10      	add	r5, sp, #64	; 0x40
60003ada:	f037 fb2d 	bl	6003b138 <__memset_veneer>
        const float rot = (360 * CUBE_3D_INTRO_NB_TURN * r);
60003ade:	eddf 7a48 	vldr	s15, [pc, #288]	; 60003c00 <CubeRead::_playIntroCube(int)+0x168>
            M[0] = x;
60003ae2:	ed8d 8a00 	vstr	s16, [sp]
            M[5] = y;
60003ae6:	ed8d 8a05 	vstr	s16, [sp, #20]
            M[10] = z;
60003aea:	ed8d 8a0a 	vstr	s16, [sp, #40]	; 0x28
60003aee:	ee28 8a27 	vmul.f32	s16, s16, s15
            const T c = cos(deg2rad * angle);
60003af2:	eddf 7a44 	vldr	s15, [pc, #272]	; 60003c04 <CubeRead::_playIntroCube(int)+0x16c>
            M[15] = (T)1;
60003af6:	edcd 9a0f 	vstr	s19, [sp, #60]	; 0x3c
            const T c = cos(deg2rad * angle);
60003afa:	ee28 8a27 	vmul.f32	s16, s16, s15
  { return __builtin_cosf(__x); }
60003afe:	eeb0 0a48 	vmov.f32	s0, s16
60003b02:	f037 fc71 	bl	6003b3e8 <__cosf_veneer>
            const T oneminusc = ((T)1) - c;
60003b06:	ee39 9ac0 	vsub.f32	s18, s19, s0
60003b0a:	eef0 8a40 	vmov.f32	s17, s0
  using ::sin;

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
  inline _GLIBCXX_CONSTEXPR float
  sin(float __x)
  { return __builtin_sinf(__x); }
60003b0e:	eeb0 0a48 	vmov.f32	s0, s16
60003b12:	f037 fa55 	bl	6003afc0 <__sinf_veneer>
            memset(M, 0, 16 * sizeof(T));
60003b16:	2230      	movs	r2, #48	; 0x30
60003b18:	eeb0 8a40 	vmov.f32	s16, s0
60003b1c:	2100      	movs	r1, #0
60003b1e:	a813      	add	r0, sp, #76	; 0x4c
60003b20:	f037 fb0a 	bl	6003b138 <__memset_veneer>
            M[0] = nx * nx * oneminusc + c;
60003b24:	eddf 7a38 	vldr	s15, [pc, #224]	; 60003c08 <CubeRead::_playIntroCube(int)+0x170>
60003b28:	eef0 6a68 	vmov.f32	s13, s17
60003b2c:	aa20      	add	r2, sp, #128	; 0x80
            M[1] = ny * nx * oneminusc + nz * s;
60003b2e:	ee28 7a27 	vmul.f32	s14, s16, s15
    * Matrix-matrix multiplication 
    */
    template<typename T> inline Mat4<T> operator*(const Mat4<T> & A, const Mat4<T> & B)
        {
        Mat4<T> R; 
        for (int i = 0; i < 4; i++)
60003b32:	2000      	movs	r0, #0
            M[2] = nx * nz * oneminusc - ny * s;
60003b34:	eef0 5a48 	vmov.f32	s11, s16
60003b38:	4614      	mov	r4, r2
            M[0] = nx * nx * oneminusc + c;
60003b3a:	eee9 6a27 	vfma.f32	s13, s18, s15
            M[15] = (T)1;
60003b3e:	edcd 9a1f 	vstr	s19, [sp, #124]	; 0x7c
            M[1] = ny * nx * oneminusc + nz * s;
60003b42:	eeb0 6a47 	vmov.f32	s12, s14
            M[2] = nx * nz * oneminusc - ny * s;
60003b46:	eed9 5a27 	vfnms.f32	s11, s18, s15
            M[4] = nx * ny * oneminusc - nz * s;
60003b4a:	ee99 7a27 	vfnms.f32	s14, s18, s15
            M[1] = ny * nx * oneminusc + nz * s;
60003b4e:	eea9 6a27 	vfma.f32	s12, s18, s15
            M[8] = nx * nz * oneminusc + ny * s;
60003b52:	eea9 8a27 	vfma.f32	s16, s18, s15
            M[5] = ny * ny * oneminusc + c;
60003b56:	ee78 8a89 	vadd.f32	s17, s17, s18
            M[0] = nx * nx * oneminusc + c;
60003b5a:	edcd 6a10 	vstr	s13, [sp, #64]	; 0x40
            M[10] = nz * nz * oneminusc + c;
60003b5e:	edcd 6a1a 	vstr	s13, [sp, #104]	; 0x68
            M[2] = nx * nz * oneminusc - ny * s;
60003b62:	edcd 5a12 	vstr	s11, [sp, #72]	; 0x48
            M[4] = nx * ny * oneminusc - nz * s;
60003b66:	ed8d 7a14 	vstr	s14, [sp, #80]	; 0x50
            M[1] = ny * nx * oneminusc + nz * s;
60003b6a:	ed8d 6a11 	vstr	s12, [sp, #68]	; 0x44
            M[5] = ny * ny * oneminusc + c;
60003b6e:	edcd 8a15 	vstr	s17, [sp, #84]	; 0x54
            M[6] = ny * nz * oneminusc + nx * s;
60003b72:	ed8d 6a16 	vstr	s12, [sp, #88]	; 0x58
            M[8] = nx * nz * oneminusc + ny * s;
60003b76:	ed8d 8a18 	vstr	s16, [sp, #96]	; 0x60
            M[9] = ny * nz * oneminusc - nx * s;
60003b7a:	ed8d 7a19 	vstr	s14, [sp, #100]	; 0x64
            {
            for (int j = 0; j < 4; j++)
60003b7e:	466b      	mov	r3, sp
        if (r < 0.01f) r = 0.01f;
60003b80:	4694      	mov	ip, r2
60003b82:	2100      	movs	r1, #0
60003b84:	461f      	mov	r7, r3
60003b86:	4698      	mov	r8, r3
60003b88:	46ae      	mov	lr, r5
60003b8a:	eddf 7a1f 	vldr	s15, [pc, #124]	; 60003c08 <CubeRead::_playIntroCube(int)+0x170>
                {
                R.M[i + j*4] = (T)0;
                for (int k = 0; k < 4; k++) { R.M[i + j * 4] += A.M[i + k * 4] * B.M[k + j * 4]; }
60003b8e:	2600      	movs	r6, #0
60003b90:	46f1      	mov	r9, lr
60003b92:	3601      	adds	r6, #1
60003b94:	ecb8 7a01 	vldmia	r8!, {s14}
60003b98:	f10e 0e10 	add.w	lr, lr, #16
60003b9c:	edd9 6a00 	vldr	s13, [r9]
60003ba0:	2e04      	cmp	r6, #4
60003ba2:	eee6 7a87 	vfma.f32	s15, s13, s14
60003ba6:	d1f3      	bne.n	60003b90 <CubeRead::_playIntroCube(int)+0xf8>
            for (int j = 0; j < 4; j++)
60003ba8:	3104      	adds	r1, #4
60003baa:	4666      	mov	r6, ip
60003bac:	3310      	adds	r3, #16
60003bae:	f10c 0c10 	add.w	ip, ip, #16
60003bb2:	2910      	cmp	r1, #16
60003bb4:	edc6 7a00 	vstr	s15, [r6]
60003bb8:	d1e5      	bne.n	60003b86 <CubeRead::_playIntroCube(int)+0xee>
        for (int i = 0; i < 4; i++)
60003bba:	3001      	adds	r0, #1
60003bbc:	3504      	adds	r5, #4
60003bbe:	3204      	adds	r2, #4
60003bc0:	2804      	cmp	r0, #4
60003bc2:	d1dc      	bne.n	60003b7e <CubeRead::_playIntroCube(int)+0xe6>
            *this = (mat * (*this));
60003bc4:	463d      	mov	r5, r7
60003bc6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
60003bc8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
60003bca:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
60003bcc:	c50f      	stmia	r5!, {r0, r1, r2, r3}
60003bce:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
60003bd0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
60003bd2:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
60003bd6:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}
        tgx::fMat4 M;
        M.setScale(r, r, r);
        M.multRotate(rot, { 0.0f, 1.0f, 0.0f });
        graphics3D::updateAll(1, 0, &M);
60003bda:	463a      	mov	r2, r7
60003bdc:	2100      	movs	r1, #0
60003bde:	2001      	movs	r0, #1
60003be0:	f004 f97a 	bl	60007ed8 <graphics3D::updateAll(int, int, tgx::Mat4<float> const*)>
        threads.yield();
60003be4:	f037 f9d8 	bl	6003af98 <___ZN7Threads5yieldEv_veneer>
        }
60003be8:	b031      	add	sp, #196	; 0xc4
60003bea:	ecbd 8b04 	vpop	{d8-d9}
60003bee:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        if (r < 0.01f) r = 0.01f;
60003bf2:	eeb0 8a67 	vmov.f32	s16, s15
60003bf6:	e76c      	b.n	60003ad2 <CubeRead::_playIntroCube(int)+0x3a>
60003bf8:	44480000 	.word	0x44480000
60003bfc:	3c23d70a 	.word	0x3c23d70a
60003c00:	43b40000 	.word	0x43b40000
60003c04:	3c8efa35 	.word	0x3c8efa35
60003c08:	00000000 	.word	0x00000000

60003c0c <CubeState::CubeMove::set(char const*)>:



	SLOWFUN const char* CubeMove::set(const char* str)
		{
		if (str == nullptr) { setInvalid();  return nullptr; }
60003c0c:	b929      	cbnz	r1, 60003c1a <CubeState::CubeMove::set(char const*)+0xe>

			/** Check if a move is valid */
			bool valid() const { return (_m[0] != '?'); }

			/** set the move as invalid */
            void setInvalid() { _m[0] = '?'; _m[1] = 0; _m[2] = 0; } 
60003c0e:	233f      	movs	r3, #63	; 0x3f
60003c10:	7003      	strb	r3, [r0, #0]
60003c12:	7041      	strb	r1, [r0, #1]
60003c14:	7081      	strb	r1, [r0, #2]
			case '\'': { str++; return str; }
			case '2':  { str++; return str; }
			}
		setInvalid(); 
		return nullptr;
		}
60003c16:	4608      	mov	r0, r1
60003c18:	4770      	bx	lr
		_m[0] = misc::uppercase(str[0]);
60003c1a:	780b      	ldrb	r3, [r1, #0]


    /** convert a char to uppercase */
    inline char uppercase(char c)
        {
        if ((c >= 'a') && (c <= 'z')) { c -= 32; }
60003c1c:	f1a3 0261 	sub.w	r2, r3, #97	; 0x61
60003c20:	2a19      	cmp	r2, #25
60003c22:	bf9c      	itt	ls
60003c24:	3b20      	subls	r3, #32
60003c26:	b2db      	uxtbls	r3, r3
		if ((_m[0] != 'U') && (_m[0] != 'R') && (_m[0] != 'F') && (_m[0] != 'D') && (_m[0] != 'L') && (_m[0] != 'B')) { setInvalid(); return nullptr; }
60003c28:	2b55      	cmp	r3, #85	; 0x55
		_m[0] = misc::uppercase(str[0]);
60003c2a:	7003      	strb	r3, [r0, #0]
		if ((_m[0] != 'U') && (_m[0] != 'R') && (_m[0] != 'F') && (_m[0] != 'D') && (_m[0] != 'L') && (_m[0] != 'B')) { setInvalid(); return nullptr; }
60003c2c:	d00c      	beq.n	60003c48 <CubeState::CubeMove::set(char const*)+0x3c>
60003c2e:	3b42      	subs	r3, #66	; 0x42
60003c30:	b2db      	uxtb	r3, r3
60003c32:	2b10      	cmp	r3, #16
60003c34:	d804      	bhi.n	60003c40 <CubeState::CubeMove::set(char const*)+0x34>
60003c36:	4a10      	ldr	r2, [pc, #64]	; (60003c78 <CubeState::CubeMove::set(char const*)+0x6c>)
60003c38:	fa22 f303 	lsr.w	r3, r2, r3
60003c3c:	07da      	lsls	r2, r3, #31
60003c3e:	d403      	bmi.n	60003c48 <CubeState::CubeMove::set(char const*)+0x3c>
60003c40:	233f      	movs	r3, #63	; 0x3f
60003c42:	2100      	movs	r1, #0
60003c44:	7003      	strb	r3, [r0, #0]
60003c46:	e7e4      	b.n	60003c12 <CubeState::CubeMove::set(char const*)+0x6>
		_m[1] = str[0];
60003c48:	784b      	ldrb	r3, [r1, #1]
		_m[2] = 0;
60003c4a:	2200      	movs	r2, #0
		_m[1] = str[0];
60003c4c:	7043      	strb	r3, [r0, #1]
		_m[2] = 0;
60003c4e:	7082      	strb	r2, [r0, #2]
		switch (_m[1])
60003c50:	b153      	cbz	r3, 60003c68 <CubeState::CubeMove::set(char const*)+0x5c>
60003c52:	3b20      	subs	r3, #32
60003c54:	b2db      	uxtb	r3, r3
60003c56:	2b12      	cmp	r3, #18
60003c58:	d808      	bhi.n	60003c6c <CubeState::CubeMove::set(char const*)+0x60>
60003c5a:	4a08      	ldr	r2, [pc, #32]	; (60003c7c <CubeState::CubeMove::set(char const*)+0x70>)
60003c5c:	fa22 f303 	lsr.w	r3, r2, r3
60003c60:	07db      	lsls	r3, r3, #31
60003c62:	d503      	bpl.n	60003c6c <CubeState::CubeMove::set(char const*)+0x60>
			case ' ':  { str++; return str; }
60003c64:	3102      	adds	r1, #2
60003c66:	e7d6      	b.n	60003c16 <CubeState::CubeMove::set(char const*)+0xa>
		str++;
60003c68:	3101      	adds	r1, #1
60003c6a:	e7d4      	b.n	60003c16 <CubeState::CubeMove::set(char const*)+0xa>
60003c6c:	233f      	movs	r3, #63	; 0x3f
60003c6e:	2100      	movs	r1, #0
60003c70:	7003      	strb	r3, [r0, #0]
60003c72:	7041      	strb	r1, [r0, #1]
		return nullptr;
60003c74:	e7cf      	b.n	60003c16 <CubeState::CubeMove::set(char const*)+0xa>
60003c76:	bf00      	nop
60003c78:	00010415 	.word	0x00010415
60003c7c:	00040081 	.word	0x00040081

60003c80 <CubeState::CubeState::isSolved() const>:
		*/



	SLOWFUN bool CubeState::isSolved() const 
		{
60003c80:	2300      	movs	r3, #0
		for (int i = 0; i < 6; i++)
			{
			int off = 9 * i;
			char c = _state[off];
			for (int j = 1; j < 9; j++)
60003c82:	f100 0108 	add.w	r1, r0, #8
		{
60003c86:	b570      	push	{r4, r5, r6, lr}
			char c = _state[off];
60003c88:	5cc5      	ldrb	r5, [r0, r3]
			for (int j = 1; j < 9; j++)
60003c8a:	181a      	adds	r2, r3, r0
60003c8c:	18cc      	adds	r4, r1, r3
				{
				if (_state[off + j] != c) return false;
60003c8e:	f812 6f01 	ldrb.w	r6, [r2, #1]!
60003c92:	42ae      	cmp	r6, r5
60003c94:	d106      	bne.n	60003ca4 <CubeState::CubeState::isSolved() const+0x24>
			for (int j = 1; j < 9; j++)
60003c96:	42a2      	cmp	r2, r4
60003c98:	d1f9      	bne.n	60003c8e <CubeState::CubeState::isSolved() const+0xe>
		for (int i = 0; i < 6; i++)
60003c9a:	3309      	adds	r3, #9
60003c9c:	2b36      	cmp	r3, #54	; 0x36
60003c9e:	d1f3      	bne.n	60003c88 <CubeState::CubeState::isSolved() const+0x8>
				}
			}
		return true;
60003ca0:	2001      	movs	r0, #1
		}
60003ca2:	bd70      	pop	{r4, r5, r6, pc}
				if (_state[off + j] != c) return false;
60003ca4:	2000      	movs	r0, #0
60003ca6:	e7fc      	b.n	60003ca2 <CubeState::CubeState::isSolved() const+0x22>

60003ca8 <CubeState::CubeState::_perm(int, int, int, int, int, int, int, int, int, int, int, int)>:
		}



	SLOWFUN void CubeState::_perm(int a1, int a2, int a3, int b1, int b2, int b3, int c1, int c2, int c3, int d1, int d2, int d3)
		{
60003ca8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
60003cac:	b08f      	sub	sp, #60	; 0x3c
60003cae:	4604      	mov	r4, r0
60003cb0:	460f      	mov	r7, r1
		char _prevstate[9 * 6];
		memcpy(_prevstate, _state, 9 * 6);
60003cb2:	4605      	mov	r5, r0
60003cb4:	466e      	mov	r6, sp
60003cb6:	f100 0b30 	add.w	fp, r0, #48	; 0x30
		{
60003cba:	e9dd 9818 	ldrd	r9, r8, [sp, #96]	; 0x60
60003cbe:	e9dd ec1a 	ldrd	lr, ip, [sp, #104]	; 0x68
		memcpy(_prevstate, _state, 9 * 6);
60003cc2:	6828      	ldr	r0, [r5, #0]
60003cc4:	3508      	adds	r5, #8
60003cc6:	f855 1c04 	ldr.w	r1, [r5, #-4]
60003cca:	46b2      	mov	sl, r6
60003ccc:	455d      	cmp	r5, fp
60003cce:	e8aa 0003 	stmia.w	sl!, {r0, r1}
60003cd2:	4656      	mov	r6, sl
60003cd4:	d1f5      	bne.n	60003cc2 <CubeState::CubeState::_perm(int, int, int, int, int, int, int, int, int, int, int, int)+0x1a>
60003cd6:	6828      	ldr	r0, [r5, #0]
60003cd8:	f8ca 0000 	str.w	r0, [sl]
60003cdc:	88a9      	ldrh	r1, [r5, #4]
60003cde:	f8aa 1004 	strh.w	r1, [sl, #4]

		_state[b1] = _prevstate[a1];
60003ce2:	f107 0138 	add.w	r1, r7, #56	; 0x38
		_state[b2] = _prevstate[a2];
		_state[b3] = _prevstate[a3];

		_state[c1] = _prevstate[b1];
		_state[c2] = _prevstate[b2];
60003ce6:	981c      	ldr	r0, [sp, #112]	; 0x70
		_state[b1] = _prevstate[a1];
60003ce8:	4469      	add	r1, sp
60003cea:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003cee:	f804 1009 	strb.w	r1, [r4, r9]
		_state[b2] = _prevstate[a2];
60003cf2:	f102 0138 	add.w	r1, r2, #56	; 0x38
60003cf6:	4469      	add	r1, sp
60003cf8:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003cfc:	f804 1008 	strb.w	r1, [r4, r8]
		_state[b3] = _prevstate[a3];
60003d00:	f103 0138 	add.w	r1, r3, #56	; 0x38
60003d04:	4469      	add	r1, sp
60003d06:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003d0a:	f804 100e 	strb.w	r1, [r4, lr]
		_state[c1] = _prevstate[b1];
60003d0e:	f109 0138 	add.w	r1, r9, #56	; 0x38
60003d12:	eb0d 0901 	add.w	r9, sp, r1
60003d16:	f819 1c38 	ldrb.w	r1, [r9, #-56]
60003d1a:	f804 100c 	strb.w	r1, [r4, ip]
		_state[c2] = _prevstate[b2];
60003d1e:	f108 0138 	add.w	r1, r8, #56	; 0x38
60003d22:	eb0d 0801 	add.w	r8, sp, r1
60003d26:	f818 1c38 	ldrb.w	r1, [r8, #-56]
60003d2a:	5421      	strb	r1, [r4, r0]
		_state[c3] = _prevstate[b3];
60003d2c:	f10e 0138 	add.w	r1, lr, #56	; 0x38
60003d30:	981d      	ldr	r0, [sp, #116]	; 0x74
60003d32:	eb0d 0e01 	add.w	lr, sp, r1
60003d36:	f81e 1c38 	ldrb.w	r1, [lr, #-56]
60003d3a:	5421      	strb	r1, [r4, r0]

		_state[d1] = _prevstate[c1];
60003d3c:	f10c 0138 	add.w	r1, ip, #56	; 0x38
60003d40:	981e      	ldr	r0, [sp, #120]	; 0x78
60003d42:	eb0d 0c01 	add.w	ip, sp, r1
60003d46:	f81c 1c38 	ldrb.w	r1, [ip, #-56]
60003d4a:	5421      	strb	r1, [r4, r0]
		_state[d2] = _prevstate[c2];
60003d4c:	991c      	ldr	r1, [sp, #112]	; 0x70
60003d4e:	981f      	ldr	r0, [sp, #124]	; 0x7c
60003d50:	3138      	adds	r1, #56	; 0x38
60003d52:	4469      	add	r1, sp
60003d54:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003d58:	5421      	strb	r1, [r4, r0]
		_state[d3] = _prevstate[c3];
60003d5a:	991d      	ldr	r1, [sp, #116]	; 0x74
60003d5c:	9820      	ldr	r0, [sp, #128]	; 0x80
60003d5e:	3138      	adds	r1, #56	; 0x38
60003d60:	4469      	add	r1, sp
60003d62:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003d66:	5421      	strb	r1, [r4, r0]

		_state[a1] = _prevstate[d1];
60003d68:	991e      	ldr	r1, [sp, #120]	; 0x78
60003d6a:	3138      	adds	r1, #56	; 0x38
60003d6c:	4469      	add	r1, sp
60003d6e:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003d72:	55e1      	strb	r1, [r4, r7]
		_state[a2] = _prevstate[d2];
60003d74:	991f      	ldr	r1, [sp, #124]	; 0x7c
60003d76:	3138      	adds	r1, #56	; 0x38
60003d78:	4469      	add	r1, sp
60003d7a:	f811 1c38 	ldrb.w	r1, [r1, #-56]
60003d7e:	54a1      	strb	r1, [r4, r2]
		_state[a3] = _prevstate[d3];
60003d80:	4602      	mov	r2, r0
60003d82:	3238      	adds	r2, #56	; 0x38
60003d84:	446a      	add	r2, sp
60003d86:	f812 2c38 	ldrb.w	r2, [r2, #-56]
60003d8a:	54e2      	strb	r2, [r4, r3]
		}
60003d8c:	b00f      	add	sp, #60	; 0x3c
60003d8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

60003d92 <CubeState::CubeState::make_move(CubeState::CubeMove)>:
		{
60003d92:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
60003d94:	b2cc      	uxtb	r4, r1
60003d96:	4605      	mov	r5, r0
60003d98:	9101      	str	r1, [sp, #4]
		if (mv.valid() == false) { ABORT("CubeState::make_move: invalid move"); }
60003d9a:	2c3f      	cmp	r4, #63	; 0x3f
60003d9c:	d12a      	bne.n	60003df4 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x62>
60003d9e:	f037 fe77 	bl	6003ba90 <___Z8is_panicv_veneer>
60003da2:	bb38      	cbnz	r0, 60003df4 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x62>
60003da4:	4964      	ldr	r1, [pc, #400]	; (60003f38 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1a6>)
60003da6:	4865      	ldr	r0, [pc, #404]	; (60003f3c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1aa>)
60003da8:	f037 ff3a 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60003dac:	4964      	ldr	r1, [pc, #400]	; (60003f40 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ae>)
60003dae:	f037 fa5f 	bl	6003b270 <___ZN5debug4CoutI17usb_serial2_classElsIA52_cEERS2_RKT__veneer>
60003db2:	4964      	ldr	r1, [pc, #400]	; (60003f44 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1b2>)
60003db4:	f037 ff34 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60003db8:	23b8      	movs	r3, #184	; 0xb8
60003dba:	a903      	add	r1, sp, #12
60003dbc:	9303      	str	r3, [sp, #12]
60003dbe:	f037 fb73 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60003dc2:	4961      	ldr	r1, [pc, #388]	; (60003f48 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1b6>)
60003dc4:	f037 fbdc 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60003dc8:	4606      	mov	r6, r0
                if (_serial) _serial->print(v);
60003dca:	6800      	ldr	r0, [r0, #0]
60003dcc:	b110      	cbz	r0, 60003dd4 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x42>
60003dce:	495f      	ldr	r1, [pc, #380]	; (60003f4c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ba>)
60003dd0:	f037 fd4e 	bl	6003b870 <___ZN5Print5printEPKc.isra.0_veneer>
60003dd4:	495e      	ldr	r1, [pc, #376]	; (60003f50 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1be>)
60003dd6:	4630      	mov	r0, r6
60003dd8:	f037 fd1a 	bl	6003b810 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60003ddc:	4b57      	ldr	r3, [pc, #348]	; (60003f3c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1aa>)
60003dde:	6818      	ldr	r0, [r3, #0]
60003de0:	f037 fcfa 	bl	6003b7d8 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
                print(v); 
60003de4:	4959      	ldr	r1, [pc, #356]	; (60003f4c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ba>)
60003de6:	485b      	ldr	r0, [pc, #364]	; (60003f54 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1c2>)
60003de8:	f037 fd42 	bl	6003b870 <___ZN5Print5printEPKc.isra.0_veneer>
60003dec:	f037 fd04 	bl	6003b7f8 <___Z9set_panicv_veneer>
60003df0:	f006 ff06 	bl	6000ac00 <hang()>
		switch (mv._m[1])
60003df4:	f89d 1005 	ldrb.w	r1, [sp, #5]
60003df8:	2927      	cmp	r1, #39	; 0x27
60003dfa:	d041      	beq.n	60003e80 <CubeState::CubeState::make_move(CubeState::CubeMove)+0xee>
60003dfc:	d811      	bhi.n	60003e22 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x90>
60003dfe:	f011 01df 	ands.w	r1, r1, #223	; 0xdf
60003e02:	d110      	bne.n	60003e26 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x94>
		switch (mv._m[0])
60003e04:	2c4c      	cmp	r4, #76	; 0x4c
60003e06:	d83f      	bhi.n	60003e88 <CubeState::CubeState::make_move(CubeState::CubeMove)+0xf6>
60003e08:	2c41      	cmp	r4, #65	; 0x41
60003e0a:	d965      	bls.n	60003ed8 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x146>
60003e0c:	3c42      	subs	r4, #66	; 0x42
60003e0e:	2c0a      	cmp	r4, #10
60003e10:	d862      	bhi.n	60003ed8 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x146>
60003e12:	e8df f004 	tbb	[pc, r4]
60003e16:	615b      	.short	0x615b
60003e18:	6149614f 	.word	0x6149614f
60003e1c:	61616161 	.word	0x61616161
60003e20:	55          	.byte	0x55
60003e21:	00          	.byte	0x00
		switch (mv._m[1])
60003e22:	2932      	cmp	r1, #50	; 0x32
60003e24:	d02e      	beq.n	60003e84 <CubeState::CubeState::make_move(CubeState::CubeMove)+0xf2>
			default: { ABORT("CubeState::make_move: parse error 1"); }
60003e26:	f037 fe33 	bl	6003ba90 <___Z8is_panicv_veneer>
60003e2a:	bb38      	cbnz	r0, 60003e7c <CubeState::CubeState::make_move(CubeState::CubeMove)+0xea>
60003e2c:	4942      	ldr	r1, [pc, #264]	; (60003f38 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1a6>)
60003e2e:	4843      	ldr	r0, [pc, #268]	; (60003f3c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1aa>)
60003e30:	f037 fef6 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60003e34:	4942      	ldr	r1, [pc, #264]	; (60003f40 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ae>)
60003e36:	f037 fa1b 	bl	6003b270 <___ZN5debug4CoutI17usb_serial2_classElsIA52_cEERS2_RKT__veneer>
60003e3a:	4942      	ldr	r1, [pc, #264]	; (60003f44 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1b2>)
60003e3c:	f037 fef0 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60003e40:	23c0      	movs	r3, #192	; 0xc0
60003e42:	a903      	add	r1, sp, #12
60003e44:	9303      	str	r3, [sp, #12]
60003e46:	f037 fb2f 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60003e4a:	493f      	ldr	r1, [pc, #252]	; (60003f48 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1b6>)
60003e4c:	f037 fb98 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60003e50:	4606      	mov	r6, r0
                if (_serial) _serial->print(v);
60003e52:	6800      	ldr	r0, [r0, #0]
60003e54:	b110      	cbz	r0, 60003e5c <CubeState::CubeState::make_move(CubeState::CubeMove)+0xca>
60003e56:	4940      	ldr	r1, [pc, #256]	; (60003f58 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1c6>)
60003e58:	f037 fd0a 	bl	6003b870 <___ZN5Print5printEPKc.isra.0_veneer>
60003e5c:	493c      	ldr	r1, [pc, #240]	; (60003f50 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1be>)
60003e5e:	4630      	mov	r0, r6
60003e60:	f037 fcd6 	bl	6003b810 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60003e64:	4b35      	ldr	r3, [pc, #212]	; (60003f3c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1aa>)
60003e66:	6818      	ldr	r0, [r3, #0]
60003e68:	f037 fcb6 	bl	6003b7d8 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
                print(v); 
60003e6c:	493a      	ldr	r1, [pc, #232]	; (60003f58 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1c6>)
60003e6e:	4839      	ldr	r0, [pc, #228]	; (60003f54 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1c2>)
60003e70:	f037 fcfe 	bl	6003b870 <___ZN5Print5printEPKc.isra.0_veneer>
60003e74:	f037 fcc0 	bl	6003b7f8 <___Z9set_panicv_veneer>
60003e78:	f006 fec2 	bl	6000ac00 <hang()>
		int type = 0;
60003e7c:	2100      	movs	r1, #0
60003e7e:	e7c1      	b.n	60003e04 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x72>
		switch (mv._m[1])
60003e80:	2101      	movs	r1, #1
60003e82:	e7bf      	b.n	60003e04 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x72>
			case '2': { type = 2; break; }
60003e84:	2102      	movs	r1, #2
60003e86:	e7bd      	b.n	60003e04 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x72>
		switch (mv._m[0])
60003e88:	2c52      	cmp	r4, #82	; 0x52
60003e8a:	d007      	beq.n	60003e9c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x10a>
60003e8c:	2c55      	cmp	r4, #85	; 0x55
60003e8e:	d123      	bne.n	60003ed8 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x146>
			case 'U': { _move_U(type); break; }
60003e90:	4628      	mov	r0, r5
		}
60003e92:	b004      	add	sp, #16
60003e94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			case 'U': { _move_U(type); break; }
60003e98:	f037 b96e 	b.w	6003b178 <___ZN9CubeState9CubeState7_move_UEi_veneer>
			case 'R': { _move_R(type); break; }
60003e9c:	4628      	mov	r0, r5
		}
60003e9e:	b004      	add	sp, #16
60003ea0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			case 'R': { _move_R(type); break; }
60003ea4:	f037 b9d0 	b.w	6003b248 <___ZN9CubeState9CubeState7_move_REi_veneer>
			case 'F': { _move_F(type); break; }
60003ea8:	4628      	mov	r0, r5
		}
60003eaa:	b004      	add	sp, #16
60003eac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			case 'F': { _move_F(type); break; }
60003eb0:	f037 bc86 	b.w	6003b7c0 <___ZN9CubeState9CubeState7_move_FEi_veneer>
			case 'D': { _move_D(type); break; }
60003eb4:	4628      	mov	r0, r5
		}
60003eb6:	b004      	add	sp, #16
60003eb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			case 'D': { _move_D(type); break; }
60003ebc:	f037 bcdc 	b.w	6003b878 <___ZN9CubeState9CubeState7_move_DEi_veneer>
			case 'L': { _move_L(type); break; }
60003ec0:	4628      	mov	r0, r5
		}
60003ec2:	b004      	add	sp, #16
60003ec4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			case 'L': { _move_L(type); break; }
60003ec8:	f037 bdee 	b.w	6003baa8 <___ZN9CubeState9CubeState7_move_LEi_veneer>
			case 'B': { _move_B(type); break; }
60003ecc:	4628      	mov	r0, r5
		}
60003ece:	b004      	add	sp, #16
60003ed0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			case 'B': { _move_B(type); break; }
60003ed4:	f037 b938 	b.w	6003b148 <___ZN9CubeState9CubeState7_move_BEi_veneer>
			default: { ABORT("CubeState::make_move: parse error 2"); }
60003ed8:	f037 fdda 	bl	6003ba90 <___Z8is_panicv_veneer>
60003edc:	bb50      	cbnz	r0, 60003f34 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1a2>
60003ede:	4916      	ldr	r1, [pc, #88]	; (60003f38 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1a6>)
60003ee0:	4816      	ldr	r0, [pc, #88]	; (60003f3c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1aa>)
60003ee2:	f037 fe9d 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60003ee6:	4916      	ldr	r1, [pc, #88]	; (60003f40 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ae>)
60003ee8:	f037 f9c2 	bl	6003b270 <___ZN5debug4CoutI17usb_serial2_classElsIA52_cEERS2_RKT__veneer>
60003eec:	4915      	ldr	r1, [pc, #84]	; (60003f44 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1b2>)
60003eee:	f037 fe97 	bl	6003bc20 <___ZN5debug4CoutI17usb_serial2_classElsIA7_cEERS2_RKT__veneer>
60003ef2:	23ca      	movs	r3, #202	; 0xca
60003ef4:	a903      	add	r1, sp, #12
60003ef6:	9303      	str	r3, [sp, #12]
60003ef8:	f037 fad6 	bl	6003b4a8 <___ZN5debug4CoutI17usb_serial2_classElsIiEERS2_RKT__veneer>
60003efc:	4912      	ldr	r1, [pc, #72]	; (60003f48 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1b6>)
60003efe:	f037 fb3f 	bl	6003b580 <___ZN5debug4CoutI17usb_serial2_classElsIA3_cEERS2_RKT__veneer>
60003f02:	4604      	mov	r4, r0
                if (_serial) _serial->print(v);
60003f04:	6800      	ldr	r0, [r0, #0]
60003f06:	b110      	cbz	r0, 60003f0e <CubeState::CubeState::make_move(CubeState::CubeMove)+0x17c>
60003f08:	4914      	ldr	r1, [pc, #80]	; (60003f5c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ca>)
60003f0a:	f037 fcb1 	bl	6003b870 <___ZN5Print5printEPKc.isra.0_veneer>
60003f0e:	4910      	ldr	r1, [pc, #64]	; (60003f50 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1be>)
60003f10:	4620      	mov	r0, r4
60003f12:	f037 fc7d 	bl	6003b810 <___ZN5debug4CoutI17usb_serial2_classElsIA2_cEERS2_RKT_.isra.0_veneer>
60003f16:	4b09      	ldr	r3, [pc, #36]	; (60003f3c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1aa>)
60003f18:	6818      	ldr	r0, [r3, #0]
60003f1a:	f037 fc5d 	bl	6003b7d8 <___ZN5debug4CoutI17usb_serial2_classE5flushEv.isra.0_veneer>
                print(v); 
60003f1e:	490f      	ldr	r1, [pc, #60]	; (60003f5c <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1ca>)
60003f20:	480c      	ldr	r0, [pc, #48]	; (60003f54 <CubeState::CubeState::make_move(CubeState::CubeMove)+0x1c2>)
60003f22:	f037 fca5 	bl	6003b870 <___ZN5Print5printEPKc.isra.0_veneer>
60003f26:	f037 fc67 	bl	6003b7f8 <___Z9set_panicv_veneer>
		}
60003f2a:	b004      	add	sp, #16
60003f2c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
			default: { ABORT("CubeState::make_move: parse error 2"); }
60003f30:	f006 be66 	b.w	6000ac00 <hang()>
		}
60003f34:	b004      	add	sp, #16
60003f36:	bd70      	pop	{r4, r5, r6, pc}
60003f38:	2000662d 	.word	0x2000662d
60003f3c:	2001546c 	.word	0x2001546c
60003f40:	20005807 	.word	0x20005807
60003f44:	2000666d 	.word	0x2000666d
60003f48:	20006674 	.word	0x20006674
60003f4c:	2000680f 	.word	0x2000680f
60003f50:	2000aaf4 	.word	0x2000aaf4
60003f54:	70000064 	.word	0x70000064
60003f58:	20006832 	.word	0x20006832
60003f5c:	20006856 	.word	0x20006856

60003f60 <debug::init(bool)>:
#endif



        SLOWFUN void init(bool wait_serial_ready)
            {
60003f60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            static int8_t _init_done = 0;
            if (_init_done) return;
60003f64:	4b22      	ldr	r3, [pc, #136]	; (60003ff0 <debug::init(bool)+0x90>)
60003f66:	f993 2000 	ldrsb.w	r2, [r3]
60003f6a:	2a00      	cmp	r2, #0
60003f6c:	d13d      	bne.n	60003fea <debug::init(bool)+0x8a>
            _init_done = 1;
60003f6e:	2201      	movs	r2, #1
60003f70:	4d20      	ldr	r5, [pc, #128]	; (60003ff4 <debug::init(bool)+0x94>)
60003f72:	701a      	strb	r2, [r3, #0]

            if (wait_serial_ready)
60003f74:	b198      	cbz	r0, 60003f9e <debug::init(bool)+0x3e>
        uint8_t numbits(void) { return usb_cdc2_line_coding[1] >> 16; }
        uint8_t dtr(void) { return (usb_cdc2_line_rtsdtr & USB_SERIAL_DTR) ? 1 : 0; }
        uint8_t rts(void) { return (usb_cdc2_line_rtsdtr & USB_SERIAL_RTS) ? 1 : 0; }
        operator bool() {
		yield();
		return usb_configuration && (usb_cdc2_line_rtsdtr & USB_SERIAL_DTR) &&
60003f76:	4c20      	ldr	r4, [pc, #128]	; (60003ff8 <debug::init(bool)+0x98>)
                ((uint32_t)(systick_millis_count - usb_cdc2_line_rtsdtr_millis) >= 15);
60003f78:	4e20      	ldr	r6, [pc, #128]	; (60003ffc <debug::init(bool)+0x9c>)
60003f7a:	4f21      	ldr	r7, [pc, #132]	; (60004000 <debug::init(bool)+0xa0>)
		yield();
60003f7c:	f037 fd84 	bl	6003ba88 <__yield_veneer>
		return usb_configuration && (usb_cdc2_line_rtsdtr & USB_SERIAL_DTR) &&
60003f80:	782b      	ldrb	r3, [r5, #0]
60003f82:	b13b      	cbz	r3, 60003f94 <debug::init(bool)+0x34>
60003f84:	7823      	ldrb	r3, [r4, #0]
60003f86:	07da      	lsls	r2, r3, #31
60003f88:	d504      	bpl.n	60003f94 <debug::init(bool)+0x34>
                ((uint32_t)(systick_millis_count - usb_cdc2_line_rtsdtr_millis) >= 15);
60003f8a:	6833      	ldr	r3, [r6, #0]
60003f8c:	683a      	ldr	r2, [r7, #0]
60003f8e:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc2_line_rtsdtr & USB_SERIAL_DTR) &&
60003f90:	2b0e      	cmp	r3, #14
60003f92:	d804      	bhi.n	60003f9e <debug::init(bool)+0x3e>
                { // we must wait for all the serial to be open. 
             // while (!Serial) { threads.delay(1); }
#ifdef _DEBUG_SERIAL
                while (!_DEBUG_SERIAL) { threads.delay(1); }
60003f94:	2101      	movs	r1, #1
60003f96:	481b      	ldr	r0, [pc, #108]	; (60004004 <debug::init(bool)+0xa4>)
60003f98:	f036 ffee 	bl	6003af78 <___ZN7Threads5delayEi_veneer>
60003f9c:	e7ee      	b.n	60003f7c <debug::init(bool)+0x1c>
		uint32_t millis_begin = systick_millis_count;
60003f9e:	4c17      	ldr	r4, [pc, #92]	; (60003ffc <debug::init(bool)+0x9c>)
				if (elapsed > 750) break;
60003fa0:	f240 29ee 	movw	r9, #750	; 0x2ee
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
60003fa4:	4f18      	ldr	r7, [pc, #96]	; (60004008 <debug::init(bool)+0xa8>)
		uint32_t millis_begin = systick_millis_count;
60003fa6:	6826      	ldr	r6, [r4, #0]
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
60003fa8:	f8df 8070 	ldr.w	r8, [pc, #112]	; 6000401c <debug::init(bool)+0xbc>
		yield();
60003fac:	f037 fd6c 	bl	6003ba88 <__yield_veneer>
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
60003fb0:	782b      	ldrb	r3, [r5, #0]
60003fb2:	b143      	cbz	r3, 60003fc6 <debug::init(bool)+0x66>
60003fb4:	783b      	ldrb	r3, [r7, #0]
60003fb6:	07db      	lsls	r3, r3, #31
60003fb8:	d505      	bpl.n	60003fc6 <debug::init(bool)+0x66>
		((uint32_t)(systick_millis_count - usb_cdc_line_rtsdtr_millis) >= 15);
60003fba:	6823      	ldr	r3, [r4, #0]
60003fbc:	f8d8 2000 	ldr.w	r2, [r8]
60003fc0:	1a9b      	subs	r3, r3, r2
		return usb_configuration && (usb_cdc_line_rtsdtr & USB_SERIAL_DTR) &&
60003fc2:	2b0e      	cmp	r3, #14
60003fc4:	d80b      	bhi.n	60003fde <debug::init(bool)+0x7e>
			uint32_t elapsed = systick_millis_count - millis_begin;
60003fc6:	6823      	ldr	r3, [r4, #0]
			if (usb_configuration) {
60003fc8:	782a      	ldrb	r2, [r5, #0]
			uint32_t elapsed = systick_millis_count - millis_begin;
60003fca:	1b9b      	subs	r3, r3, r6
			if (usb_configuration) {
60003fcc:	b90a      	cbnz	r2, 60003fd2 <debug::init(bool)+0x72>
				if (elapsed > 750) break;
60003fce:	454b      	cmp	r3, r9
60003fd0:	e001      	b.n	60003fd6 <debug::init(bool)+0x76>
				if (elapsed > 2000) break;
60003fd2:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
				if (elapsed > 750) break;
60003fd6:	d802      	bhi.n	60003fde <debug::init(bool)+0x7e>
			yield();
60003fd8:	f037 fd56 	bl	6003ba88 <__yield_veneer>
60003fdc:	e7e6      	b.n	60003fac <debug::init(bool)+0x4c>
#endif      
                }
            Serial.begin(2000000); // speed does not matter and is ignored. 
            _cout._serial = &Serial;
60003fde:	4b0b      	ldr	r3, [pc